# 第一阶段

## 一、软件的生命周期

软件的开发流程

## 1、软件定义期

### （1）可行性研究分析：

技术、人力、设备、时间、资金、回报、政策、风俗..

### （2）功能需求分析：

如：学子商城功能性需求分析

-   前台：<http://101.96.128.94:9999/>

-   后台：http://101.96.128.94:9999/admin/login

-   前台子系统：商品模块、用户模块、购物车模块

-   后台子系统：商品模块，用户模块、订单模块

-   移动端子系统：商品模块、用户模块、购物车模块

## 2、软件开发期

### （3）软件开发：

概要设计阶段------架构师（子系统、模块、模块间的接口、数据结构）

详细设计阶段------模块负责人（页面、主题内容、属性、算法）

### （4）编码实现阶段

UI设计------网页的效果图

前端------将网页效果图转为html、css、js文件

后端------负责提供网页中所需要的数据

### （5）测试阶段

软件测试工程师

## 3、软件维护期

### （6）部署阶段：

将软件部署到服务器

### （7）维护阶段

## 二、服务器

Sever：客户端提供各种服务的功能强大的计算机

## 1、访问服务器：

-   服务器地址：域名/IP地址

-   使用该服务对应的端口号

-   提供该服务的协议

如 <http://101.96.128.94:9999/>

-   http:// 协议

-   101.96.128.94 IP地址（域名）

-   :9999 端口号

## 2、访问本机服务器

### （1）启动自己电脑的网页服务器

双击打开C:\\WebServer\\start.cmd,启动服务器

### （2）使用浏览器访问自己电脑上网页服务器

IP地址：127.0.0.1端口号：:80协议：http://

-   使用IP地址访问：http://127.0.0.1:80

-   使用域名访问：<http://localhost:80>

### （3）将文件部署到自己电脑的服务器上

C:\\WebServer\\public 目录就是自己电脑上的网页服务器目录，将文件放到该目录就是部署到服务器上

### （4）通过局域网访问自己电脑的服务器

服务器IP地址：<http://192.168.1.104:80>

查看自己电脑在局域网的IP地址

cmd命令下输入Ipconfig查看 以太网适配器 以太网 IPv4地址\*（有线）；无线适配器 IPv4地址\*（无线）

## 三、数据库（mysql数据库）

## 1、数据库概述

计算机数据的存储方式有：内存/特定的文件/第三方云服务/数据库服务器，其中数据库就是按照特定的形式来组织存储数据，是为了对数据的操作方便------增删改查，数据库按发展的历史可以分为网状数据库---层次型数据库---关系型数据库---非关系型数据库。

常见的关系型数据库：常见的关系型数据库：SQLsever，Qracle，MysQl，DB2....

关系型数据库的逻辑结构：

+---------------------------------+
| sever→database→table→row→column |
|                                 |
| 服务器 数据库 数据表 行 列      |
+---------------------------------+

## 2、mysql数据库

免费、开源、号称中小型数据、兼容各种操作系统。

MySQLAB（瑞典） -\> SUN公司 -\> Oracle公司

-   Martin: mariaDB

-   Oracle: mysql

XAMPP：服务器套装，包含多个服务器端软件

### （1）mysql部署结构

-   服务器端：负责存储/维护数据。

-   开启服务器：C:\\xampp\\mysql\\bin\\mysqld.exe前提是确保3306端口不被占用

-   客户端：负责连接服务器，对数据增删改查

-   打开客户端工具：C:\\xampp\\mysql\\bin\\mysql.exe

使用客户端连接服务器端

Mysql.exe -h127.0.0.1 --P3306 --uroot --p 简写：mysql -uroot

-   h host：服务器的域名或IP地址，默认不能使用局域网IP

-   --P port：端口号

-   --u user：用户名 root为管理员

-   -p password：密码 root的密码默认为空

### （2）常用的管理命令

所有命令加英文分号结束

-   Quit; 退出服务器连接

-   Show databases; 显示服务器下所有的数据库

-   Use 数据库名; 进入指定数据库

-   Show table；显示当前数据库所有的数据表

-   desc 表名；描述表中都有哪些列（表头）

### （3）常用的SQL命令

结构化查询语言，用来操作关系型数据库；主要用于对数据的增删改查

##### SQL命令的两种执行方式

-   交互模式：客户端输入一行，点击回车，服务器端执行；适用于临时性的查看数据。

-   脚本模式：客户端把所有要执行的命令写在一个脚本文件中，一次性交给服务器执行，适用于批量的操作数据。

mysql --uroot\< sql文件路径

在连接mysql的同时，提交脚本文件，不能进入mysql里面操作。

##### SQL语法规范

一条SQL语句可以跨越多行，以英文的分号结尾

假设某一条语句出现错误，则此条语句后面所有语句不再执行

SQL命令不区分大小写，习惯上关键字大写，非关键字小写

分为单行注释（\#\...）和多行注释（/\*\*/），注释的内容不再被执行

##### 常用的SQL命令

-   DROP DATABASE IF EXISTS 数据库; 丢弃已经存在的数据库

-   CREATE DATABASE 数据库; 创建一个新的数据库

-   USE 数据库; 进入创建的数据库

-   CREATE TABLE t1(

-   id INT,

-   Age TINYINT;

-   Phone CHAR(11),

-   Price DECIMAL(6,2),

-   Sex BOOL,

-   Ctime DATETIME

-   Article VARCHAR,

-   score INT

-   ); 创建保存数据的表

-   INSERT INTO student VALUES(\'1\', \'tom\', \'M\', \'97\'); )插入数据，数值型数据可以不加引号

-   SELECT \* FROM student; 查询数据

-   UPDATE user SET phone=\'19988888888\',isOnline=\'n\' WHERE uid=\'2\'; 修改数据

-   DELETE FROM user WHERE uid=\'3\'; 删除数据

**练习**

**1.编写脚本文件xz.sql，先丢弃数据库xz如果存在，再创建数据库xz，进入该数据库，创建保存用户数据的表user，包含编号uid，用户名uname，密码upwd，电话phone，邮箱email，性别sex，真实姓名userName，注册时间regTime，是否在线isOnline；插入若干条数据**

**2..编写脚本文件01\_sina.sql，先丢弃数据库sina，创建新的数据库sina，进入该数据库，创建保存新闻数据的表news，包含有编号nid，标题title，发布时间ctime，来源origin；插入若3条数据，删除1条，修改1条。 注意：解决中文乱码**

### （4）中文乱码

##### 存储英文字符

ASCII码：总共有128个，对所有的英文字母及其符号进行了编码；如abc 979899

Latin-1:总共有256个，兼容ASCII码，同时对欧洲符号进行了编码

##### 存储中文字符

GB2312：对6千多常用的汉字进行了编码，兼容ASCII码

GBK：对两万多汉字进行了编码，兼容GB2312

BIG5：台湾繁体字编码

Unicode: 对世界上主流国家常用的语言进行了编码，具体存储方案有UTF-8,UTF-16,UTF-32

**mysql默认使用Latin-1编码，不兼容中文，所以出现乱码**

##### 解决mysql中文乱码

-   脚本文件另存为的编码为UTF8

-   客户端连接服务器端的编码为UTF8 ：SET NAMES UTF8;

-   服务器端创建数据库使用的编码为UTF8 ：CREATE DATABASE 数据库名 CHARSET=utf8；

![](media/image2.png){width="3.0608694225721784in" height="1.4779811898512687in"}

**练习：**

**编写脚本文件01\_sina.sql，先丢弃数据库sina，创建新的数据库sina，进入该数据库，创建保存新闻数据的表news，包含有编号nid，标题title，发布时间ctime，来源origin；插入若3条数据，删除1条，修改1条。 注意：解决中文乱码**

### （5）列类型

创建数据表时候，指定的列可以存储数据类型

##### 数值型

-   **TINYINT**：微整形，占一个字节 -128～127

-   **SMALLINT**：小整型，占两个字节-32768～32767

-   **INT**：整型，占4个字节-2417483648\~2147483647

-   **BIG**：大整型，占8个字符，范围很大

-   **FLOAT**：单精度浮点型，占4个字节，最多3.4E38，可产生数据误差

-   **DOUBLE**：双精度浮点型，占8个字节，范围比BIGINT大得多，可能产生计算误差

-   **DECIMAL（M,D）**：定点小数，不会产生计算误差,M代表总的有效位数，D代表小数点后的有效位置。

-   **BOOL**：布尔型，只有两个值TRUE/1,FALSE/0(不能加引号)，正在存储的时候，变成TINYINT,对应的数据1/0

-   注：bool型真正存储的时候自动转为tinyint类型

##### 日期时间型

-   **DATE**：日期型，'2019-12-28'

-   **TIME**：时间型，'15:24:30'

-   **DATETIME**：日期时间型，'2019-12-25 15:02:02'

##### 字符串型

-   **VARCHAR(M)**：变长字符串，不会产生空间浪费，操作速度相对慢，M最大值是65535

-   **CHAR(M)**：定长字符串，可能产生空间浪费，操作速度相对快，M的最大值是255（常用于存储固定长度的数据，如电话号码，身份证等）

-   **TEXT(M)**：大型变型字符串，M的最大值是2G。

**编写脚本文件02\_xuezi.sql，设置编码为UTF8，先丢弃再创建数据库xuezi，进入该数据库，创建保存笔记本数据的表laptop，包含编号lid，标题title，价格price，库存量stockCount，上架时间shelfTime，是否为首页推荐isIndex，插入若干条数据。**

**练习：**

**编写脚本文件03\_tedu.sql，设置编码为UTF8，先丢弃再创建数据库tedu，进入该数据库，创建保存部门数据的表dept，包含部门编号did、部门名称dname，插入以下数据**

**10 研发部 20 运营部 30 市场部 40 测试部**

**创建保存员工数据的表emp，包含编号eid，姓名ename，性别sex，生日birthday，工资salary，所属部门编号deptId，插入若干条数据。**

**练习：**

**编写脚本文件xz.sql，设置编码为UTF8，先丢弃再创建数据库xz，进入该数据库，创建笔记本家族的表laptop\_family，包含fid，名称fname，数量count,插入以下数据**

**10 联想 20 戴尔 30 小米**

**创建保存笔记本数据的表laptop，包含lid，title，price，规格spec，详情detail，上架时间shelfTime，是否在售isOnsale，所属家族编号familyId；插入若干条数据；**

### （6）列约束

约束，数据库中某列上的数据往往必须符合某种规范，如编号不能重复、年龄必须在一定范围、密码有长度限制、员工所在部门必须真的存在\...\...类似的限制/规范就称为"列约束"。Mysql可以对要插入的数据进行特定的验证，只要满足条件才可以插入，否则被认为是非法的插入。

##### 主键约束：PRIMARY KEY

声明了主键约束的列上（通常加在id列），不能出现重复值，也不能出现NULL，所有的记录会自动按照主键列上的值由小到大排序，因此一个表中至多只能有一个主键列。

+---------------------------------------------------------------------------------------------------------------+
| NULL 表示空，在插入数据时，无法确定的数据通常用NULL，例如无法确定一个员工的性别，生日，无法确定商品的价格等； |
|                                                                                                               |
| 注；使用时NULL不能加引号。                                                                                    |
|                                                                                                               |
| 两个NULL比较是不等的。                                                                                        |
+---------------------------------------------------------------------------------------------------------------+

##### 非空约束；NOT NULL

声明为非空的列，不能出现NULL，但可以出现重复值。

##### 唯一约束：UNIQUE

声明唯一约束的列，不能出现重复值，但可以出现NULL，且允许出现多个NULL。

##### 检查约束

检查约束可以检查新插入的数据是否满足指定的条件

CREATE TABLE student(

Score TINYINT CHECK(score\>=0 score \<=100)

);

注：mysql不支持检查约束，检查约束会影响数据插入速度。对服务器造成较大压力。

##### 默认值约束：DEFAULT

具体两种方式可以应用默认值

INSERT INTO laptop\_family VALUES(\'34\',\'神州\',DEFAULT);\#应用默认值方法一

INSERT INTO laptop\_family(fid,fname) VALUES(\'35\',\'惠普\');\#应用默认值方法二

##### 外键约束 FOREIGN KEY

声明了外键约束的列上，取值范围必须到另一个表的主键中，两者的列类型要保持一致，允许使用null或者多个null，FOREIGN KEY (列) REFERENCES 数据表（主键列）

FOREIGN KEY (familyId) REFERENCES laptop\_family(fid)

##### 自增列 AUTO\_INCREMENT

自动增长，如果声明一个自增列，无需手动复制，直接赋值为NULL，会获取当前最大值，然后加1插入

注：只适用于整数型的主键列，自增列允许手动赋值。

### （7）简单查询

##### 1.查询特定的列

-   Select 列名称，列名称from 表名; 例如：select ename,salary from emp;

##### 2.查询所有的列

-   Select \* from 表名; 例如：select \* from emp;

##### 3.给列起别名（as）

-   Select 列名as 新列名,列名 as 新列名from 表名; 例如：select ename as 姓名from emp;

注：AS可以省略，保留空格即可；起别名是为了简化列名称

##### 4.显示不同记录/合并相同的项（distinct）

Select distinct deptid from emp; 只显示emp表中不同的deptid（查看员工都分布在哪些部门）；

##### 5.查询时执行计算（+,-,\*,/）

select ename,salary\*12 from emp; 查询员工的姓名和年薪；

select ename 姓名,(salary+700)\*12+8000 年薪 from emp;起别名和算员工的年薪

##### 6.查询的结果集排序（order by）

select \* from dept order by did ASC; 查询dept表中的did列升序排列

select \* from dept order by did desc; 查询dept表中的did列降序排列

注：asc为ascendant单词的缩写；desc为descendant单词的缩写。

如果排序规则为空，则默认按升序排列（ASC）

select \* from emp order by salary,birthday; 按员工工资升序排列，工资相同则按年龄从大到小

select \* from emp order by sex,ename; 按员工性别排序，性别相同则按姓名升序

##### 7.条件查询（where语句）

select \* from emp where eid=5; 查询编号为5的员工所有信息；

select eid,ename,sex,salary from emp where ename=\'Lucy\';查询姓名为lucy的id，性别和工资；

select \* from emp where salary\>6000 and sex=1;查询工资大于6000并且性别为男性的员工

Select \* from emp where deptid is null; 查询部门编号为null的员工

Select \* from emp where deptid is not null;查询部门编号不为null的员工

注：比较运算符\>,\<,\>=,\<=,!=(不等于)

-   **IS NULL/IS NOT NULL**

-   **AND/OR**

-   **BETWEEN AND/ NOT BETWEEN AND**

-   **IN()/ONT IN()**

##### 9.模糊条件查询（like）

select \* from emp where ename like \'%e%\'; 查询出姓名中含有字符e的员工

select \* from emp where ename like \'%e\'; 查询出姓名中以e结尾的员工

select \* from emp where ename like \'%e\_\'; 倒数第二个字符为e

注：LIKE'%关键字%' 其中%可以匹配零个或者多个字符

"\_"可以匹配任意一个字符

##### 10.分页查询

如果查询的结果集中有太多的数据，一页显示不完，可以分页显示。前提要有两个已知条件：每页的数据量和当前的页码。

select \* from emp limit start,count

-   ![](media/image3.png){width="2.8869564741907263in" height="1.6in"}**start:表示从哪一条数据开始查询**

-   **count：表示每页的数量**

-   **start=（页码-1）\*count**

假设每页显示5条数据

第一页：select \* from emp limit 0,5;

第二页：select \* from emp limit 5,5;

第三月：select \* from emp limit 10,5;

### （8）复杂查询

##### 1、聚合查询/分组查询

聚合函数：函数是一个功能体。提供若干个数据，得到结果

**COUNT(数据)/SUM(数据)/ AVG(数据)/MAX(数据)/MIN(数据)**

**数量 总和 平均数 最大值 最小值**

select count(ename) from emp; 查询所有员工的数量

select sum(salary) from emp; 查询所有员工工资总和

select avg(salary) from emp where sex=1; 查询男员工平均工资

select min(salary) from emp; 查询工资最低/高的员工

分组查询：**Group by；**只能查询聚和函数以及分组条件。

select deptId ,max(salary) from emp group by deptId;

select sex,max(salary),min(salary),avg(salary) from emp group by sex;

select year(birthday) from emp; 查询所有员工出生的年份（提取年份用**year**，提取月份用**month**）

select \* from emp where year(birthday)=1991; select \* from emp where month(birthday)=12;

##### 2、子查询

一条查询语句的结果作为另一条查询语句的条件

select \* from emp where deptId=(select did from dept where dname=\'研发部\');查询出研发部的所有员工

select \* from emp where salary\>=(select salary from emp where ename=\'tom\'); 查询比Tom工资高的员工有哪些

select \* from emp where year(brithday)=(select year(brithday) from emp where ename=\'tom\'); 查询出tom同一年出生的员工有哪些

##### 3、多表查询

查询结果包含多个表的信息（表之间要有关联）

select ename,dname from emp,dept where deptId=did; 查询出所有员工的姓名及其部门名称

以上的查询结果中，无法查询到没有部门的员工，无法查询到没有员工的部门；

如何解决以上问题：

-   1、内连接 INNER JOIN\...ON 和上面的查询结果一样

select ename,dname from emp inner join dept on deptId=did;

-   2、左外链接 LEFT OUTER JOIN ..ON (outer关键字可省略)

select ename,dname from emp left outer join dept on deptId=did; 显示左侧表中所有的记录

-   3、右外连接 RIGHT OUTER JOIN\...ON (outer关键字可省略)

select ename,dname from emp right join dept on deptId=did; 显示右侧表中所有的记录

-   4、全连接-显示左侧和右侧所有的记录

Full join，mysql不支持，mysql可以通过通过union合并相同记录实现

> UNION ALL 不合并相同的记录
>
> UNION 合并相同的记录

**练习：**

**查询出工资在8000以上的女员工的姓名、性别、生日，结果集按照工资的降序排列，最后显示前两个人。**

**select ename,sex,birthday,salary from emp where salary\>8000 and sex=0 order by salary desc limit 0,2;**

**select ename,sex,birthday from emp where salary\>8000 and sex=0 order by salary desc limit 0,2;**

小知识：时间单位；时间的写法是多种多样的，关于时间的列类型可能会用到BIGINT，是因为存储的日期时间是距离计算机元年的毫秒数 1秒=1000毫秒

学习一门编程语言的基本步骤：

(1)了解背景知识：历史、现状、特点、应用场景

(2)搭建开发环境

(3)变量和常量(4)数据类型(5)运算符(6)逻辑结构

(7)通用小程序(8)函数和对象(9)第三方的库和框架

(10)个人的项目

## 三 . JavaScript

推荐书：《JavaScript高级程序设计》（第三版）

## 1、JS概述

### （1）发展史

1995年，JS最早出现了Netscape的浏览器中

1996年，IE中也出现了JS，称为JScript

1997年，Netscape把JS提交给ECMA，指定标准规范ECMAScript

2009年，JS开始向服务器端发展，出现了Node.js

### （2）现状

JS既能开发浏览器的交互效果，也能进行服务器端的操作，例如数据库访问，web服务器创建

### （3）特点

-   解释型语言：编译一行执行一行，脚本文件无需编译，由JavaScript引擎解释执行；

-   弱类型语言：

-   基于对象：后期几乎所有操作都由对象完成

-   跨平台性：可以在多个操作系统执行

### （4）应用场景

-   制作浏览器端的交互效果（前端）

-   创建Web服务器，操作数据库等（后端）

## 2、JS的开发环境

### （1）浏览器

浏览器中有自带的JS解释器

### （2）服务器

需要安装Node.js，内含有V8引擎的JS解释器

Node --v 查看当前版本；Node.js下载地址：<https://nodejs.org/>

### （3）运行JS代码

-   浏览器端：把js文件嵌入到html文件中\<script src="js文件"\>\<script\>

-   服务器端：node.js上运行 node js文件 回车

### （4）JS语法规范

-   区分大小写

-   每行代码结尾的分号可加可不加，建议都加

-   注释分为单行（//\...）和多行（/\*\...\*/）

## 3、变量和常量

### （1）变量（var）

用来存储程序中的数据，如var x=1;var用于声明变量，变量的名称是x，储存的值为1；

##### 变量名称

-   变量名称可以由字母，数字，下划线\_，美元符号\$ 组成，但要遵循以下规则：

> 声明变量的名称开头不能是数字 如var 1a=3;
>
> 特殊符号不能作为变量名；如var b\#4=5;
>
> JavaScript中的关键字不能作为变量名；
>
> 变量名称可以是汉字，但实际不能用汉字作为变量名称，因为解析可能会出现乱码；

+--------------------------------------------------------------------+
| > 驼峰命名法：userName，userPwd，email，phone，.......（推荐使用） |
|                                                                    |
| 下划线命名法：user\_name user\_password,......                     |
+--------------------------------------------------------------------+

##### 变量赋值

-   变量可以被多次赋值，且可以是不同类型的值；

-   变量未赋值，则保存的值为undefined（未定义的）；var=d;d未赋值，保存值为undefind;

-   一次可以声明多个变量，如：var b1=1,b2=2,b3;

### （2）常量（const）

用于保存不可变化的值，声明常量必须赋值，不能为空，不能重新赋值；

## 4、数据类型

-   原始类型：

> 数值型（number），字符串型(string)，布尔型(boolean)，未定义型（undefind）,空（null）

-   引用类型

> javaScript中除了原始类型之外就是对象。特殊对象有全局对象、数组（arry）、函数（function）

-   检查数据类型(**typeof**); 如：Console.log(typeof f1);

### （1）数值型（number）

-   整型和浮点型

```{=html}
<!-- -->
```
-   八进制（以0开头）和十六进制（以0x开头）

-   指数形式：e3/e-3代表10的3/-3次方

### （2）字符串型（string）

被引号所包含的数据就是字符串型，不区分单双引号

查看任意一个字符的Unicode码：\'a\'.charCodeAt()

### （3）布尔型（boolean）

true / false，在程序表示真或者假，常用于保存一些是否的结果，例如是否登录，是否注册，是否为会员等

比较运算的结果也是布尔型 3\>1

### （4）未定义型（undefined）

只有一个值是undefined

声明了变量未赋值，则为undefined

### （5）空（null）

只有一个值是null，类型是object（对象），常和引用类型的数据一起使用。

### （6）数据类型转换

##### 隐式转换

在运算过程中，自动发生的数据类型转换；

1）加法的隐式转换：

-   数值型+字符串型：数值型转为字符串型，如2+\'3\'-\>\'23\'，其中加号(+)表示字符串之间拼接

-   数值型+布尔型：布尔型转为数值型，如2+true-\>3；2+false -\>2，其中true-\>1；false-\>0

-   字符串型+布尔型：布尔型转为字符串型，如\'2\'+true-\>\'2tru

减乘除的隐式转换

2）JS中减乘除的隐式转换：

如果运算符的两端不是数值，都自动转为数值型。

总结

**隐式转换中，如果加号两端中出现字符串，则数据转为字符串型，执行拼接；其他情况都是自动调用number函数转为数值型**。

##### 强制转换

-   强制转换数值型Number()；NAN：Not a Number，NaN和任何值执行运算结果都是NaN

-   强制转整型parseInt()：通常是将浮点（小数）型或数字开头字符串型转整型，其他的都是返回NaN；

-   强制转浮点型parseFloat()：通常是将字符串型转浮点型，其他的都是返回NaN；

-   强制将数值和布尔型转为字符串toString

将数值和布尔值转为字符串后需要保存

到新变量中（js中字符串是不可变类型）

> var num=5;
>
> var num1=num.toString();

-   强制转换为布尔型：只有五个值被转为false（0, null, NaN, undefined, \"\"），其余都是ture。

## 5、运算符

**表达式：**由运算符所连接的操作数据，所组成的形式。

运算符分为算术运算符、比较运算符、逻辑运算符、位运算符、赋值运算符、三目运算符

注意JS中的运算符优先级

### （1）算术运算符

-   \+ - \* / 加减乘除

-   %取余：判断是否闰年，判断奇数和偶数

-   ++自增：在原来的基础上加1；

-   \--自减： 在原来基础上减1

**注意区分++a和a++的区别，++a先自增再赋值，a++先赋值再自增**

### （2）比较运算符

-   \< \>= \<=

-   ==(等于) !=(不等于)：比较值（可能发生隐式转换）

-   ===(全等于) !==不全等于：比较值和类型

注：

**条件中判断是否相等都用===**

数字和字符串比较：字符串转为数字

字符串比较：比较的是两个首字符的unicode码

任何值和NaN（包含本身）比较都是返回false；

### （3）逻辑运算符

-   && 并且：关联的两个条件都是true，结果是true，否则false；

-   \|\| 或者：关联的两个条件有个一是true，结果是true，否则false；

-   ! 非：取反

注：优先级：一条语句如果出现并且和或者，先执行并且再执行或者

**短路逻辑：**在逻辑运算中，如果前一个条件已经可以得出最终结论，则后续内容不再执行，只有前一个条件不足以得出最终结论时，后一个条件才会执行。

在&&运算中，如果第一个条件为false，不再执行第二个条件

在\|\|运算中，如果第一个条件为true，不再执行第二个条件

逻辑运算带有隐式转换。默认会将两遍的值尝试转换为bool型，再决定执行或返回哪个值。

### （4）位运算符（了解）

在执行运算的时候，计算机会把数据转换成二进制再运算。

十进制和二进制转换过程中可能会出现误差，通常只存在小数的运算中。

按位与（&）

按位或（\|）

### （5）赋值运算符

= += -= \*= /= %=

其中+=，-=，\*=，/=称为计算赋值，即先执行计算再执行赋值；

a+=1等同于a=a+1；

### （6）三目运算符

-   一目，由一个运算符连接的一个操作数据或表达式；如a++; a\--; !（取反）

-   二目，由一个运算符连接的两个操作数据或表达式：+ - \* /\...

-   三目，由两个运算符连接的三个操作数据或表达式

**三目运算**的语法结构：条件表达式 **?** 表达式1 **:** 表达式2

如果条件表达式为true，执行表达式1；

如果条件表达式为false，执行表达式2；

## 6、流程控制

程序=数据+算法。程序的执行方式分为顺序执行、选择执行、循环执行。

### （1）分支结构（选择执行）

+--------------------+----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| 条件语句           | if语句                                       | 条件表达式中可以放任何形式的数据                                                                                                     |
|                    |                                              |                                                                                                                                      |
|                    | if(条件表达式){                              | 0 NaN '' undefined null 这几个数据会隐式转为false，其余的均为true。                                                                  |
|                    |                                              |                                                                                                                                      |
|                    | 语句1                                        | 如果if后的大括号中只有一行语句，则可以省略大括号。                                                                                   |
|                    |                                              |                                                                                                                                      |
|                    | }                                            |                                                                                                                                      |
+====================+==============================================+======================================================================================================================================+
|                    | if else语句                                  |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | if(条件表达式){                              |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | 语句1                                        |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | }else{                                       |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | 语句2                                        |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | }                                            |                                                                                                                                      |
+--------------------+----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
|                    | if-else嵌套                                  |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | if(条件表达式1){                             |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | 语句1                                        |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | }else if(条件表达式n){                       |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | 语句n                                        |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | }else{                                       |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | 语句n+1 //如果以上所有的条件表达式都是falss} |                                                                                                                                      |
+--------------------+----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| 特殊的多项分支语句 | switch-case语句                              | 根据一个表达式的不同值来选择执行相应的语句。                                                                                         |
|                    |                                              |                                                                                                                                      |
|                    | switch(表达式){                              | 表达式在和case后的值比较的过程中，使用的是全等于，要求值和类型相同。                                                                 |
|                    |                                              |                                                                                                                                      |
|                    | case值1: //如果表达式的值为1，               | 对比switch-case和if-else嵌套，前者只能进行全等于的比较，后者可以使用各种比较运算，使用范围更广，结构上也更为清晰合理，执行效率更高。 |
|                    |                                              |                                                                                                                                      |
|                    | > 语句1;                                     |                                                                                                                                      |
|                    | >                                            |                                                                                                                                      |
|                    | > break;                                     |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | case值n: //如果表达式的值为，                |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | > 语句n;                                     |                                                                                                                                      |
|                    | >                                            |                                                                                                                                      |
|                    | > break;                                     |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | default:                                     |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | 语句n+1; //以上表达式和每个值比较都是false； |                                                                                                                                      |
|                    |                                              |                                                                                                                                      |
|                    | }                                            |                                                                                                                                      |
+--------------------+----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+

  提升练习：
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  分别弹出两次提示框，要求用户输入商品的单价和数量，计算出总价，如果总价满600打9折；假设卡内余额有1000，如果足以支付，警示框弹出\'pay success\'，否则警示框弹出\'pay error\'。
  声明变量保存一个人的成绩，90以上打印'优秀'，80\~90以下打印'良好'，70\~80以下打印'中等'，60\~70以下打印'及格'，否则打印'不及格'

### （2）循环结构（循环执行）

+--------------+----------------------------+---------------------------------------------------------+
| while循环    | 初始值                     | 循环：一遍又一遍执行相同或相似的代码                    |
|              |                            |                                                         |
|              | while(循环条件){           | 循环的三个要素：                                        |
|              |                            |                                                         |
|              | 循环体;                    | 1.  循环条件：控制循环的次数；                          |
|              |                            |                                                         |
|              | 步长；                     | 2.  循环体：重复执行相同的代码；                        |
|              |                            |                                                         |
|              | }                          | 3）循环中还需加入初始值、步长。                         |
+==============+============================+=========================================================+
| do-while循环 | do{                        | 先执行循环体，在执行循环条件，循环条件是false时结束循环 |
|              |                            |                                                         |
|              | 循环体                     | 不管循环条件是否为true，都会执行一次循环体              |
|              |                            |                                                         |
|              | }                          |                                                         |
|              |                            |                                                         |
|              | while(循坏条件)            |                                                         |
+--------------+----------------------------+---------------------------------------------------------+
| for循环      | for(初始值;循环条件;步长){ | 1）执行初始值，判断循环条件，                           |
|              |                            |                                                         |
|              | 循环体                     | 2）如果循环条件是true执行循环体，false结束循环          |
|              |                            |                                                         |
|              | }                          | 3）如果执行完循环体，执行增量；重新执行第二步。         |
+--------------+----------------------------+---------------------------------------------------------+

注

for循环中的初始值，循环条件，步长可以不放在括号里面，但要保留for循环的结构即for( **;** **;** ); 如果有多个循环条件，后边的起作用。

##### 循环中break和continue关键字

**break关键字**：

可以结束任何形式的循环，

当break执行后，

后边所有的循环体和循环条件都不执行；

**continue关键字**：

跳过本次循环体，继续执行下一次循环

##### 循环嵌套

在循环体中存在另一个循环，任意多个之间都可以相互嵌套

外层循环：控制循环的行数,i就是行数

内层循环: 控制每一行循环的列数

每一行的循环条件是由所在的行数决定

总结：

**求和初始值为0，求乘积初始值是1，记录执行次数初始值为0，拼接初始值为空字符''；**

**求循环次数，声明变量保存次数，每循环一次次数加1；**

  提升练习：
  ----------------------------------------------------------------------------------------------------------------
  计算1\~100之间所有整数的和，当和大于4000的时候，提前结束循环，并打印出此时总和是多少，以及当前循环到了哪个数字
  有一张0.0001米的纸，对折多少次可以达到珠穆朗玛峰的高度8848，写出响应的程序即可
  打印99乘法表

## 7、函数

函数分为系统函数和自定义函数：function 是一个功能体，可以接受若干个参数，返回特定的值。

### （1）创建函数

+----------------------+----------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| 创建普通函数         | function 函数名称(){                                     | 调用：函数名称()                                                                                                                     |
|                      |                                                          |                                                                                                                                      |
|                      | 函数体------封装的反复执行的代码                         | 调用后就会执行函数体中的代码                                                                                                         |
|                      |                                                          |                                                                                                                                      |
|                      | }                                                        |                                                                                                                                      |
+======================+==========================================================+======================================================================================================================================+
| 创建带有参数的函数   | function 函数名称(参数列表){ //参数列表用于接收数据-形参 | 创建函数时候的参数称为形参，调用函数时候的参数称为实参，实参会赋值给形参；实参的数量可以是0个或者多个，未被赋值的形参值为undefined。 |
|                      |                                                          |                                                                                                                                      |
|                      | 函数体                                                   |                                                                                                                                      |
|                      |                                                          |                                                                                                                                      |
|                      | }                                                        |                                                                                                                                      |
|                      |                                                          |                                                                                                                                      |
|                      | 调用函数名称(参数列表) //真正传递数据-实参               |                                                                                                                                      |
+----------------------+----------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| 创建带有返回值的函数 | function 函数名称(参数列表){                             | 调用：函数名称(参数列表)                                                                                                             |
|                      |                                                          |                                                                                                                                      |
|                      | 函数体                                                   | return：表示函数执行后返回的结果，可以保存下来，函数调用后会得到return的值                                                           |
|                      |                                                          |                                                                                                                                      |
|                      | return 值; //返回值，函数调用后返回结果                  |                                                                                                                                      |
|                      |                                                          |                                                                                                                                      |
|                      | }                                                        |                                                                                                                                      |
+----------------------+----------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
|                      | 如果没有return或return后没有返回值，结果都是undefined    |                                                                                                                                      |
|                      |                                                          |                                                                                                                                      |
|                      | return执行以后,函数内return后面的所有代码不会执行        |                                                                                                                                      |
+----------------------+----------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+

### **（4）变量的作用域（必考）**

作用域：变量或者函数可以访问的范围

-   函数作用域：在函数中使用var声明的变量，叫做**局部变量**，只能在函数内部访问，不能在外部访问到。

-   全局作用域：在全局作用域下声明的变量，叫做**全局变量**，可以在任意合法位置访问到。

**在函数内部使用var声明的变量是局部变量，不使用var声明的变量是全局变量**

+---------------------------------------------------------------------+--------------------------------+
| function fn(n){                                                     | function fun(){                |
|                                                                     |                                |
| //赋值 var n=5;                                                     | var m1=m2=m3=8;                |
|                                                                     |                                |
| //函数体                                                            | }                              |
|                                                                     |                                |
| }                                                                   | fun();                         |
|                                                                     |                                |
| fn(5);相当于把5赋给了n                                              | console.log(m1);//m1是局部变量 |
|                                                                     |                                |
| console.log(n);//无法打印，因为形参是一个局部变量，无法被外部访问。 | console.log(m2);//m2是全局全局 |
|                                                                     |                                |
| **考点：变量的作用域**                                              | console.log(m3);//m3是全局变量 |
|                                                                     |                                |
|                                                                     | **考点：是否用var声明了变量**  |
+---------------------------------------------------------------------+--------------------------------+

**变量的声明提升**：JS程序执行前，会将使用var关键字声明的变量提升到所在作用域的最前边（全局和函数），赋值还是在原来的位置

+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------+
| //var a;var声明的变量提升到所在作用域的最前边                                                                                | var n=9;                                                               |
|                                                                                                                              |                                                                        |
| console.log(a);                                                                                                              | function fun(){                                                        |
|                                                                                                                              |                                                                        |
| var a=1;//a=1;赋值还在原来的位置                                                                                             | console.log(n); //首先访问当前作用域下之前是否有n，没有才会再往上找n； |
|                                                                                                                              |                                                                        |
| 执行代码的结果：**undefined**（未定义：只声明未赋值）                                                                        | var n=3; //提升到了当前作用域最前边                                    |
|                                                                                                                              |                                                                        |
| function fn(){                                                                                                               | }                                                                      |
|                                                                                                                              |                                                                        |
| console.log(b);                                                                                                              | fun();                                                                 |
|                                                                                                                              |                                                                        |
| var b=3; var声明的变量提升到所在作用域的最前边，如果不加var声明，就不存在变量的提升，运行代码就会报错，因为往上找不到变量b； | **考点：变量的声明提升**                                               |
|                                                                                                                              |                                                                        |
| }                                                                                                                            |                                                                        |
|                                                                                                                              |                                                                        |
| fn();                                                                                                                        |                                                                        |
|                                                                                                                              |                                                                        |
| 执行代码的结果：**undefined**（未定义：只声明未赋值）                                                                        |                                                                        |
+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------+

### **（5）函数的作用域（必考）**

函数作用域：函数访问范围也分为全局作用域和函数作用域。

-   函数作用域：在函数中使用function关键创建的函数，只能在当前函数下被调用

-   全局作用域：在全局下使用function关键字创建的函数，可以在任意作用域被调用

+--------------------------------------------------+--------------------------------------------------------------------------------+
| //全局作用域                                     | var n=3;                                                                       |
|                                                  |                                                                                |
| var n=1;                                         | function fn(n){                                                                |
|                                                  |                                                                                |
| function fn(){//全局作用域下的函数               | //var n=9 函数调用时，会将9赋给形参n；                                         |
|                                                  |                                                                                |
| var n=2;                                         | n=n+5;//让形参n在原来的基础上加5，所找到的是当前作用域下的形参n，而不是全局的n |
|                                                  |                                                                                |
| function fn1(){//函数作用域下创建的函数,局部函数 | }                                                                              |
|                                                  |                                                                                |
| console.log(n);                                  | fn(9);                                                                         |
|                                                  |                                                                                |
| }                                                | console.log(n);//打印的是全局的n；                                             |
|                                                  |                                                                                |
| fn1();//只能在当前函数下被调用                   |                                                                                |
|                                                  |                                                                                |
| }                                                |                                                                                |
|                                                  |                                                                                |
| fn();                                            |                                                                                |
+--------------------------------------------------+--------------------------------------------------------------------------------+

函数的提升：和声明变量提升一样，JS程序执行前，会将function创建的函数提升到所在作用域的最前边，调用可以在任意合法的位置。

+-----------------+--------------------------------------------------------------------------------------------+
| fun();          | 调用放在函数前也是可以的，因为使用function关键字创建的函数，可以提升到所在作用域的最前边。 |
|                 |                                                                                            |
| function fun(){ |                                                                                            |
|                 |                                                                                            |
| console.log(3); |                                                                                            |
|                 |                                                                                            |
| }               |                                                                                            |
+-----------------+--------------------------------------------------------------------------------------------+

### （6）斐波那契数列

有一对兔子，从第3个月开始，每个月都会生一对兔子，所生的兔子从第3个月开始，每个月都生一对兔子；

1 1 1 1 1 1

1 1 1 1

1 1 1

1 1

1 1

1

1

1

第1项和第2项是1，从第3项开始

每项的值是前两项相加的和

1 1 2 3 5 8 13 21 34 55 89 144\...

### （7）递归

在函数的内部调用自身，默认是死循环。

递归要有**结束条件**，结合**return**来使用。

+-------------------------+---------------------------------+---------------------------------+
| 弹出3次警示框，然后结束 | 使用递归计算1-n之间所有整数的和 | 使用递归计算斐波那契数列第n项值 |
+=========================+=================================+=================================+
| var i=0;                | function getSum(n){             | function fib(n){                |
|                         |                                 |                                 |
| function say(){         | if(n===1){                      | if(n===1 \|\| n===2){           |
|                         |                                 |                                 |
| alert(\'long ago\');    | return 1;                       | return 1;                       |
|                         |                                 |                                 |
| i++;                    | }                               | }                               |
|                         |                                 |                                 |
| if(i===3){              | return n+getSum(n-1)            | return fib(n-1)+fib(n-2);       |
|                         |                                 |                                 |
| return;                 | }                               | }                               |
|                         |                                 |                                 |
| }                       | getSum();                       | console.log(fib(10));           |
|                         |                                 |                                 |
| say();                  | console.log( getSum(100) )      | say();                          |
|                         |                                 |                                 |
| }                       | say();                          |                                 |
|                         |                                 |                                 |
| say();                  |                                 |                                 |
+-------------------------+---------------------------------+---------------------------------+

## 8、匿名函数

匿名函数：没有名称的函数：function () { \...}

### 函数表达式

+-----------------------------+----------------------------------+
| **函数声明方式创建函数**    | **函数表达式方式创建函数**       |
|                             |                                  |
| function函数名称(形参列表){ | var 函数名称=function(形参列表){ |
|                             |                                  |
| 函数体                      | 函数体                           |
|                             |                                  |
| }                           | }                                |
+-----------------------------+----------------------------------+

### （2）匿名函数自调用

全局污染：全局变量出现会影响所有作用域的变量；

开发原则：防止全局污染，尽量少用全局变量；

匿名函数自调用可以创建一个独立的函数作用域，防止全局污染。

(function(形参列表){

函数体；//函数作用域,里面的变量是局部变量，函数体中的变量和创建的函数只能在内部使用

})(实参列表);

+----------------------------------------------------------------+-----------------+
| (function(形参列表){                                           | (function(a){   |
|                                                                |                 |
| 函数体; //函数体中的变量和创建的函数只能在内部使用}(实参列表); | var num=1;      |
|                                                                |                 |
|                                                                | console.log(a); |
|                                                                |                 |
|                                                                | })(2);// 输出 2 |
+----------------------------------------------------------------+-----------------+

### （3）回调函数

**回调函数：将一个函数以实参形式传递，这个函数就称为回调函数；**

目的：就是为了确保一个函数执行完以后，再去执行另一个函数

function fn(a){//2、此时a是一个函数,如果要执行传递的函数中的函数体代码，需要调用函数

a();//3、调用函数：执行函数中的函数体代码；

};

fn(function(){......})//1、把function(){...}以实参的形式传给a

## 9、全局函数

全局函数又称为系统函数：

  **number**         将数据转为数值
------------------ ----------------------------------------------------------
  **parseInt()**     将数据转为整型
  **parseFloat()**   将数据转为浮点型
  encodeURI()        对一个URL中的非英文字符编码
  decodeURI()        对已经编码的URL进行解码
  **isNaN()**        判断一个值转数值后是否为NaN；是true/不是false；
  isFinite()         判断一个值是否为有限值；是true/不是fale；Infinity 无限值
  **eval()**         执行字符串中的表达式；eval('1+1') 2

注：

0做除数返回的是Infinity(无穷)；

只有无穷不是有限值，其他都是有限值。

## 10、对象

对象属于引用类型数据，是由一组属性和方法的集合。

JS中的对象：自定义对象（用户创建的对象）；内置对象（JS提供的）；宿主对象（根据JS不同的执行环境来划分）。

自定义对象：对象字面量；内置构造函数；自定义构造函数

### （1）对象字面量创建对象

使用对象字面量创建对象：使用大括号**{ }**创建空对象；

-   属性名和属性值之间用冒号隔开；

-   多组属性之间用逗号隔开；

-   属性名引号可加可不加，如果含有特殊字符必须加引号

### （2）访问对象属性

**对象.属性名 对象\[\'属性名\'\]**

添加或修改对象：**对象.属性名=值**；**对象\[\'属性\'\]=\'值\'**

删除属性：delete 对象.属性名；delete 对象\[\'属性名\'\]

如果属性中含有特殊字符，必须使用中括号形式

如果访问不存在的属性，返回值是undefined

### （3）内置构造函数创建对象

使用内置构造函数创建对象：**new Object()** 创建一个空对象，需要单独添加每一个属性

添加对象：**对象.属性名=\'属性值\'**；**对象\[\'属性名\'\]=\'属性值\'**

### （4）遍历对象中的属性

访问对象中的每个属性（访问所有属性）

+------------------------------------------+
| **for**(var key **in** 对象){            |
|                                          |
| **key** 对象中每个属性                   |
|                                          |
| **对象\[key\]** 通过属性名找对应的属性值 |
|                                          |
| }                                        |
+------------------------------------------+

### （5）检测属性是否存在

-   对象.属性名**===**undefined true不存在；flase存在。

-   对象.**hasOwnProperty**('brand'); true存在；flase不存在。

-   '属性名' **in** 对象 true存在；flase不存在。

### （6）对象中的方法

方法也称成员方法，对应的是一个匿名函数。

### （7）对象与原始数据的区别（堆内存和栈内存）

两者的数据存储的方式不同：

-   原始数据是栈内存

-   对象是堆内存

![C:\\Users\\jiefe\\AppData\\Local\\Temp\\1583725820(1).png](media/image4.png){width="4.72in" height="1.612209098862642in"}

注：

-   null 空，类型是对象object

表示对象不指向任何的堆内存空间

-   如果堆内存中的对象不被

任何的地址指向，则该数据就会销毁

-   赋值为null就不再指向，如dong=null ran=null则堆内存中的数据就会销毁

## 11、数组（array）

数组：由多个元素组成的集合，每个元素就是一个数据（使用数组的含义：便于操作数据）

### （1）数组字面量创建数组

**\[**元素1**,**元素2**,**元素3**,**元素4,...**\]** 数组可以放任何形式的数据。

### （2）访问数组中的元素

**数组\[下标\]** （访问数组中的元素，即获取数组中的数据）

**下标是从0开始**，如果访问不存在的元素则返回**undefined**

### （3）内置构造函数创建数组

**new Array**(元素1,元素2,元素3,元素4,...)

new Array(3); 初始化元素个数为3，需要单独添加每个元素，也可以添加更多元素

### （4）数组的长度

**数组.length（**数组.length可查看数组中元素的个数，数组长度=元素个数

在数组的末尾添加新的元素 **数组\[数组.length\]=值**;

### （5）数组的分类

索引数组；以0以上的整数作为下标

关联数组：以字符串作为下标，每个元素需单独添加，不推荐使用有相关需要建议使用对象代替

数组.length无法获取关联数组的长度

### （6）遍历数组元素

1）for-in

既可以遍历关联数组，也可以遍历索引数组。（尽量不用for in来遍历索引数组，使用循环）

+----------------------------------------------------------+
| **for**(var key **in** 数组){                            |
|                                                          |
| **key** //要遍历的数组元素的**下标**(数字也可以是字符串) |
|                                                          |
| **数组\[key\]** //获取下标对应的**元素**                 |
|                                                          |
| }                                                        |
+----------------------------------------------------------+

2）循环 for while do-while

+--------------------------------------+
| 只能遍历索引数组                     |
|                                      |
| for(var **i=0;i\<数组.length**;i++){ |
|                                      |
| **i代表下标**                        |
|                                      |
| **数组\[i\]** 代表下标对应的元素}    |
+--------------------------------------+

### （7）数组方法（API）

API(application programming interface)应用程序编程接口，预定义好的一些方法或函数

  **toString()**                          将数组转为字符串；
--------------------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  **join(\'-\')**                         将数组转为字符串，默认是按照逗号分隔元素，也可以提供参数作为指定的分隔符。
  **concat(arr1,arr2,...)**               用于拼接多个数组：arr1,arr2\...是要拼接的数组
  **slice(start,end)**                    截取数组中的元素，返回一个新数组；start是开始的下标，end是结束的下标，不包括end；如果end为空表示截取到最后；下标是负数表示倒数
  **splice(start,count,val1,val2\...)**   删除数组中的元素，返回删除后的元素格式为数组，原数组会发生变化。start开始的下标，count删除的长度，val1,val2\...删除后补充的元素；如果count为空表示删除到最后，如果start为负值表示倒数。
  **reverse()**                           翻转数组元素,返回翻转后的数组；原数组也会发生变化
  **sort()**                              对数组元素进行排序，默认是按Unicode码从小到大，返回排序后的数组。
  **push(v1,v2,...)**                     在数组末尾添加元素，返回数组的长度，原数组会发生变化；v1，v2是要添加的元素
  **pop()**                               删除数组末尾的一个元素，返回删除的元素，原数组会发生变化
  **unshift(v1,v2,...)**                  往数组的开头添加元素，返回数组的长度，原数组会发生变化；v1，v2是要添加的元素；
  **shift()**                             删除数组开头的一个元素，返回删除的元素，原数组会发生变化

### （8）二维数组

数组中的每个元素也是数组 var=arr**\[ \[\], \[\], \[\]\... \]**

访问二维数组中的元素 arr**\[下标\]\[下标\];**

数组=null：数组赋值为null，不再指向任何一个堆内存数据，就会释放堆内存空间

## 12、字符串对象

包装对象：目的是让原始类型数据向引用类型数据类型一样，具有属性和方法。

JS中提供了三种包装对象：**String**、**Number**、**Boolean**

将任意类型转为字符串：

new String() 构造函数，强制将数据转为字符串型，返回对象

String() 普通函数，强制将数据转为字符串型，返回字符串（推荐写法）

注：包装对象和普通的字符串用法没有区别

### （1）转义字符

转换字符本身的意义，在要转义的字符前加反斜杠 **\\** ;

  **\\\'**     将有特殊意义的引号转换成 **普通字符**
------------ --------------------------------------------
  **\\n**      将普通字符ｎ，转义成 **换行符**
  **\\t**      将普通字符ｔ转义成 **制表符**（tab键效果）
  **\\\'\'**   双引号
  **\\b**      退格符
  **\\\\**     反斜杠

### （2）字符串API

API 作用------参数------返回值

  **.length()**               查看字符串的长度
--------------------------- ----------------------------------------------------------------------------------------------------------------------------
  **.charAt()**               查看下标对应的字符
  **.charCodeAt()**           查看某个字符的Unicode码
  **.indexOf()**              查看满足条件的第一个下标，如果找不到返回-1
  **.lastIndexOf()**          查看满足条件的最后一个下标，如果找不到返回-1
  **.toUpperCase()**          将英文字母转为大写
  **.toLowerCase()**          将英文字母转为小写
  **.slice(start,end)**       截取字符串，跟数组方法slice用法一样
  **.substring(start,end)**   截取字符串，start开始下标，end结束下标，end为空截取到最后；如果下标为负数，自动转成0，start和end的值不分大小，顺序可以颠倒
  **.substr(star,count)**     截取字符串，start开始的下标，count截取的长度，如果count为空截取到最后
  **.split(str)**             按照指定的字符将字符串分割为数组

### （3）匹配模式

用于查找、替换字符串

+-----------------+---------------------------------------------------+
| **search(str)** | 查找匹配的字符串，返回下标，如果找不到返回-1.     |
|                 |                                                   |
|                 | search(/Range/i) 正则表达写法：iignore 忽略大小写 |
+=================+===================================================+
| **match(str)**  | 查找匹配的字符串，返回满足条件的数组；            |
|                 |                                                   |
|                 | math(/Range/ig) 正则表达写法：ggobal 全局查找     |
+-----------------+---------------------------------------------------+
| **replace()**   | replace(/range/ig，str) 查找并替换字符串          |
+-----------------+---------------------------------------------------+

## 13、Date对象

用于对日期时间进行储存和计算

### （1）创建Date对象

-   new Date(\'2020/3/11 11:29:30\'); //2020-03-11T03:29:30.000Z（0时区时间）

-   new Date(2020,4,11,11,29,30); //2020-05-11T03:29:30.000Z（第二个0-11，对应实际1-12）

-   new Date(); //访问当前操作系统时间

-   new Date(1581234000000); //距离计算机元年的毫秒数

### （2）获取Date对象中的日期时间

**get**FullYear/Month/Date/Hours/Minutes/Seconds/Milliseconds/Day

**get**Time 距离计算机元年毫秒数

月份范围0\~11 使用的时候需要加1；星期范围0\~6 对应星期日\~星期六

### （3）获取本地字符串格式

-   toLocaleDateString() 年-月-日

-   toLocaleTimeString() 时:分:秒

-   toLocaleString() 年-月-日 时:分:秒

### （4）修改Date对象中的日期时间

**set**FullYear/Month/Date/Hours/Minutes/Seconds/Milliseconds

**set**Time修改距计算机元年时间,可能覆盖所有时间日期

+--------------------------------------+----------------------------------------+
| 提升练习：                           |                                        |
+======================================+========================================+
| 计算当前距离清明节还有x天x小时x分x秒 | 创建当前系统时间的对象，拼接以下效果： |
|                                      |                                        |
|                                      | 2020年3月11日 12:03:09 星期三          |
+--------------------------------------+----------------------------------------+

## 14、math对象

用于数学运算。math不需要创建对象，可以直接使用其中的API

  PI             获取圆周率                      console.log(Math.PI);
-------------- ------------------------------- ---------------------------------
  abs();         获取绝对值                      console.log(Math.abs(8-45));
  ceil()         向上取整                        console.log(Math.ceil(4.1));
  floor()        向下取整                        console.log(Math.floor(4.1));
  round()        四舍五入取整                    console.log(Math.round(4.1));
  max()          取一组数字的最大值              console.log(Math.max(2,3,9,7));
  min()          取一组数字的最小值              console.log(Math.min(2,3,9,7));
  pow(x,y)       求x的y次幂                      console.log(Math.pow(3,3));
  **random()**   取随机数,范围大于等于0，小于1   **c**onsole.log(Math.random());

  提升练习：
  --------------------------------------------------------------------------------------------------------------------------------
  双色球抽奖代码（红球：1-33之间随机取6个数字，不能重复，从小到大排序；蓝球：在1-16之间随机取1个，随机产生一个1-16的随机数即可）

## 15、number对象

将数据转为数据转为数值型，对数值进行管理。

  new Number()        将数据转为数值型，返回对象
------------------- ---------------------------------------------
  Number()            将数据转为数值型，返回数值
  Number.MAX\_VALUE   获取Number的最大值
  Number.MIN\_VALUE   获取Number的最小值
  toFixed(n)          保留小数点后n位
  toString(n)         将数值转为字符串同时设置进制，n为转换的进制

## 16、boolean对象

-   new Boolean()  将数据转为布尔型，返回对象

-   Boolean() 将数据转为布尔型，返回布尔型

-   !!值 隐式减号数据转为布尔型

## 17、错误处理

-   语法错误（SyntaxError）：错误使用了中文字符或缺少表达式、括号等

-   引用错误（ReferenceError）：使用未声明的变量

-   Type Error：错误的使用数据类型，例如对象中的方法名称写错。

-   Range Error：参数的使用超出范围

-   自定义错误：程序员自己指定的错误。

## 18、ES6新特征

ECMAScript6 第六套标准规范

### （1）块级作用域

使用let关键字声明的变量，只能在块级作用域下使用，不能被外部访问，不存在变量提升

块级作用域：{ }、for、while、do、if\.....所有**大括号**内的都是块级作用域；**循环条件中的括号**

作用：可以防止污染全局

### （2）箭头函数

箭头函数：是回调函数的另一种写法，和之前的匿名函数不完全一样

+-----------------+---------------------------------------------------------------------------------------------+
| sort((a,b)=\>{\ | **如果箭头函数的函数体只有一行代码，并且是return形式的，**可以**简化**为：sort((a,b)=\>a-b) |
| return a-b;     |                                                                                             |
|                 |                                                                                             |
| })              |                                                                                             |
+-----------------+---------------------------------------------------------------------------------------------+

### （3）函数中的参数

ES6允许给参数设置默认值，如果没有传递实参，自动调用形参的默认值（函数增强），通常都是倒着给形参设置默认值

+------------------------+
| function add(a,b,c=8){ |
|                        |
| console.log(a+b+c);}   |
|                        |
| add(2,5);              |
|                        |
| 输出：15               |
+------------------------+

### （4）模板字符串

**\` \`** (反引号) 这就是模板字符串，可以直接写任意的字符串不需要拼接，可以换行。

在模板字符串中使用**\${js表达式}**

\${}中可以放任何有返回值的js表达式，比如：变量, 运算, 三目, 函数调用， 创建对象， 访问数组下标。模板字符串会自动执行js表达式的结果，并拼接到最终生成的普通字符串中。

+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------+
|                                                                    | 创建一个员工对象，包含有编号，姓名，性别，工资；打印出 编号：2 姓名：xxx 性别：男 工资：8199.00￥ |
+====================================================================+==================================================================================================+
| let title=\'苹果air\';                                             | let emp={                                                                                        |
|                                                                    |                                                                                                  |
| let price=28888;                                                   | eid:\'1213\',                                                                                    |
|                                                                    |                                                                                                  |
| let madeIn=\'中国\';                                               | ename:\'tom\',                                                                                   |
|                                                                    |                                                                                                  |
| console.log(\`标题：\${title} 价格：\${price} 产地：\${madeIn}\`); | sex:0,                                                                                           |
|                                                                    |                                                                                                  |
| console.log(\`                                                     | salary:80000                                                                                     |
|                                                                    |                                                                                                  |
| 标题：\${title}                                                    | };                                                                                               |
|                                                                    |                                                                                                  |
| 价格：\${price.toFixed(2)}                                         | console.log(\`                                                                                   |
|                                                                    |                                                                                                  |
| 产地：\${madeIn}                                                   | 编号：\${emp.eid} 姓名：\${emp.ename} 性别：\${emp.sex=1 ? \'男\':\'女\'} 工资：\${emp.salary}   |
|                                                                    |                                                                                                  |
| \`);                                                               | \`);                                                                                             |
+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------+

### 四. Nodejs

下载网址：nodejs.org（官方网站）nodejs.cn（中文镜像）

## 1、NodeJs概述

Node.js运行在服务器的JS解释器，基于谷歌的V8引擎解释器，可以实现服务端操作，例如数据库操作，Web服务器的创建。

### （1）对比JS和Node.js的区别

-   JS运行客户端浏览器，存在多款浏览器，代码有兼容性问题；Node.js运行在服务器端，只有V8引擎一种解释器，不存在兼容性问题。

-   两者都有内置对象、自定义对象、宿主对象（根据执行环境的不同划分）

-   JS用于网页中的交互效果，nodejs用于服务器端的操作，例如数据库的操作，文件的操作\...

### （2）node.js的执行方式

-   脚本模式：**node 路径** 回车

-   交互模式：**node** 回车 进入交互模式 ；

-   退出交互：**ctrl+c** 两次 或者 **.exit** 回车

### （3）Node.js的特点

-   简单，避免过度设计

-   单线程逻辑处理

-   非阻塞的异步I/O处理

-   事件驱动编程

-   无锁机制，不会产生死锁

-   支持数万个并发连接

### （4）node.js的应用场景

-   Node.js 属于I/O密集型，可以解决数万个并发连接，适合基于社交网络的大规模Web应用，

-   Nodejs不适合CPU密集型的应用，如：递归、数据加密解密、数据挖掘和数据分析

## 2、全局对象

全局作用域下的变量就是全局对象下的属性，全局对象下的函数就是全局对象下的方法，可以使用全局对象来访问。

### （1）node.js：global

-   在交互模式下创建的函数和声明的变量都是全局global下的，可以使用**global**访问；

例如：var a=1;可以用global.a 访问

-   在脚本模式下，声明的变量和创建的函数都不属于全局下的，一个文件默认会去创建一个独立的作用域，叫做文件（模块）作用域，可以防止污染全局

### （2）JS：window

在浏览器下，在JS下创建的函数和声明的变量都属于是全局作用域下的，可以用**window**来访问；

例如：var a=1;可以用winodw.a 访问

### （3）console对象------控制台

console.log(1); 输出日志

console.info(2); 输出消息

console.warn(3); 输出警告

console.error(4); 输出错误

console.time(字符串); 开始计时

console.timeEnd(字符串); 结束计时

注：

开始计时和结束计时打印的内容要保持一致。

+--------------------------------+-----------------------------+--------------------------------+
| console.time(\'for\');         | console.time(\'while\');    | console.time(\'do-while\');    |
|                                |                             |                                |
| for (let i=1;i\<=10000 ;i++ ){ | let i=1;                    | i=1;                           |
|                                |                             |                                |
| }                              | while (i\<=10000){          | do                             |
|                                |                             |                                |
| console.timeEnd(\'for\');      | i++;                        | {                              |
|                                |                             |                                |
|                                | }                           | i++;                           |
|                                |                             |                                |
|                                | console.timeEnd(\'while\'); | }                              |
|                                |                             |                                |
|                                |                             | while (i\<=10000);             |
|                                |                             |                                |
|                                |                             | console.timeEnd(\'do-while\'); |
+--------------------------------+-----------------------------+--------------------------------+

### （4）process对象------进程

process.ach 查看当前CPU架构

process.platform 查看当前的操作系统

process.version 查看当前的node.js.的版本号

process.env 查看当前环境变量有哪些

process.kill(编号) 结束指定编号的进程

### （5）Buffer对象------缓冲区

缓冲区：在内存中临时存储数据的区域，通常网络传输的数据都是在缓冲区。

创建Buffer，并储存数据

> let buf=**Buffer.alloc(5,\'abcde\')** //设置buffer的空间大小为5个字节 如何存储不到5个，
>
> 会循环填满5个,一个汉字占3个字节

将Buffer数据转为字符串

**buf.toString()**或**String(buf)**

+-----------------------------------+
| let buf=Buffer.alloc(5,\'abcde\') |
|                                   |
| console.log(buf);                 |
|                                   |
| console.log(String(buf);          |
|                                   |
| console.log(buf.toString());      |
+-----------------------------------+

## 3、全局函数

### （1）一次性定时器

开启：var timer=**setTimeout(回调函数，间隔时间)**;时间单位是毫秒

清除：**clearTimeout(timer);**

+-----------------------------------+
| let timer=setTimeout( function(){ |
|                                   |
| console.log(\'hello timer\');     |
|                                   |
| },3000);                          |
|                                   |
| clearTimeout(timer);              |
+-----------------------------------+

### （2）周期性定时器

开启：var timer=**setInterval（回调函数，间隔时间），**每隔一段时间，执行一次回调函数

清除：**clearInterval（timer）**

+------------------------------+
| let timer=setInterval(()=\>{ |
|                              |
| console.log(\'滴滴滴\');     |
|                              |
| },5000);                     |
|                              |
| clearInterval(timer);        |
+------------------------------+

### （3）立即执行定时器

开启：let timer=**setImmediate（回调函数）**，在事件队列的开头执行。

清除：**clearImmediate（timer）**

另一个立即执行器

**process.nextTick(回调函数)**，在主程序后面执行。

![C:\\Users\\jiefe\\AppData\\Local\\Temp\\1584176398(1).png](media/image5.png){width="3.2695647419072618in" height="1.8347812773403325in"}执行顺序：主程序 主程序后 事件队列

+---------------------------------------------------+---+
| 练习：使用周期定时器打印'滴滴滴'，3次后清除定时器 |   |
+===================================================+===+
| var i=0;                                          |   |
|                                                   |   |
| var timer=setInterval(()=\>{                      |   |
|                                                   |   |
| console.log(\'滴滴滴\');                          |   |
|                                                   |   |
| i++;                                              |   |
|                                                   |   |
| if(i===3){                                        |   |
|                                                   |   |
| clearInterval(timer);                             |   |
|                                                   |   |
| }                                                 |   |
|                                                   |   |
| },3000);                                          |   |
+---------------------------------------------------+---+

## 4、模块

模块是一个独立的功能体，在Node.js下规定，任意一个文件就是一个模块。可以引入其他模块，也可以被其他模块引入。分为自定义模块、核心模块、第三方模块。

### （1）模块中的参数

nodejs.自动为每个文件添加了一个构造函数。在文件中声明的变量自动被函数包含，所以不属于全局下，是局部变量。

**(function(exprots,require,module,\_\_filename,\_\_dirname){**

程序员自己写的代码

**});**

-   require:是一个函数，用于引入另一个模块， (\'./\*\*\*.js\')，如：**require(\'./08\_2.js\')**

-   exports:是要导出的对象，如果要导出内容，都是往这个对象中添加

-   module:是当前模块的对象

-   module.exports : 当前模块要导出的对象；默认和module.exports指向同一个对象

> **exports是module.exports的别名（简写），作用等同于module.exports。**

-   \_\_filename:当前模块的绝对路径和模块名称

-   \_\_dirname:当前模块的绝对路径

注：

如果要导出对象，需要把要导出的对象赋值给module.exports，此时module.exports就不再指向同一个对象了。

![](media/image6.png){width="3.086956474190726in" height="1.2279735345581801in"}

### （2）模块的分类

引用文件模块和目录模块

+----------+------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
|          | 引入以以路径开头的模块                                                                               | 引用不以路径开头的模块                                                                              |
+==========+======================================================================================================+=====================================================================================================+
| 文件模块 | **require（'./**文件名称**'）**                                                                      | **require('**querystring'**)**                                                                      |
|          |                                                                                                      |                                                                                                     |
|          | 用于引入用户自定义模块，后缀名是js的话js可以省略。                                                   | 常用于引入官方的核心模块                                                                            |
+----------+------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| 目录模块 | **require(\'./**目录名称\'**)**                                                                      | **require(\'**目录名称**\')**                                                                       |
|          |                                                                                                      |                                                                                                     |
|          | 首先会到目录下查找package.json下main属性对应的文件（固定格式如下），如果找不到才会自动引入index.js。 | 首先会到当前目录下的node\_modules目录中寻找对应的目录模块，如果找不到会到上一级寻找，直到顶层目录。 |
|          |                                                                                                      |                                                                                                     |
|          | {                                                                                                    | 常用于引入第三方模块                                                                                |
|          |                                                                                                      |                                                                                                     |
|          | \"\":\"文件名\"}                                                                                     |                                                                                                     |
+----------+------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+

+-----------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------+
| 提升练习：                                                                                                                                    |                                                |
+===============================================================================================================================================+================================================+
| 创建主模块main.js和功能模块circle.js， 在功能模块下导出两个函数，分别是传递半径后计算圆的周长和面积；在主模块下引入功能模块后，调用两个函数。 |                                                |
+-----------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------+
| circle.js模块                                                                                                                                 | main模块                                       |
|                                                                                                                                               |                                                |
| function getArea(r){                                                                                                                          | //引用circle.js模块，存到变量circle中          |
|                                                                                                                                               |                                                |
| return Math.PI\*Math.pow(r,2);                                                                                                                | let circle=require(\'./circle.js\');           |
|                                                                                                                                               |                                                |
| }                                                                                                                                             | console.log(circle);                           |
|                                                                                                                                               |                                                |
| function getLength(r){                                                                                                                        | // { getArea: \[Function: getArea\],           |
|                                                                                                                                               |                                                |
| return 2\*Math.PI\* r;                                                                                                                        | getLength: \[Function: getLength\] }           |
|                                                                                                                                               |                                                |
| }                                                                                                                                             | //调用模块功能                                 |
|                                                                                                                                               |                                                |
| module.exports.getArea=getArea;                                                                                                               | console.log( circle.getArea(3).toFixed(2));    |
|                                                                                                                                               |                                                |
| module.exports.genLength=getLength;                                                                                                           | console.log( circle.getLength(3).toFixed(2) ); |
|                                                                                                                                               |                                                |
| //也可以直接导出匿名函数                                                                                                                      |                                                |
|                                                                                                                                               |                                                |
| module.export.getArea=function getArea(r){                                                                                                    |                                                |
|                                                                                                                                               |                                                |
| return Math PI\*Math.pow(r,2);                                                                                                                |                                                |
|                                                                                                                                               |                                                |
| }                                                                                                                                             |                                                |
|                                                                                                                                               |                                                |
| module.export.getLength=function getLength(r){                                                                                                |                                                |
|                                                                                                                                               |                                                |
| return 2\*Math.PI\*r;                                                                                                                         |                                                |
|                                                                                                                                               |                                                |
| };                                                                                                                                            |                                                |
+-----------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------+

### （3）包和npm（第三方模块）

包指第三方模块，一个包就是一个目录模块

npm是用于管理包的工具，包括下载安装，卸载，更新，上传等

npm官网：[www.npmjs.com](http://www.npmjs.com) 可以查找所有包的信息，使用说明

##### 1.命令行切换目录

方法一：cd 绝对目录 回车

如果涉及盘符变化

1、cd 绝对目录 回车

2、盘符：

方法二：在要进入目录文件夹下的空白区域按住shift，单击鼠标右键，选择"在此处打开powershell窗口"

##### 2.使用npm

npm -v 查看当前版本号

**npm install 包名称** 下载安装包，自动才下载到当前命令目录下的node\_modules中，同时会产生package-lock.json文件，用于锁定版本号，会记录依赖的包的信息。

npm config set registry <https://registry.npm.taobao.org/> 设置npm下载地址，从国内镜像下载

##### 3.CommonJS规范

JS往服务器端发展遵循了这个规范，例如模块中引入、导出、作用域等都是这个规范的实现。

### （4）查询字符串模块 querystring

查询字符串是浏览器向Web服务器发请求，传递数据的一种方式；位与URL中？后的部分

如：https://search.jd.com/Search?keyword=笔记本&price=4000

查询字符串模块是用于操作查询字符串的。

-   **parse()** 将查询字符串解析为对象

-   **stringify()** 将对象格式化为查询字符串

+-------------------------------------------------------------------+--------------------------------------------------------+
| 获取学子商城中通过查询字符串传递的数据                            | 获取查询字符串中的商品价格和名称                       |
|                                                                   |                                                        |
| 1、\'keyword=笔记本&price=4000\' 2、lid=3&pname=dell              | http://www.codebody.com/shopping?pname=dell&price=4999 |
+===================================================================+========================================================+
| const querystring=require(\'querystring\'); //1.引入模块          | const querystring=require(\'querystring\');            |
|                                                                   |                                                        |
| let str=\'keyword=笔记本&price=4000\';                            | var str2=\'pname=dell&price=4999\';                    |
|                                                                   |                                                        |
| var obj=querystring.parse(str); //3.将查询字符串解析为对象        | var obj2=querystring.parse(str2);                      |
|                                                                   |                                                        |
| console.log(obj.keyword,obj.price); //4.获取数据                  | console.log(obj);                                      |
|                                                                   |                                                        |
| var str2=querystring.stringify(obj); //5.将对象格式化为查询字符串 | console.log(\`                                         |
|                                                                   |                                                        |
| let str4=\'lid=3&pname=dell\';                                    | 商品价格:\${obj.price}                                 |
|                                                                   |                                                        |
| let obj4=querystring.parse(str4);                                 | 商品名称:\${obj.pname}                                 |
|                                                                   |                                                        |
| console.log(obj4);                                                | \`);                                                   |
+-------------------------------------------------------------------+--------------------------------------------------------+

### （5）URI模块

URL模块是用来处理和解析URL的

+----------------------------------------------------------+
| <http://www.codeboy.com:80/detail.html?lid=5&pname=dell> |
|                                                          |
| 协议 域名 端口 文件路径 查询字符串                       |
+----------------------------------------------------------+

-   **parse()** 将url解析为对象，可以获取到url的各部分

```{=html}
<!-- -->
```
-   **format()** 将对象格式化为url

+----------------------------------------------------------------------------------------------------------------------------------------------------+
| 练习：获取以下url中查询字符串的数据 [https://www.tmooc.cn:443/admin.html?uname=root&upwd=123](https://www.tmooc.cn/admin.html?uname=root&upwd=123) |
+====================================================================================================================================================+
| //第一步：解析URL获取查询字符串                                                                                                                    |
|                                                                                                                                                    |
| //第二部：解析获取的查询字符串，从中获取数据                                                                                                       |
|                                                                                                                                                    |
| const url=require(\'url\');                                                                                                                        |
|                                                                                                                                                    |
| const querystring=require(\'querystring\');                                                                                                        |
|                                                                                                                                                    |
| var str=\'[https://www.tmooc.cn:443/admin.html?uname=root&upwd=123](https://www.tmooc.cn/admin.html?uname=root&upwd=123)\';                        |
|                                                                                                                                                    |
| //解析URL获取查询字符串                                                                                                                            |
|                                                                                                                                                    |
| var obj=url.parse(str);                                                                                                                            |
|                                                                                                                                                    |
| console.log(obj.query);                                                                                                                            |
|                                                                                                                                                    |
| //解析查询字符串为对象                                                                                                                             |
|                                                                                                                                                    |
| let obj2=querystring.parse(obj.query);                                                                                                             |
|                                                                                                                                                    |
| console.log(obj2.uname,obj2.upwd);                                                                                                                 |
+----------------------------------------------------------------------------------------------------------------------------------------------------+

### （6）文件系统模块（fs）

fs用于文件的操作，目录的创建、删除、读取；文件的创建、读取、写入、删除....

##### 同步和异步

同步：方法调用后，必须等待方法调用结束，才能继续后边的任务；通过返回值获取结果

异步：方法调用后无需等待结束，直接执行后续的代码，整个过程不会阻碍后边的任务；通过回调函数获取结果，最后执行，等主程序执行完后执行。异步执行流程图如下

![G:\\web2020\\Stage one\\05nodejs\\day02\_all\\day02\\异步执行流程图.png](media/image7.png){width="4.28in" height="1.8096139545056869in"}

文件系统（fs）常用的操作：

                          异步                                     同步
----------------------- ---------------------------------------- --------------------------------------------
  查看文件状态            fs.**stat**(path,callback)               fs.**statSync**(path)
  创建目录                fs.**mkdir**(path,callback)              fs.**mkdirSync**(path)
  删除目录                fs.**rmdir**(path,callback)              fs.**rmdirSync**(path)
  读取目录                fs.**reddir**(path,callback);            fs.**reddirSync**(path);
  清空写入                fs.**writeFile**(path,data,callback);    fs.**writeFileSnyc**(path,data,callback);
  追加写入                fs.**appendFile**(path,data,callback);   fs.**appendFileSync**(path,data,callback);
  读取文件                fs.**readFile**(path,callback);          fs.**readFileSync**(path,callback);
  删除文件                fs.**unlink**(path,callback);            fs.**unlinkSync**(path,callback);
  判断文件/目录是否存在   fs.**existsSync**(path);                 

**注：**

path：路径（文件名）

callback：回调函数（函数以实参形式传递的都称为回调函数）

使用异步方法，不会阻碍后边的任务；通过回调函数获取结果，主程序执行完后执行

使用同步方法，没有回调函数，直接添加路径查看，在主程序中执行

##### 1.查看文件状态

+-------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| 异步：fs.**stat**(path,callback);                                                                                                                     | 同步：fs.**statSync**(path)                                                          |
+=======================================================================================================================================================+======================================================================================+
| const fs=require(\'fs\');                                                                                                                             | const fs=require(\'fs\'); //引入fs模块                                               |
|                                                                                                                                                       |                                                                                      |
| fs.stat(\'文件路径\',function(err,stats){ //文件路径 **./** 可加可不加；出现错误的话异步方法是不会显示错误的所以要设置参数err以查看失败出现的错误信息 | let stats=fs.statSync(\'文件路径\') //查看文件状态，保存到变量中，使用返回值获取结果 |
|                                                                                                                                                       |                                                                                      |
| if(){throw err; //如果查看失败，抛出错误                                                                                                              | console.log(stats);                                                                  |
|                                                                                                                                                       |                                                                                      |
| }                                                                                                                                                     |                                                                                      |
|                                                                                                                                                       |                                                                                      |
| console.log(stats); //获取到的文件状态信息                                                                                                            |                                                                                      |
|                                                                                                                                                       |                                                                                      |
| console.log(stats.**isDirectory()** ); //是否为目录                                                                                                   |                                                                                      |
|                                                                                                                                                       |                                                                                      |
| console.log(stats.**isFile()** ); //是否为文件                                                                                                        |                                                                                      |
|                                                                                                                                                       |                                                                                      |
| });                                                                                                                                                   |                                                                                      |
+-------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+

+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| 提升练习：                                                                                                                                                                                   |                                              |
+==============================================================================================================================================================================================+==============================================+
| 主模块main.js引入一个不以路径开始的目录模块home，包含文件index.js，导出一个函数，传递任意一个文件路径，打印文件的状态；最后在main.js下调用。//引入第三方模块都要放在一个常量里面（官方建议） |                                              |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| G:\\Web2020\\Stage one\\05nodejs\\day02\_all\\main.js                                                                                                                                        | G:\\Web2020\\Stage one\\05nodejs\\day02\_all |
|                                                                                                                                                                                              |                                              |
| main.js如果想引用一个不以路径开始的目录模块，该目录模块必须放在当前目录下node\_modules里面，当前目录没有就往上一级目录寻找，常用于引入第三方模块                                             | \\node\_modules\\home\\index.js              |
|                                                                                                                                                                                              |                                              |
| const home=require(\'home\');                                                                                                                                                                | const fs=require(\'fs\');                    |
|                                                                                                                                                                                              |                                              |
| console.log(home);                                                                                                                                                                           | function getStat(path){                      |
|                                                                                                                                                                                              |                                              |
| console.log(home.getStat(\'main.js\') );                                                                                                                                                     | let stats=fs.statSync(path);                 |
|                                                                                                                                                                                              |                                              |
|                                                                                                                                                                                              | return stats; }                              |
|                                                                                                                                                                                              |                                              |
|                                                                                                                                                                                              | exports.getStat=getStat;                     |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+

##### 2.创建目录

+------------------------------------+-------------------------------+
| 异步：fs.mkdir(path,callback)      | 同步：fs.mkdirSync(path)      |
+====================================+===============================+
| const fs=require(\'fs\');          | fs.mkdirSync(\'mydir2\');     |
|                                    |                               |
| fs.mkdir (\'mydir\',function(err){ | console.log(\'目录创建成功\') |
|                                    |                               |
| if(err) throw err;                 |                               |
|                                    |                               |
| console.log(\'目录创建成功\');     |                               |
|                                    |                               |
| });                                |                               |
+------------------------------------+-------------------------------+

##### 3.读取目录

+-------------------------------------------------+--------------------------------------------+
| 异步：fs.readdir(path,callback)                 | 同步：fs.readdirSync(path)                 |
+=================================================+============================================+
| const fs=require(\'fs\');                       | let result=fs.readdirSync(\'day02\_all\'); |
|                                                 |                                            |
| fs.readdir(\'day01\_all\',function(err,result){ | console.log(result);                       |
|                                                 |                                            |
| if(err) throw err;                              |                                            |
|                                                 |                                            |
| console.log(result);});                         |                                            |
+-------------------------------------------------+--------------------------------------------+

注：异步是通过回调函数获取读取目录结果result，同步通过声明变量保存读取的结果result。

##### 4.移除目录

+------------------------------------+----------------------------+
| 异步：fs.rmdir(path,callback)      | 同步：fs.rmdirSync(path)   |
+====================================+============================+
| fs.rmdir(\'01.dir\',function(err){ | fs.rmdir(\'02.dir\');      |
|                                    |                            |
| if (err) throw err;                | console.log(\'移除成功\'); |
|                                    |                            |
| console.log(\'目录移除成功\');     |                            |
|                                    |                            |
| });                                |                            |
+------------------------------------+----------------------------+

注：此方法只能移除空目录

##### 5.覆盖写入文件

+-------------------------------------------------------+----------------------------------------------+
| 异步：fs.writeFile(path,data,callback)                | 同步：fs.writeFileSync(path,data)            |
+=======================================================+==============================================+
| fs.writeFile(\'1.txt\',\'hello world\',function(err){ | fs.writeFileSync(\'1.txt\',\'hello world\'); |
|                                                       |                                              |
| if(err) throw err;                                    | console.log(\'写入成功\');                   |
|                                                       |                                              |
| console.log(\'写入成功\');                            |                                              |
|                                                       |                                              |
| });                                                   |                                              |
+-------------------------------------------------------+----------------------------------------------+

注：第一个参数 **path** 文件的路径；第二个参数 **data** 要写入的数据，

如果文件不存在，会创建文件然后写入；

如果文件已经存在，会覆盖内容然后写入。

##### 6.追加写入文件

+----------------------------------------------------------+--------------------------------------------------------------------+
| 异步：fs.appendFile(path,data,callback)                  | 同步：fs.appendFileSync(path,data)                                 |
+==========================================================+====================================================================+
| fs.appendFile(\'2.txt\',\'hello word\\n\',function(err){ | let arr=\[\'广州\',\'上海\',\'北京\',\'深圳\',\'武汉\',\'重庆\'\]; |
|                                                          |                                                                    |
| if(err) throw err;                                       | for (i=0;i\<arr.length ;i++ ){                                     |
|                                                          |                                                                    |
| console.log(\'追加写入成功\');                           | fs.appendFileSync(\'01.txt\',arr\[i\]+\'\\n\');                    |
|                                                          |                                                                    |
| });                                                      | }                                                                  |
+----------------------------------------------------------+--------------------------------------------------------------------+

注：如果文件不存在，先创建然后再写入

如果文件存在，会在文件的末尾追加写入（**\\n**换行写入）

##### 7.读取文件

+--------------------------------------------+--------------------------------------+
| 异步：fs.readFile(path,callback)           | 同步：fs.readFileSync(path)          |
+============================================+======================================+
| fs.readFile(\'01.txt\',function(err,data){ | var data=fs.readFileSync(\'2.txt\'); |
|                                            |                                      |
| if(err) throw err;                         | console.log(data.toString());        |
|                                            |                                      |
| console.log( data.toString() );            |                                      |
|                                            |                                      |
| });                                        |                                      |
+--------------------------------------------+--------------------------------------+

注：data读取到的数据，格式是**Buffer**，需要转为字符串

##### 8.删除文件

+------------------------------------+----------------------------+
| 异步：fs.unlink(path,callback)     | 同步：fs.unlinkSync(path)  |
+====================================+============================+
| fs.unlink(\'1.txt\',function(err){ | fs.unlinkSync(\'1.txt\');  |
|                                    |                            |
| if(err) throw err;                 | console.log(\'删除成功\'); |
|                                    |                            |
| console.log(\'删除成功\');         |                            |
|                                    |                            |
| });                                |                            |
+------------------------------------+----------------------------+

##### 9.检测文件（目录）是否存在

+------------------------------------+----------------------+
| 同步：fs.existsSync(path);         | 异步方法已被官方废弃 |
+====================================+======================+
| if( !fs.existsSync(\'mydir2\') ){  |                      |
|                                    |                      |
| fs.mkdirSync(\'mydir2\');          |                      |
|                                    |                      |
| }                                  |                      |
|                                    |                      |
| if( fs.existsSync(\'data.txt\') ){ |                      |
|                                    |                      |
| fs.unlinkSync(\'data.txt\');       |                      |
|                                    |                      |
| }                                  |                      |
+------------------------------------+----------------------+

##### 10．流（stream）

数据流，只需要内存中很小空间，就可以读取一个大文件。

-   **fs.createReadStream(path)**：创建可读取的流对象

-   **fs.createWriteStream(path)**：创建可写入的流对象

+------------------------------------------------------------------------+--------------------------------------------------------+
| 创建可读取的流对象                                                     | 使用流完成拷贝大文件                                   |
+========================================================================+========================================================+
| const fs=require(\'fs\');                                              | //创建可读取的流                                       |
|                                                                        |                                                        |
| //创建可读取的文件流对象                                               | const readStream=fs.createReadStream(\'01.zip\');      |
|                                                                        |                                                        |
| let readStream=fs.createReadStream(\'01.zip\');                        | //创建可写入的流，同时也会创建新的文件                 |
|                                                                        |                                                        |
| let i=0;                                                               | const writeStream=fs.createWriteStream(\'range.rar\'); |
|                                                                        |                                                        |
| readStream.on(\'data\',function(chunk){                                | //把读取的流通过管道添加到写入流                       |
|                                                                        |                                                        |
| //on(\'data\')是事件名称，监听是否有数据流，自动获取，data是固定写法。 | //pipe 管道专门用于处理流                              |
|                                                                        |                                                        |
| //chunk 就是所读取的数据，分段的数据。                                 | readStream.pipe(writeStream);                          |
|                                                                        |                                                        |
| //console.log(chunk);                                                  |                                                        |
|                                                                        |                                                        |
| //每读取一段加1                                                        |                                                        |
|                                                                        |                                                        |
| i++;});                                                                |                                                        |
|                                                                        |                                                        |
| readStream.on(\'end\',function(){                                      |                                                        |
|                                                                        |                                                        |
| console.log(\'读取结束\',i);                                           |                                                        |
|                                                                        |                                                        |
| });                                                                    |                                                        |
|                                                                        |                                                        |
| //end是事件名称，监听是否读取结束，固定写入；                          |                                                        |
|                                                                        |                                                        |
| 如果结束会自动触发该事件，执行后边的回调函数                           |                                                        |
+------------------------------------------------------------------------+--------------------------------------------------------+

### （7）http协议

浏览器和web服务器之间的通信协议

##### 1.General：通用头信息

-   Request URL：请求的URL，对应浏览器地址栏内容，要向服务器获取哪些内容

-   Request Method：请求的的方法get/post 直接输入地址栏的默认就是get，输入表单点提交

-   status code：响应状态码

**1\*\*：正在响应，还没有结束**

**2\*\*：成功响应**

**3\*\*：响应重定向，跳转到另一个URL**

**4\*\*：客户端错误**

**5\*\*：服务器端错误**

-   Remote Address：请求的服务器IP地址和端口号

##### 2. response Headers：响应头信息 

-   Connection:建立连接方式，keep-alive 持久连接

-   Content-length：响应的内容的长度

-   Accept-Ranges：响应内容的单位

-   Content-Type：text/html 文件类型

-   Content=Encoding：服务器端响应文件的压缩形式

-   Transfer-Encoding:服务器端的传输方式 chunked 分段传输

-   Location：跳转的URL,结合着状态码3\*\*使用

##### 3.request headers：请求头信息 

-   Accept：接收的文件类型有哪些

-   Accept-Encoding:浏览器接收的压缩类型 gzip / deflate

-   User-Agent：客户端使用的浏览器

##### 4.请求主体

用于浏览器向服务器发送的数据，可有可无。

### （8）http模块

既可以创建web服务器，也可以模拟浏览器向其他web服务区发请求

##### 1.模拟浏览器

向服务器端发请求：http.get(url,callbak);

参数url：请求的url

参数callback：通过回调函数，获取服务器端的响应

回调函数参数**res**：响应的对象

响应的对象方法：res.**statusCode** 响应的状态码

响应的对象方法：res.**on**（'data',function(**chunk**){}）通过事件获取传递的数据

chunk传递的数据，分段传输，格式为buffer，需要转为字符串格式。

+--------------------------------------------------------------------------------+
| 使用http模块下的get方法，向http://www.tmooc.com发送请求，并获取响应的数据      |
+================================================================================+
| const http=require(\'http\'); //引入http模块                                   |
|                                                                                |
| http.get(\'http://www.tmooc.cn\',function(res){ //通过回调函数获取服务器端响应 |
|                                                                                |
| console.log(res.statusCode); //获取响应的状态码                                |
|                                                                                |
| res.on(\'data\',function(chunk){ //监听是否有数据流，通过回调函数获取数据      |
|                                                                                |
| console.log(chunk.toString()); //chuck传递的数据，分段的                       |
|                                                                                |
| });                                                                            |
|                                                                                |
| });                                                                            |
+--------------------------------------------------------------------------------+

##### 2.创建web服务器

const server=http.createServer() 创建web服务器

server.listen(8080) 设置web服务器端口号，监听端口变化

server**.**on(\'request\',function(req,res){ \.... })

接收浏览器的请求，是一个事件，当有请求自动触发；通过回调函数来获取请求和做出响应

参数1：request 事件名称（请求）

参数2：通过回调函数获取请求和做出响应

req：请求的对象

> url：请求的URL，显示端口后的部分
>
> method：请求的方法

res：响应的对象

> writeHead(code,obj)：设置响应的状态码和头信息
>
> 参数1 code：设置响应的状态码；
>
> 参数2 obj：用来设置响应的头信息，可以为空
>
> write()：设置浏览器中响应的内容
>
> end()：结束响应，发送响应的内容到浏览器

响应的如果是html文件（或其他文件），需要引入文件模块，读取文件内容，保存到变量data（自定义）中，然后发送内容到浏览器中。

访问本机创建的服务器地址：

<http://127.0.0.1:8080>

<http://localhost:8080>

+------------------------------------------------------------------------------------+
| 创建web服务器，引入模块，设置web服务器的端口号，监听端口的变化                     |
+====================================================================================+
| const http=require(\'http\');                                                      |
|                                                                                    |
| var app=http.createServer();                                                       |
|                                                                                    |
| app.listen(8080);                                                                  |
|                                                                                    |
| //创建服务器后，浏览器一旦有请求，服务器要作出响应（设置事件，通过回调函作出响应） |
|                                                                                    |
| app.on(\'request\',function(req,res){                                              |
|                                                                                    |
| //res.writeHead(302,{Location:\'http://www.tmooc.cn\'});                           |
|                                                                                    |
| console.log(req.url);                                                              |
|                                                                                    |
| res.write(\'this is your beer\');                                                  |
|                                                                                    |
| res.end();                                                                         |
|                                                                                    |
| });                                                                                |
+------------------------------------------------------------------------------------+

+--------------------------------------------------------------+---+
| 提升练习：                                                   |   |
+==============================================================+===+
| 创建web服务器，根据请求内容作出响应：                        |   |
|                                                              |   |
| 请求url/login，响应this is login；                           |   |
|                                                              |   |
| 请求url/study，跳转到<http://www.tmooc.cn>；                 |   |
|                                                              |   |
| 请求url/index，响应文件1.html                                |   |
|                                                              |   |
| 其它，响应状态码400内容为not found                           |   |
+--------------------------------------------------------------+---+
| const http=require(\'http\');                                |   |
|                                                              |   |
| const fs=require(\'fs\');                                    |   |
|                                                              |   |
| const app=http.createServer();                               |   |
|                                                              |   |
| app.listen(8080);                                            |   |
|                                                              |   |
| //接收浏览器的请求，通过回调函数做出响应                     |   |
|                                                              |   |
| app.on(\'request\',function(req,res){                        |   |
|                                                              |   |
| //console.log(req.url,req.method);                           |   |
|                                                              |   |
| //根据请求的内容（URL）来做出响应                            |   |
|                                                              |   |
| if(req.url===\'/login\'){                                    |   |
|                                                              |   |
| //设置响应的文件类型及编码                                   |   |
|                                                              |   |
| res.writeHead(200,{                                          |   |
|                                                              |   |
| \'Content-Type\':\'text/html;charset=utf-8\'                 |   |
|                                                              |   |
| });                                                          |   |
|                                                              |   |
| //1.响应一段文字                                             |   |
|                                                              |   |
| res.write(\'\<h2\>这是登陆的页面login\</h2\>\');             |   |
|                                                              |   |
| res.end();                                                   |   |
|                                                              |   |
| }else if(req.url===\'/study\'){                              |   |
|                                                              |   |
| //2.响应的重定向（跳转）                                     |   |
|                                                              |   |
| res.writeHead(302,{                                          |   |
|                                                              |   |
| Location:\'http://www.tmooc.cn\'                             |   |
|                                                              |   |
| }); res.end();                                               |   |
|                                                              |   |
| }else if(req.url===\'/index\'){                              |   |
|                                                              |   |
| //3.如果请求的URL是 /index，响应文件1.html                   |   |
|                                                              |   |
| 先读取文件readFileSync，把读取的内容作为响应的内容，最后发送 |   |
|                                                              |   |
| let data=fs.readFileSync(\'1.html\').toString();             |   |
|                                                              |   |
| //默认是buffer数据                                           |   |
|                                                              |   |
| res.write(data);                                             |   |
|                                                              |   |
| res.end();                                                   |   |
|                                                              |   |
| }else{                                                       |   |
|                                                              |   |
| //如果以上都没有设置状态码为404响应内容为Not Found           |   |
|                                                              |   |
| res.writeHead(404);                                          |   |
|                                                              |   |
| res.write(\'Not Found\');                                    |   |
|                                                              |   |
| res.end();                                                   |   |
|                                                              |   |
| }                                                            |   |
|                                                              |   |
| });                                                          |   |
+--------------------------------------------------------------+---+

### （9）express框架

基于Node.js平台的，快速、开放、极简的web开发框架

express框架网址：[www.expressjs.com.cn](http://www.expressjs.com.cn)（下载安装： npm install express）

##### 1.路由

路由是web服务器根据浏览器请求的方法和URL来作出响应

三要素：请求方法、请求的对象、响应（回调函数）

响应的对象（**res**）

-   res.**send()** 响应内容并发送，只能响应一次

-   res**.sendFile()** 响应网页（文件），必须使用绝对路径 \_\_dirname

-   res.**redirect()：** 响应重定向，直接跟重定向url

请求对象（**req**）

-   req.method 请求的方法

-   req**.**url 请求的url

-   req.header 请求的头信息

-   req.**query** 获取请求是查询字符串传递的数据，并格式化对象

-   req.**params** 获取路由传参的数据，格式化为对象

+----------------------------------------------------------------+-------------------------------------------------------+
| 创建路由，请求方法:get 请求的[url: /index](file:///C:\index)， | 创建路由，请求方法为get，请求url为/login。响应'请登陆 |
|                                                                |                                                       |
| 响应\'\<h1\>这是首页\</h1\>\';                                 |                                                       |
|                                                                |                                                       |
| 请求方法:get 请求的URL:/，跳转到 \'/index\'                    |                                                       |
|                                                                |                                                       |
| (跳转首页做法，/后面没有内容默认跳转到首页)                    |                                                       |
+================================================================+=======================================================+
| const express=require(\'express\');                            | server.get(\'/login\',function(req,res){              |
|                                                                |                                                       |
| const server=express();                                        | res.send(\'请登陆XXXXXXXXX\');                        |
|                                                                |                                                       |
| server.listen(8080);                                           | res.send(\'welcome\');                                |
|                                                                |                                                       |
| server.get(\'/index\',function(req,res){                       | //send调用以后响应已经结束，不运行再次响应            |
|                                                                |                                                       |
| res.send(\'\<h1\>这是首页\</h1\>\');                           | });                                                   |
|                                                                |                                                       |
| });                                                            |                                                       |
|                                                                |                                                       |
| server.get(\'/\',function(req,res){                            |                                                       |
|                                                                |                                                       |
| res.redirect(\'/index\');                                      |                                                       |
|                                                                |                                                       |
| });                                                            |                                                       |
+----------------------------------------------------------------+-------------------------------------------------------+

##### 2.数据传递方式

-   get请求：以查询字符串的形式传递数据，服务器端使用req.query获取数据，结果是对象

-   post请求：是通过表单提交传递数据，服务器端通过事件的形式获取数据

-   路由传参：设置路由中接收的名称，通过浏览器传递，被/:接收

注：查询字符串传递数据容易被浏览器所缓存，而post传递数据不会出现在地址栏

路由传参：

+------------------------------------+------------------------------------------------+
| 浏览器传递 127.0.0.1:8080/detail/5 | server.get(\'/detail/:lid\',function(req,res){ |
|                                    |                                                |
| 5是传递的数据，被lid接收           | req.params//获取路由传参的数据，格式化为对象   |
|                                    |                                                |
|                                    | });//lid设置形参，用于接收实参5，              |
+------------------------------------+------------------------------------------------+

+------------------+-----------------------------------------------+----------------------------------------------------------------------------------------------------------+
| **传递数据方式** | **格式**                                      | **在路由中获取**                                                                                         |
+==================+===============================================+==========================================================================================================+
| get              | 查询字符串                                    | req.query                                                                                                |
|                  |                                               |                                                                                                          |
|                  | http://127.0.0.1:8080/mysearch?keyword=笔记本 |                                                                                                          |
+------------------+-----------------------------------------------+----------------------------------------------------------------------------------------------------------+
| post             | url中不可见                                   | 以流的方式传递，需要使用事件获取，格式为buffer，转字符后为查询字符串，需要解析为对象。**该操作为异步**。 |
|                  |                                               |                                                                                                          |
|                  | 请求是通过表单提交传递数据，                  | req.on(\'data\', function(chunk){ })                                                                     |
+------------------+-----------------------------------------------+----------------------------------------------------------------------------------------------------------+
| 路由传参         | http://127.0.0.1:8080/package/mysql           | app.get(\'/package/:pname\',function(req,res){\                                                          |
|                  |                                               | req.params//获取路由传参的数据，格式化为对象\                                                            |
|                  |                                               | } );                                                                                                     |
+------------------+-----------------------------------------------+----------------------------------------------------------------------------------------------------------+

get请求传递数据；req.query 获取url中查询字符串数据:

+--------------------------------------------------------------------------------------------------+
| 创建web服务器，浏览器端获取搜索的页面，服务器端创建对应的路由（get /search）,响应文件search.html |
+==================================================================================================+
| const express=require(\'express\');                                                              |
|                                                                                                  |
| const server=express();                                                                          |
|                                                                                                  |
| server.listen(8080);                                                                             |
|                                                                                                  |
| server.get(\'/search\',function(req,res){ //根据浏览器搜索页面创建路由：响应文件search.html      |
|                                                                                                  |
| res.sendFile(\_\_dirname+\'/search.html\');                                                      |
|                                                                                                  |
| });                                                                                              |
|                                                                                                  |
| server.get(\'/mysearch\',function(req,res){ //根据表单的请求创建对应的路由,响应'这是所有数据'    |
|                                                                                                  |
| //console.log(req.query); //req.query可以获取查询字符串传递的对象，并解析为对象                  |
|                                                                                                  |
| //console.log(req.method,req.url);                                                               |
|                                                                                                  |
| res.send(\'这是所有的数据\'+req.query.keyword);                                                  |
|                                                                                                  |
| });                                                                                              |
+--------------------------------------------------------------------------------------------------+
| search.html                                                                                      |
|                                                                                                  |
| \<h1\>这是搜索页面\</h1\>                                                                        |
|                                                                                                  |
| \<form method=\"get\" action=\"/mysearch\"\>                                                     |
|                                                                                                  |
| \<input type=\"text\" name=\"keyword\"\>                                                         |
|                                                                                                  |
| \<input type=\"submit\"\>                                                                        |
|                                                                                                  |
| \</form\>                                                                                        |
+--------------------------------------------------------------------------------------------------+

路由传参；req.params 获取路由传参的数据

+---------------------------------------------------------------------------------------+
| 创建路由(get /package),响应"这是包的详细介绍：                                        |
+=======================================================================================+
| 浏览器输入：127.0.0.1:8080/package/mysql                                              |
|                                                                                       |
| const express=require(\'express\');                                                   |
|                                                                                       |
| const server=express();                                                               |
|                                                                                       |
| server.listen(8080);                                                                  |
|                                                                                       |
| server.get(\'/package/:pname\',function(req,res){ //设置形参:pname，用于接收实参mysql |
|                                                                                       |
| console.log(req.params); // req.paramsu用于获取路由传参的数据                         |
|                                                                                       |
| res.send(\'这是包的详细介绍：\'+req.params.pname); //响应并发送                       |
|                                                                                       |
| });                                                                                   |
+---------------------------------------------------------------------------------------+

+----------------------------------------------------------------------------------------------------------------------+
| 创建购物车的路由（get /shopping）,传递商品的编号lid和价格price，在路由获取数据，并响应到浏览器端'编号：xx 价格：xxx' |
+======================================================================================================================+
| const express=require(\'express\');                                                                                  |
|                                                                                                                      |
| const server=express();                                                                                              |
|                                                                                                                      |
| server.listen(8080);                                                                                                 |
|                                                                                                                      |
| server.get(\'/shopping/:lid/:price\',function(req,res){                                                              |
|                                                                                                                      |
| console.log(req.params);                                                                                             |
|                                                                                                                      |
| res.send(\`                                                                                                          |
|                                                                                                                      |
| 编号：\${req.params.lid}                                                                                             |
|                                                                                                                      |
| \<br\>                                                                                                               |
|                                                                                                                      |
| 价格：\${req.params.price}                                                                                           |
|                                                                                                                      |
| \`);                                                                                                                 |
|                                                                                                                      |
| });                                                                                                                  |
+----------------------------------------------------------------------------------------------------------------------+

post通过表单提交，传递数据，url中不可见，服务器端通过事件的形式获取数据

+------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| 提升练习：                                                                                                                                                             |   |
+========================================================================================================================================================================+===+
| 创建web服务器，浏览器请求获取登陆页面，创建路由（get /login）,响应文件login.html;点击提交，再次向服务器发请求（post/mylogin）,根据表单请求创建对应路由，响应"登陆成功" |   |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| const express=require(\'express\');                                                                                                                                    |   |
|                                                                                                                                                                        |   |
| const server=express();                                                                                                                                                |   |
|                                                                                                                                                                        |   |
| server.listen(8080);                                                                                                                                                   |   |
|                                                                                                                                                                        |   |
| server.get(\'/login\',function(req,res){                                                                                                                               |   |
|                                                                                                                                                                        |   |
| //创建路由(get /login)，响应文件login.html                                                                                                                             |   |
|                                                                                                                                                                        |   |
| res.sendFile(\_\_dirname+\'/login.html\');                                                                                                                             |   |
|                                                                                                                                                                        |   |
| });                                                                                                                                                                    |   |
|                                                                                                                                                                        |   |
| //根据表单提交的请求，创建对应的路由 post /mylogin                                                                                                                     |   |
|                                                                                                                                                                        |   |
| server.post(\'/mylogin\',function(req,res){                                                                                                                            |   |
|                                                                                                                                                                        |   |
| //获取post传递的数据，传递的数据是以流的方式                                                                                                                           |   |
|                                                                                                                                                                        |   |
| //事件：一旦有数据传递，自动触发；通过回调函数获取数据                                                                                                                 |   |
|                                                                                                                                                                        |   |
| req.on(\'data\',function(chunk){                                                                                                                                       |   |
|                                                                                                                                                                        |   |
| //chunk就是传递的数据，分段的                                                                                                                                          |   |
|                                                                                                                                                                        |   |
| console.log(chunk.toString());                                                                                                                                         |   |
|                                                                                                                                                                        |   |
| //转为字符串后为查询字符串，需要使用查询字符串模块解析为对象                                                                                                           |   |
|                                                                                                                                                                        |   |
| let obj=querystring.parse(chunk.toString());//                                                                                                                         |   |
|                                                                                                                                                                        |   |
| console.log(obj);                                                                                                                                                      |   |
|                                                                                                                                                                        |   |
| //获取到数据以后，再执行send                                                                                                                                           |   |
|                                                                                                                                                                        |   |
| res.send(\'登陆成功，欢迎：\'+obj.user);});                                                                                                                            |   |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| /login.html                                                                                                                                                            |   |
|                                                                                                                                                                        |   |
| \<form method=\"post\" action=\"/mylogin\"\>                                                                                                                           |   |
|                                                                                                                                                                        |   |
| 用户：\<input type=\"text\" name=\"user\"\>\<br\>                                                                                                                      |   |
|                                                                                                                                                                        |   |
| 密码：\<input type=\"text\" name=\"password\"\>\<br\>                                                                                                                  |   |
|                                                                                                                                                                        |   |
| \<input type=\"submit\"\>                                                                                                                                              |   |
|                                                                                                                                                                        |   |
| \</form\>                                                                                                                                                              |   |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+

##### 3.路由器

路由的使用过程中，不同的模块可能出现相同的URL，把同一个模块下的路由放到一个容器（文件），给url添加前缀，防止不同模块路由之间出现相同的url，这个容器就是路由器。

路由器最终要引入到web服务器下才能使用。

+--------------------------------------------------------------------------------+
| 创建路由器模块（自定义）                                                       |
+================================================================================+
| const express=require(\'express\'); //引入express，路由器是express下的一个功能 |
|                                                                                |
| const router=express.Router(); //创建路由器                                    |
|                                                                                |
| router.get(\'/list\',function(req,res){ //在路由器下添加路由                   |
|                                                                                |
| res.send(\'这是用户列表\');                                                    |
|                                                                                |
| });                                                                            |
|                                                                                |
| module.exports=router; //导出路由器对象，供web服务器使用                       |
+--------------------------------------------------------------------------------+
| 在服务器下引入并挂载                                                           |
+--------------------------------------------------------------------------------+
| const userRouter=require(\'./user.js\'); //引入路由器模块                      |
|                                                                                |
| app.use( \'/user\',userRouter ); //把路由器挂载到服务器并添加前缀              |
+--------------------------------------------------------------------------------+

路由器的使用：

+--------------------------------------------------------------------------------------------+------------------------------------------------+
| 创建商品路由器product.js，并添加路由(get /list)，在web服务器下引入并挂载，添加前缀/product |                                                |
+============================================================================================+================================================+
| product.js                                                                                 | const express=require(\'express\');            |
|                                                                                            |                                                |
| //1.引入express                                                                            | const productRouter=require(\'./product.js\'); |
|                                                                                            |                                                |
| const express=require(\'express\');                                                        | //console.log(productRouter);                  |
|                                                                                            |                                                |
| //2.创建路由器对象                                                                         | const server=express();                        |
|                                                                                            |                                                |
| const router=express.Router();                                                             | server.listen(8080);                           |
|                                                                                            |                                                |
| //3.往路由器对象中添加路由get /list                                                        | //把路由器挂载到服务器下，同时添加前缀/product |
|                                                                                            |                                                |
| router.get(\'/list\',function(req,res){                                                    | server.use(\'/product\', productRouter);       |
|                                                                                            |                                                |
| res.send(\'这是商品列表\');                                                                |                                                |
|                                                                                            |                                                |
| });                                                                                        |                                                |
|                                                                                            |                                                |
| //4.导出路由器对象                                                                         |                                                |
|                                                                                            |                                                |
| module.exports=router;                                                                     |                                                |
+--------------------------------------------------------------------------------------------+------------------------------------------------+

##### 4.中间件

浏览器向服务器发请求，中间件拦截请求并作出响应；中间件最终是要为路由服务的。

中间件分为：应用级中间件、路由级中间件、内置中间件、第三方中间间、错误处理中间件

###### 4.1应用级中间件

应用级中间件也称为自定义中间件，是一个函数：app**.use(URL,** **function(req,res,next)...{})，**

URL表示要拦截哪一个路由，对应路由中的URL

回调函数：拦截到以后，自动调用

req：请求的对象

res：响应的对象

next：是一个函数，表示执行下一个中间件或路由

+--------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------+
| 创建中间件，拦截对/list的请求，如果提供的用户名为root，则允许查看后台数据，否则响应\'无此权限\'        | 创建购物车路由(get /shopping),传递商品的价格price，在中间件中将价格打九折，最后在路由中响应'商品价格：xxx' |
+========================================================================================================+============================================================================================================+
| const express=require(\'express\');                                                                    | const express=require(\'express\');                                                                        |
|                                                                                                        |                                                                                                            |
| const app=express();                                                                                   | const app=express();                                                                                       |
|                                                                                                        |                                                                                                            |
| app.listen(8080);                                                                                      | app.listen(8080);                                                                                          |
|                                                                                                        |                                                                                                            |
| //app.use在使用中间件                                                                                  | //创建中间件                                                                                               |
|                                                                                                        |                                                                                                            |
| //参数1：拦截的URL                                                                                     | app.use(\'/shopping\',function(req,res,next){                                                              |
|                                                                                                        |                                                                                                            |
| //参数2：拦截到以下，执行的回调函数,在回调函数中可以获取到请求，以及做出响应                           | //获取价格数据                                                                                             |
|                                                                                                        |                                                                                                            |
| app.use(\'/list\',function(req,res,next){                                                              | console.log(req.query);                                                                                    |
|                                                                                                        |                                                                                                            |
| //req请求对象                                                                                          | //加价格打九折                                                                                             |
|                                                                                                        |                                                                                                            |
| //获取查询字符串传递的数据                                                                             | req.query.price\*=0.9;                                                                                     |
|                                                                                                        |                                                                                                            |
| console.log(req.query);                                                                                | //往后执行                                                                                                 |
|                                                                                                        |                                                                                                            |
| //res响应对象                                                                                          | next();                                                                                                    |
|                                                                                                        |                                                                                                            |
| //判断数据是否为root，如果不是root，则响应无此权限，否则允许往后执行(可能有其它的中间件，也可能是路由) | });                                                                                                        |
|                                                                                                        |                                                                                                            |
| if(req.query.uname!==\'root\'){                                                                        | app.get(\'/shopping\',function(req,res){                                                                   |
|                                                                                                        |                                                                                                            |
| res.send(\'无此权限\');                                                                                | //获取价格就是执行完打折后的                                                                               |
|                                                                                                        |                                                                                                            |
| }else{                                                                                                 | console.log(req.query);                                                                                    |
|                                                                                                        |                                                                                                            |
| //执行下一个中间或路由                                                                                 | res.send(\'商品价格：\'+req.query.price);                                                                  |
|                                                                                                        |                                                                                                            |
| next();                                                                                                | });                                                                                                        |
|                                                                                                        |                                                                                                            |
| }                                                                                                      |                                                                                                            |
|                                                                                                        |                                                                                                            |
| });                                                                                                    |                                                                                                            |
|                                                                                                        |                                                                                                            |
| //获取后台数据路由 (get /list)                                                                         |                                                                                                            |
|                                                                                                        |                                                                                                            |
| app.get(\'/list\',function(req,res){                                                                   |                                                                                                            |
|                                                                                                        |                                                                                                            |
| res.send(\'这是后台的数据\');                                                                          |                                                                                                            |
|                                                                                                        |                                                                                                            |
| });                                                                                                    |                                                                                                            |
+--------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------+

###### 4.2路由级中间件

路由器的使用

###### 4.3内置中间件

在express4中只保留了一个内置中间件（static）

-------------------------------------------------
  server**.use( express.static**(\'目录名称\') );
  -------------------------------------------------

服务器把所有的静态资源托管到指定的目录下，如果浏览器端要请求文件，不需要再创建路由，自动的到该目录下查找

//静态资源静态资源：html、css、浏览器js、图像、视频\....

+------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| 托管静态资源到files目录下，查看如果和public有相同的文件名称，哪一个起作用                                                                |                                              |
+==========================================================================================================================================+==============================================+
| const express=require(\'express\');                                                                                                      |                                              |
|                                                                                                                                          |                                              |
| const app=express();                                                                                                                     |                                              |
|                                                                                                                                          |                                              |
| app.listen(8080);                                                                                                                        |                                              |
|                                                                                                                                          |                                              |
| //托管静态资源，把所有静态资源托管到public，浏览器请求自动到这个目录下查找                                                               |                                              |
|                                                                                                                                          |                                              |
| app.use( express.static(\'public\') );                                                                                                   |                                              |
|                                                                                                                                          |                                              |
| app.use( express.static(\'files\') );                                                                                                    |                                              |
+------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| 创建web服务器，托管静态资源到public目录，在该目录下创建登陆的网页login.html，点击按钮，向服务器发请求(post /mylogin)，在路由中获取数据。 |                                              |
+------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| const express=require(\'express\');                                                                                                      | login.html                                   |
|                                                                                                                                          |                                              |
| const app=express();                                                                                                                     | \<h2\>用户登陆\</h2\>                        |
|                                                                                                                                          |                                              |
| app.listen(8080);                                                                                                                        | \<form method=\"post\" action=\"/mylogin\"\> |
|                                                                                                                                          |                                              |
| app.use( express.static(\'public\') );                                                                                                   | 用户：\<input type=\"text\" name=\"uname\"\> |
|                                                                                                                                          |                                              |
| app.use( express.static(\'files\') );                                                                                                    | \<br\>                                       |
|                                                                                                                                          |                                              |
|                                                                                                                                          | 密码：\<input type=\"text\" name=\"upwd\"\>  |
|                                                                                                                                          |                                              |
|                                                                                                                                          | \<br\>                                       |
|                                                                                                                                          |                                              |
|                                                                                                                                          | \<input type=\"submit\"\>                    |
|                                                                                                                                          |                                              |
|                                                                                                                                          | \</form\>                                    |
+------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+

###### 4.4第三方中间件

第三方中间都是以第三方模块的形式出现，需要先下载安装，通常express在下载安装的时候会附带下载一些第三方中间件。

+------------------------------------------------------------------------------------------+
| body-parser中间件的使用                                                                  |
+==========================================================================================+
| const express=require(\'express\');                                                      |
|                                                                                          |
| //1.引入body-parser中间件模块                                                            |
|                                                                                          |
| const bodyParser=require(\'body-parser\');                                               |
|                                                                                          |
| //const querystring=require(\'querystring\');                                            |
|                                                                                          |
| const app=express();                                                                     |
|                                                                                          |
| app.listen(8080);                                                                        |
|                                                                                          |
| app.use( express.static(\'public\') ); //托管静态资源到public目录                        |
|                                                                                          |
| //2.使用body-parser中间件，将post请求的数据解析为对象                                    |
|                                                                                          |
| app.use( bodyParser.urlencoded({                                                         |
|                                                                                          |
| extended:false //不使用第三方的qs模块，而是使用核心模块querystring将查询字符串解析为对象 |
|                                                                                          |
| }) );                                                                                    |
|                                                                                          |
| app.post(\'/mylogin\',function(req,res){ //根据表单的请求创建对应路由                    |
|                                                                                          |
| req.on(\'data\',function(chunk){ //事件：监听是否数据传递                                |
|                                                                                          |
| console.log( chunk.toString() );                                                         |
|                                                                                          |
| let obj=querystring.parse( chunk.toString() ); //使用查询字符串模块解析为对象            |
|                                                                                          |
| console.log(obj);                                                                        |
|                                                                                          |
| });                                                                                      |
|                                                                                          |
| console.log( req.body ); //3.获取数据，格式为对象                                        |
|                                                                                          |
| res.send(\'登陆成功\');                                                                  |
|                                                                                          |
| });                                                                                      |
+------------------------------------------------------------------------------------------+

### （10）mysql模块

连接数据库：

-   交互模式：mysql.exe -h127.0.0.1 -P3306 -uroot -ptoot简写：mysql -uroot

-   脚本模式：mysql -uroot \< c:/xampp/\.../xz.sql

mysql的增删改查

-   增 INSERT INTO emp VALUES( \...\...)

-   删 DELETE FROM emp WHERE uid=5;

-   改 UPDATE emp SET \...\....WHERE \....

-   查 SELECT \* FROM emp;

##### 1.下载安装mysql第三方模块

npm install mysql

##### 2.使用mysql模块连接mysql数据库

-   普通连接：

> mysql.createConnection(){
>
> 连接数据库需要的服务器、端口、用户名、密码、使用的数据库
>
> };

-   连接池(推荐写法)

> **mysql.createPool({**

连接数据库需要的服务器、端口、用户名、密码、使用的数据库，连接池大小connectionLimit

**});**

-   connection.end(); 执行完所有的SQL语句后关闭连接

##### 3.执行SQL语句

pool.**query(sql,arr,callback)**

sql 要执行的SQL语句

arr 要过滤的数据，会替换SQL语句中占位符(?)

> pool.query(\'INSERT INTO emp VALUES**(?,?,?)\',\[16,\'range\',1\]**

callback 回调函数，用于获取SQL语句的结果

> **function(err,result){....};**
>
> 参数1 err：可能出现的错误
>
> 参数2 result：SQL语句的结果

+---------------------------------------------------------------+-----------------------------------------------------------------------------------------------+
| 连接数据库，查询数据库tedu中emp表的所有内容                   | 使用连接池方法                                                                                |
+===============================================================+===============================================================================================+
| const mysql=require(\'mysql\');                               | const mysql=require(\'mysql\');                                                               |
|                                                               |                                                                                               |
| const connection=mysql.createConnection({                     | const pool=mysql.createPool({host:\'127.0.0.1\',                                              |
|                                                               |                                                                                               |
| host:\'127.0.0.1\',port:\'3306\',user:\'root\',psaaword:\'\', | port:\'3306\',user:\'root\',psaaword:\'\',atabase:\'tedu\',connectionLimit:\'15\'//默认的是15 |
|                                                               |                                                                                               |
| database:\'tedu\'//连接后要进入的数据库                       | });                                                                                           |
|                                                               |                                                                                               |
| });                                                           | pool.query(\'SELECT \* FROM emp\',                                                            |
|                                                               |                                                                                               |
| 执行SQL 命令,会自动建立连接，执行连接可以不写                 | function(err,result){                                                                         |
|                                                               |                                                                                               |
| connection.query(\'SELECT \* FROM emp\',                      | if (err) throw err;                                                                           |
|                                                               |                                                                                               |
| function(err,result){                                         | console.log(result);                                                                          |
|                                                               |                                                                                               |
| if (err) throw err;                                           | });                                                                                           |
|                                                               |                                                                                               |
| console.log(result);});                                       |                                                                                               |
+---------------------------------------------------------------+-----------------------------------------------------------------------------------------------+

##### 4. SQL注入和占位符 ? 

SQL注入，在用户提供的数据中加入SQL命令可以攻击数据库，所以要过滤用户提供的数据，使用?占位符，可以过滤数据防止SQL注入攻击数据库。

SQL注入：

SELECT \* FROM user WHERE uname=\'root\' AND upwd=\'123456\' **OR 1=1**;

SELECT \* FROM emp WHERE eid=\'5\' **OR 1=1**;

占位符 **？**

pool.query(\'INSERT INTO emp VALUES(?,?,?,?,?,?)\',\[16,\'range\',1,\'1978-8-1\',\'800000\',10\]

+---------------------------------------------------------------------------------------------------------------------------------------------+
| 往emp表中插入一条数据，SQL命令中的值都要使用占位符对数据进行过滤。                                                                          |
+=============================================================================================================================================+
| const mysql=require(\'mysql\');                                                                                                             |
|                                                                                                                                             |
| const pool=mysql.createPool({                                                                                                               |
|                                                                                                                                             |
| host:\'127.0.0.1\',                                                                                                                         |
|                                                                                                                                             |
| port:\'3306\',                                                                                                                              |
|                                                                                                                                             |
| user:\'root\',                                                                                                                              |
|                                                                                                                                             |
| psaaword:\'\',                                                                                                                              |
|                                                                                                                                             |
| database:\'tedu\',                                                                                                                          |
|                                                                                                                                             |
| connectionLimit:\'15\'});                                                                                                                   |
|                                                                                                                                             |
| pool.query(\'INSERT INTO emp VALUES(?,?,?,?,?,?)\',\[16,\'range\',1,\'1978-8-1\',\'800000\',10\],//arr会替换SQL语句中占位符(?)，防止SQL注入 |
|                                                                                                                                             |
| function(err,result){                                                                                                                       |
|                                                                                                                                             |
| if (err) throw err;                                                                                                                         |
|                                                                                                                                             |
| console.log(result);                                                                                                                        |
|                                                                                                                                             |
| });                                                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------------------------------+

##### 5.增删改查

插入数据可以是对象形式，插入的某些列可以不写，不写则按照默认值填入。

+------------------------------------------------+-----------------------------------------------------------------------------------+
| 插入对象形式数据                               | 创建对象，修改对象中提供的列                                                      |
+================================================+===================================================================================+
| const mysql=require(\'mysql\');                | const mysql=require(\'mysql\');                                                   |
|                                                |                                                                                   |
| const pool=mysql.createPool({//同上});         | const pool=mysql.createPool({//同上});                                            |
|                                                |                                                                                   |
| let emp={ename:\'然哥\',birthday:\'1978-8-8\', | let ran={ename:\'阿然.史密斯\',salary:\'88000\',                                  |
|                                                |                                                                                   |
| deptId:10};                                    | eid:17}                                                                           |
|                                                |                                                                                   |
| pool.query(\'INSERT INTO emp SET ?\',\[emp\],  | pool.query(\'UPDATE emp SET ? WHERE eid=?\',\[ran,ran.eid\],function(err,result){ |
|                                                |                                                                                   |
| function(err,result){                          | if(err) throw err;                                                                |
|                                                |                                                                                   |
| if(err) throw err;                             | console.log(result);});                                                           |
|                                                |                                                                                   |
| console.log(result);});                        |                                                                                   |
+------------------------------------------------+-----------------------------------------------------------------------------------+

# 学子商城项目

完成学子商城的6个接口

-   后端项目接口：处理前端的请求，例如注册、登陆、获取首页数据等都有对应的接口

-   前端和后端对接：后端给前端提供项目中的接口。

Node.js中的接口：每个路由就对应一个接口。

项目步骤

1)  创建web服务器

2)  托管静态资源到public目录

3)  创建路由器，并在服务器下引入

4)  创建连接池模块，在路由器下引入

## 1、用户注册接口（路由）

在用户路由器user.js下，创建路由器对象，添加注册的路由(post /reg)，响应登陆成功；并导出路由器。 在web服务器app.js下引入该路由器并挂载，添加前缀/user。

## 2、用户登陆接口（路由）

## 3、用户修改数据接口（路由）

4、用户列表接口（路由）

5、用户检索接口(get /user/detail)

![](media/image8.png){width="2.7478258967629046in" height="0.9821894138232721in"}

6、删除用户接口(get /user/delete)

![](media/image9.png){width="2.551388888888889in" height="0.8805555555555555in"}

商品模块的表(xz\_laptop)





# 第二阶段

## 一、HTML Basic

## 1、WEB基础知识

HTML：泛指前端的网页技术；HTML5：大前端技术，是html4和XHTML1.0的升级版



### （1）web和Internet

Internet：全球计算机互联网 俗称：因特网，互联网

主要服务www服务、BBS：论坛、Email:邮件、telnet远程登录、FTP：上传下载

Web：又称为万维网，即www，将各种类型的信息和服务无缝连接，并提供界面，万维网其实

就是无数WEB文档的集合

Web与Internet：Web是Internet上的最流行的应用；Internet为Web运行提供了网络环境

### （2）internet上的应用程序

##### 1.C/S结构

l c：client 客户端

l s：server 服务器

需要下载客户端，在硬件上安装才能使用

##### 2.B/S结构

l b：browser浏览器

l s：server服务器

在浏览器上运行的应用

##### 3.C/S和B/S的区别

l C/S需要升级更新

l B/S 更新不会影响用户体验

### （3）web的工作原理

l web：运行在internet上的一种B/S结构的应用，俗称网站

l internet：为web运行提供了网络环境

web的工作原理：基于浏览器和服务器以及通信协议在实现的数据的传输和展示

##### 1.通信协议

通信协议，规范了数据是如何打包和传递的，让浏览器和服务器都可以识别交互的数据

http://  https://

##### 2.服务器

服务器功能：存储数据；接收用户的请求，并响应；提供程序的运行环境；具备一定的安全功能

服务器产品Tomcat---->java；Apache---->php；IIS--------->.net

服务器技术：java php .net  python  nodejs

##### 3.浏览器

浏览器功能：1.代表用户发送请求；2.作为js，html，css解析器，把代码解析成图形界面

浏览器产品：chrome、safari、firefox、opera、IE------edge浏览器技术：HTML5 CSS3 javascript

## 2、html快速入门

Hyper Text Markup Langeuage（HTML）超文本标记语言

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 超文本标记语言,用来设计网页，

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 用该语言编写的文件，以.html 或 .htm为后缀，

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 由浏览器解释运行，可以嵌入脚本语言编写的程序片段，如JS

### （1）html基础语法

##### 1.标记语法

HTML用于描述功能的符号成为“标记”，也叫标签、元素、节点；

标记使用时必须使用尖括号(**<>**)括起来标记，由关键字组成，标签具备一些功能

分为双标记和单标记

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 双标记（封闭类型标记）：双标记成对出现，有开有关

<关键字></关键字>，如：<a> </a>

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 单标记（非封闭类型）：空标签，没有内容区域。

<关键字> 或者 <关键字/>ex：<br>，<hr>，<img>，<input>，<meta>

##### 2.元素

即标记，指尖括号及尖括号所包围的内容部分，元素可以包含文本内容和其他元素，也可以为空

元素嵌套：元素可以相互嵌套形成更为复杂的语法

​        

​        元素的嵌套：    <div>         <p></p>    </div>        

<标签1>



<标签2>

<标签3> </标签3>

</标签2>

</标签1>

注：p标签中不能嵌套其他块级元素

##### 3.属性和值

通过属性和值，对标签进行修饰

语法：< 标签 属性1="值1" 属性2="值2" ....>

ex：<p align="center" id="p1">

标准属性，通用属性。所有标签都有的属性

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) id ：定义元素在页面中唯一的标识

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) title ：鼠标悬停在元素上所提示的文本

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) style ：css中，定义内联样式

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) class ：css中，引用类选择器

专有属性：只针对一个标签起作用的属性

##### 2.4.注释

在源码中编写，但不会被浏览器所解释的内容，成为注释

可以将对代码的解释说明放在注释中

语法：<!-- 注释内容 -->

快捷方式：ctrl+/ 不能嵌套注释，不能写在标签内部

 

## 3、HTML的文档结构

### （1）文档类型的声明<!DOCTYPE html>

告诉浏览器，解析运行本篇代码，使用h5的规则解析

### （2）网页结构<html> </html>

表示网页的开始和结束，一个html文件中只能有一对html标签

<!doctype html>

<head></head>网页头部，定义网页信息

<body></body>网页主体，展示内容

</html>

### （3）head标签 <head> </head>

定义网页的信息

  <meta>                                     元数据标签

  <meta charset="utf-8">                        设置中文编码

  <meta name="description" content="描述内容">   网页描述

  <meta name="Keywords" content="关键字">      关键字设置

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) <title></title>                 网页标题

  <script></script>                              定义js代码或者引用js文件

  <style></style>                               css中，定义内部样式

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) <link/>                    css中，引用外部css文件的样式

### （4）body标签 <body>  </body>

<body></body> 指定网页的主体

属性：

bgclor ：body的背景颜色，取值颜色的合法值

text ： body 文本的颜色，取值颜色的合法值

  <!--告诉浏览器，本文档使用\h5的规则来解析-->  <!DOCTYPE html>    <html>  <head>   <!--  设置中文编码  -->       <meta  charset="UTF-8">   <!-- 网页描述 -->       <meta  name="viewport" content="width=device-width,  initial-scale=1.0">   <!--  网页的标题  -->       <title></title>   </head>  <!--  网页主体，展示内容  -->  <body bgclor="pink"  text="purple"> <!--  设置网页背景和文本颜色  -->       </body>  </html>  

## 4、文本标记

### （1）语法和属性

| 标签     | 语法                       | 属性                                                         | 表现形式                                                     |
| -------- | -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 标题     | <h1> </h1>  ……  <h6> </h6> | align=" ";                                                   | a)字体大小有变化，h1最大，h6最小  b)字体加粗  c)单独成行，上下有垂直间距 |
| 段落     | <p> </p>                   | align="left";                                                | 独立成行，有垂直间距                                         |
| 换行     | <br>或<br/>                |                                                              |                                                              |
| 分割线   | <hr> 或 <hr/>              | size 设置水平线的粗细，取值单位px；  width 设置水平线的宽度，取值单位px、%（父元素宽度的%）  color 设置水平线颜色  align  内容水平对齐  left/center(默认缺省值)/right |                                                              |
| 预格式化 | <pre></pre>                |                                                              | pre可以保留html代码中的回车和空格效果  单独成行              |

 

| 特殊字符 | **空格** | **&nbsp** | 文本样式  | 斜体 | em或i |
| -------- | -------- | --------- | --------- | ---- | ----- |
| <        | &lt      | 加粗      | strong或b |      |       |
| >        | &gt;     | 删除线    | del或del  |      |       |
| ©        | &copy    | 下划线    | del或s    |      |       |
| ®        | &reg     | 上标      | sup       |      |       |
| ×        | &times   | 下标      | sub       |      |       |
| 人民币   | &yen     |           |           |      |       |

 

| 块分区 | <div></div>   | 属性：单独成行；align="" | 页面布局的时候，使用div  |
| ------ | ------------- | ------------------------ | ------------------------ |
| 行分区 | <span></span> |                          | 处理同一行文字的不同样式 |

### （2）标签的显示方式

| 行内元素 | 与其他行内元素共用一行，默认从左往右显示 | i em s del b strong  span sub sup | 都不支持align | 靠内容撑开，没有内容，就没有宽度                             |
| -------- | ---------------------------------------- | --------------------------------- | ------------- | ------------------------------------------------------------ |
| 块级元素 | 独占一行，默认从上往下排列               | h1~h6 p   pre hr div              | 支持align属性 | 不设置宽度，默认占父元素宽度100%                             |
| 行内块   | 与其他的行内元素和行内块共用一行         | input                             |               | 浏览器默认给input的一个宽高，但是不同浏览器给的默认宽高不一样 |
| table    | 是一种特殊的表现方式                     | <table></table>                   |               |                                                              |

## 5、图像和链接

### （1）语法和属性

| 图像标签  <img>或<img />                                     | 语法：<img  src=" " alt" "  title=" " width=" " height="">   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 属性：  l src：source源，资源路径  l alt：图片加载错误时，显示的文字  l title：鼠标悬停时，显示的文字  l width：设置图片的宽度；height：设置图片的高度  注：图片是行内元素，但是可以设置宽高  常用的图片的格式  l  jpg、png、gif 动态图  注：如果设置的宽高比不是图片的原始宽高比，图片会产生失真效果，一般情况下，width和height只设置一个，另外一个自适应） |                                                              |
| 链接  <a>   </a>                                             | 语法：<a  href="  "  target="_blank">链接的内容</a>          |
| href：链接路径、  target：指定打开链接的方式   _self 默认值，在当前也main打开新网页  _blank在新页面打开网页  注：a标签需要添加href属性，才会出现连接功能，不然就是普通文本 |                                                              |
| a标签其他功能                                                | <a href="mailto:cheng@t.com">发邮件</a>  使用a标签打开邮件发送软件（没安装软件就无反应） |
| **[**](javacsript:show())**执行****js****语句********（非常重要）**  使用a标签，调用js |                                                              |
| <a href="#">返回页面顶部</a>  a标签的时候还不知道指向哪个链接，可以先使用#替代 |                                                              |
| <a href="1.zip">下载</a> 基本不用，下载的文件类型太有限      |                                                              |

### （2）URL

Uniform Resource Locator 统一资源定位符，俗称路径

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 绝对路径---使用网络资源的时候使用绝对路径

完整路径，通信协议+主机名称+文件目录结构+具体文件名称http://cdn.tmooc.cn/imgad/455.png

使用网络资源的优点：资源不占用自己服务器的存储空间；缺点：资源不稳定

绝对路径可以访问本服务资源，但是，项目中切记不要用这种方式

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 相对路径-----使用本服务器资源，用相对路径

|                              |                      |                                   |
| ---------------------------- | -------------------- | --------------------------------- |
| 资源相对当前html的路径       | 语法                 |                                   |
| 资源在html文件的上上一级目录 | ../../文件名         | <img  src="../../4.jpg">          |
| 资源在html文件的上一级目录   | ../文件名            | <img  src="../img3_wide.jpg">     |
| 资源和html文件在同一目录     | 文件名               | <img  src="02.png">               |
| 资源在html文件的下一级目录   | 目录/文件名          | <img src="img-素材/3.jpg">        |
| 资源在html文件的下下一级目录 | 目录名/目录名/文件名 | <img src="img-素材/image/06.png"> |

### （3）锚点

锚点，就是页面中的一个记号，可以通过a标签，让页面回到这个记号处

1）定义锚点

l  h4版本定义锚点：使用a标签定义锚点<a name=“锚点名称”>……</a>

l  版本定义锚点：使用任意元素id值当做锚点名称  <any id=”锚点名称”>……</any>any指任意元素

2）激活锚点：<a href=”#锚点名称”></a>

## 6、表格

### （1）语法和属性

早期，表格用于页面的布局，由于加载速度慢，抛弃使用表格布局了

现在，表格专属用于数据展示

| <table>表格开始  <tr>行  <td></td> 列  </tr>  </table> | 在当前页面，再创建一个4*4的表格，内容是1~16  table>tr*4>td*4 |
| ------------------------------------------------------ | ------------------------------------------------------------ |
|                                                        |                                                              |

table的属性

| width="300px"            | 表格的宽度                                 |
| ------------------------ | ------------------------------------------ |
| height="300px"           | 表格的高度                                 |
| border="1px"             | 表格的边框                                 |
| align="center/left/right | "表格的水平对齐方式                        |
| bordercolor="red"        | 边框颜色                                   |
| bgcolor="pink"           | 背景颜色                                   |
| cellpadding="10px"       | 表格内边距，边框到内容的距离（以左和上为准 |
| cellspaceing="10px"      | 表格的外边距，边框到边框的距离             |

tr的属性

| bgcolor="yellow"           | 背景颜色                   |
| -------------------------- | -------------------------- |
| align="left/center/right"  | 表格一行的内容水平对齐方式 |
| valign="top/middle/bottom" | 表格一行的内容垂直对齐方式 |

td的属性

| width="70px"               | 当前单元格宽度         |
| -------------------------- | ---------------------- |
| height="70px"              | 当前单元格高度         |
| align="left/center/right"  | 当前单元格水平对齐方式 |
| valign="top/middle/bottom" | 当前单元格垂直对齐方式 |
| bgcolor="blue"             | 当前单元格             |
| **colspan="2"**            | 跨列,合并列            |
| **rowspan="3"**            | 跨行,合并行            |

1.跨列: colspan，从指定单元格位置处开始,横向向右合并n个单元格(n包括自己),被合并的单元格删除

2.跨行: rowspan，从指定单元格的位置处,纵向向下合并n个单元格(n包括自己),把被合并的单元格删除

\3. <caption>表格的标题，</caption>如果要设置标题,caption必须紧跟<table>标签后面

\4. **行****/****列的标题**，td的属性,th都可以用，替换的特点:**文字加粗****,****水平居中**。

### （2）表格的复杂应用

表结构标签，在页面中，不可见。我们制作的表格,浏览器会自动的添加上<tbody></tbody>标签

1.行分组:可以将连续的几行,划分到同一个组中,进行统一的管理

  1.<thead></thead>  表头  2.<tbody></tbody>  表主体  注意，不写表结构，浏览器会自动添加tbody  3.<tfoot></tfoot>  表脚  

2.表格的嵌套：表格当中所有的嵌套都只能放在td中完成

### （3）表格的显示方式

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 每一行，对应的列，宽度相同；每一行，所有的列，高度相同

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 内容少，设置宽高大，表格按照设置宽高显示；内容多，设置宽高小，表格按照内容宽高显

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 表格的渲染步骤，与其他元素不同，先把数据存储到内存中，再一次性渲染到页面，效率低

注:浏览器解析html文本的时候，没有空格，就认为是一个单词，不会换行；有空格，认为是多个单词，放不下会自动换行

| 提升练习： |      |
| ---------- | ---- |
|            |      |

## 7、列表

让数据更有条理的显示，很多时候习惯使用无序列表做布局

### （1）语法和属性

| 有序列表  older list（ol）   | 语法：<ul>       <li>列表项</li> list item      <li>列表项</li>  </ul> | 属性：  1)      type  设置标题项的类型  取值：1（默认），a，A，i，I  2)      start 设置标题项的起始编号 |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 无序列表  unolder list（ul） | 语法：<ol>       <li>列表项</li>      <li>列表项</li>  </ol> | 属性：  type 设置列表符号  取值：dis（默认）circle，square，none     实心圆  空心圆 实心方块 无标识 |
| 项目列表  （h5新元素）       | 语法：<dl>      <dt>项目标题</dt>      <dd>描述1</dd>  </dl> | 对一个名词进行解释说明的时候使用项目列表（定义列表平）       |

### （2）列表的嵌套

所有嵌套的内容，都要放在li中，是语义要求。

li中可以嵌套其他元素(a、img、p......)，还可以嵌套其他列表。

## 8、结构标记

HTML5所提供的结构标记，专门用于表示常见的网页结构（即布局），用于替代div，描述整个网页的结构，结构标记的作用与div一样，结构标记有语义，增加了可读性，更容易被搜索到

### （1）常用结构标记

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif)  <header></header> 定义网页的头部，或者某个区域的顶端

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif)  <nav></nav> 定义网页的导航链接

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif)  <section></section> 定义网页的主体

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif)  <aside></aside> 定义网页的侧边栏

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) <article></article> 定义与文字相关的内容，比如回帖，评论

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) <footer></footer> 定义网页的底部，或者某个区域的底部

## 9、表单

浏览器提交数据给服务器的方式有两种，一是form提交，二是ajax提交

使用form，就不用ajax；使用ajax，就不用form

form，没有接收响应的能力。后面的课程，使用ajax来发送请求，并接收响应。

### （1）表单组成

l 前端部分：提供了可视化输入控件，自动收集用户输入的信息，并提交请求给服务器，

l 后端部分：后台接口，接收请求，对请求进行处理，发送响应。

### （2）表单元素

| 表单标签  <form>   </form>                 | 语法：  ****  <input  type=""  name=""  id="" value="" />  **** |
| ------------------------------------------ | ------------------------------------------------------------ |
| 属性                                       | 取值                                                         |
| 1）action                                  | 定义表单提交时发生的动作，填写提交的接口  默认缺省，提交给当前html本页 |
| 2）method  定义表单提交的方式，提交的方法  | a）method="get"（默认缺省值）  明文提交，提交的内容会显示在地址栏  提交的数据有大小限制，最大2KB  b）method="post"  隐式提交，提交的内容不在地址栏显示  提交的内容在form data(请求主体)中  c）put/delete/option. |
| 3）enctpte  设置表单可以提交什么类型的数据 | a）enctype="application/x-www-form-urlencoded"（默认缺省值）允许提交任意字符，不能提交文件  b）enctype=" multipart/form-data "  允许提交文件给服务器  c）enctype=" text/plain "  允许提交普通字符（不能有& = 等特殊符号 |

### （3）表单控件

在form标签中，能够与用户进行可视化交互的元素

##### 1.input输入

| 控件标签  <input>   | 语法：  <form action="" method=""  enctype="">  ****  </form>  所有input天生都是行内块，天生自带宽高，不同浏览器，自动带的宽高不同 |
| ------------------- | ------------------------------------------------------------ |
| ** **type=""****>** | 公有的属性，指定input元素的类型（9种）                       |
| input通用属性       | 特点                                                         |
| name=""             | 为控件定义名称，  使用form表单提交数据，要提交的数据的name必须写  使用ajax提交，就不需要写name（单选多选除外，name分组）  总结：使用ajax，不需要name属性，使用form提交，要用name |
| value=""            | 控件的值，真正提交给服务器的值  **例外，在按钮中，****value****是设置按钮的文本** |
| disabled            | 禁用，无值属性。不能选中，不能修改，不能提交                 |

type的取值：

| <input type=”**text**”>      | 文本框                   | text是input的默认值  文本框和密码框专有属性：  a）maxlength 设置用户输入的最大长度  b）readonly  只读，无属性值，只看不能改，但是可以提交  c）placeholder 提示占位符 |
| ---------------------------- | ------------------------ | ------------------------------------------------------------ |
| <input type=”**password**”>  | 密码框                   |                                                              |
| <input type=”**submit**”>    | 提交按钮                 | 将表单中的数据，收集整理并发给服务器                         |
| <input type=”**reset**”>     | 重置按钮                 | 将表单恢复到初始状态                                         |
| **< button >< button />**    | 普通按钮                 | 没有任何功能，专门用来激活js方法  <button></button>  功能和submit相同，h5新出的元素 |
| <input type=” **radio**”>    | 单选按钮                 | 必须使用name属性，做分组，不然不会出现单选效果  必须有value值，不然值都是on |
| <input type=” **checkbox**”> | 多选按钮                 | 必须使用name属性，做分组，不然不会出现多选效果  必须有value值，不然值都是on  checked 无值属性，默认选中 |
| <input type=”**hidden**”>    | 隐藏域                   | 想把数据提交给服务器，但是又不想让用户看到                   |
| <input type=”**file**”>      | 文件选择框  （上传文件） | 想上传文件，需要修改form标签的2个属性  a）method="post"  post没有上传数据的大小数据  b）enctype="multipart/form-data" 允许提交文件给服务器  multiple 无值属性，可以一次选择多个文件提交 |

##### 2. textarea多行文本域

| 控件标签  <textarea></textarea>                              | 语法：  <form  action="" method="" enctype="">  ****  ****  </form> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 属性  rows=""  cols=""设置一行能显示多少字符，一共多少行  1.用户可以手动调整大小，不可取  2.col的设置，根据硬件不同，值会不同，不统一，不可取。 |                                                              |

##### 3. select下拉选择框

| 控件标签  <select>  </select>                                | 语法：  <form  action="">  ****  ******北京******  ******上海******  ******广州******  ****  </form> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 最后提交的是select的name=select的value  1.option没有value的时候，select的value是选中的那个option的内容区域的值  2.option有value的时候，select的value是选中的那个option的value值  select属性：name  size 默认值为1，取值>1的时候，变成滚动选择框  multiple 在滚动选择框下，进行多选  option属性  selected无值属性，默认选择 |                                                              |

##### 4.其他元素

| 其他控件  标签                                               | 关联控件：lable  <label for=”要关联的控件id”></label>        | 1.label可以选择性的替代form中span,不强制  2.可以关联控件，点击label也可以选中控件  使用lable的for属性，引用要关联的控件id值 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 控件分组：fieldest>legend  <fieldset>    分组边框     <legend></legend> 分组的名称  </fieldset> |                                                              |                                                              |
| 浮动框架：  （不属于form表单的知识）  <iframe></iframe>      | 在一个html中引入其他的html文件  src="02_list.html" 要引入的html资源路径  frameborder="0"   框架的边框  scrolling="no"   设置滚动条  yes/no  height="1000px"  框架的高度  width="100%"   框架的宽度 |                                                              |

 

| 提升练习：             |               |
| ---------------------- | ------------- |
| 完成表单合并单元格练习 | 完成input练习 |

##### 7.新表单元素（10个）

h5新增的input元素

| <input type="email"  name="mail">    | 邮箱     | 提交的时候，自动验证格式  @前后必须有字符             |
| ------------------------------------ | -------- | ----------------------------------------------------- |
| <input type="search"  name="search"> | 搜索类型 | 有快速清除的小叉叉                                    |
| <input type="url"  name="url">       | 网址类型 | url类型提交的时候，验证http:                          |
| <input type="tel"  name="tel">       | 电话号码 | 在移动端运行，会弹出虚拟键盘                          |
| <input type="number" name="number">  | 数字类型 | max="20" min="10设置最大值、最小值  step="3" 设置步长 |
| <input type="range"  name="range">   | 范围类型 |                                                       |
| <input type="color"  name="c1">      | 颜色类型 | 提供了一个取色器                                      |
| <input type="date"  name="date">     | 日期类型 | 提供一个日期选择控件                                  |
| <input type="month"  name="month">   | 月份类型 |                                                       |
| <input type="week"  name="week">     | 星期类型 |                                                       |

 

 

 



 

## 二、AJAX

## 1、ajax前瞻--http协议

### （1）URL

url结构：协议+服务器主机名称+目录结构+文件名称

| **完整的****URL**   <scheme>://<user>:<pwd>@<host>:<port>/<path>;<params>?<query>#<flag> |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ****                                                         | 协议，定义了以哪种方式获取服务器资源                         |
| **:**                                                        | 早期，服务器管理的登录模式，现在很少有人使用了，因为会暴露用户名和密码 |
| ******主机名称**                                             | 127.0.0.1 IP（[www.tmooc.cn](http://www.tmooc.cn) 域名 localhos） |
| ****                                                         | 端口号，对应着主机中的不同服务                               |
| ******路径**                                                 | 资源在服务器上的具体的存放位置                               |
| ******参数**                                                 | 跟踪状态的参数，session/cookie                               |
| ****                                                         | 查询字符串                                                   |
| ****                                                         | 锚点                                                         |

 

| **常见协议** | **默认端口号** | **协议基本作用**    |
| ------------ | -------------- | ------------------- |
| FTP          | 21             | 文件上传、下载      |
| SSH          | 22             | 安全的远程登录      |
| TELNET       | 23             | 远程登录            |
| SMTP         | 25             | 邮件传输            |
| **DNS**      | **53**         | **域名解析**        |
| **HTTP**     | **80**         | **超文本传输**      |
| POP3         | 110            | 邮件接收            |
| **HTTPS**    | **443**        | **加密传输的HTTPS** |

### （2）http协议

HyperText Transfer protocol（http）：超文本传输协议，规范了数据是如何打包和传递的，是专门传输html的

##### 1.http协议的历史

http0.9----->**http1.1**

##### 2.请求与响应流程

 

在客户端输入域名（www.baidu.com）是无法访问服务器的，访问服务器就一定要用ip地址，DNS服务器就是用于域名转换成IP地址，所以客户端请求服务器必须要进行DNS查询，DNS响应对应的IP地址，客户端得到IP地址后，客户端请求web服务器，web服务器作出响应

Message消息/报文 是http协议，在客户端与服务器端传递数据块

HTTP规定，这个数据块必须符合特定的格式，才能被彼此理解

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) Request Message 客户端发送给服务器端的请求消息

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) Response Message 服务器端发送给客户端的响应消息

##### 3.请求消息Request Message

请求消息，客户端发送给服务器端的数据块，分为三部分：请求起始行，请求头，请求主体。

1） 请求起始行（Request Headers的第一行）

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 请求方法：GET  协议版本：/ HTTP/1.1  请求的url： Host: www.tmooc.cn

| 请求方法 | 原生的http请求  （http自带的请求方法）                       | Restful API 请求  （统一了接口格式，统一了请求方法）         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
|          | a）get明文提交  获取服务器信息的时候用，最大2kb  req.query  没有请求主体  b）post 隐式提交  向服务器传递数据的时候  req.body  有请求主体  c）put把文件放到服务器上的时候使用     d）delete 删除服务器上资源的时候使用     e）option预请求 | a）get 所有查询的模块都用get  select    req.params  没有请求主体  b）post所有的新增数据都用post  insert  req.body   有请求主体  c）put 所有的修改用修改 （update）  有请求主体  d）delete  所有的删除用  （delete）  没有请求主体 |

2）请求头（Request Headers）

| **Host:** [www.tmooc.cn](http://www.tmooc.cn) | 浏览器告诉服务器，请求的哪个主机                       |
| --------------------------------------------- | ------------------------------------------------------ |
| **Connection**: keep-alive                    | 浏览器告诉服务器，请开启持久连接                       |
| **User-Agent:**                               | 浏览器告诉服务器，我此时的浏览器类型和版本号           |
| **Accept-Encoding**: gzip,  deflate           | 浏览器告诉服务器，我这个浏览器能够接收的压缩文件的格式 |
| **Accept-Language**:  zh-CN,zh;q=0.9          | 浏览器告诉服务器，我能够接收的自然语言的类型           |
| **Referer**: http://www.tmooc.cn/             | 浏览器告诉服务器，这个请求来自于哪个网页               |

我的浏览器类型和版本号：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36

3）请求主体form data

 post/put有请求主体 get/delete 没有请求主体

##### 4.响应消息Response Message

响应消息，服务器端发送给客户端的数据块，分为三部分：响应起始行，响应头，响应主体

1）响应起始行 

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 协议版本号HTTP/1.1 响应状态码200  响应状态码的原因短句OK

响应状态码，告诉浏览器，服务器的响应状态是什么

| 1XX     | 正在请求，提示信息           |
| ------- | ---------------------------- |
| 2XX     | 200响应成功                  |
| 3XX     | 重定向                       |
| 301     | 永久重定向                   |
| 302     | 临时重定向                   |
| 304     | 不连接服务器，使用浏览器缓存 |
| 4XX     |                              |
| **404** | **请求资源不存在（查路径）** |
| 403     | 权限不够                     |
| 405     | 请求方法不被允许             |
| 5XX     | 500 服务器代码错误           |

2）响应头

| Date: Tue, 11 Feb 2020 06:43:05 GMT, | 告诉浏览器，服务器响应的具体时间 |
| ------------------------------------ | -------------------------------- |
| Connection: keep-alive               | 告诉浏览器，已经开启了持久连接   |
| Content-Type: text/html              | 告诉浏览器，响应主体的数据类型   |

响应主体数据类型

| text/html              | 响应回来的数据是html   |
| ---------------------- | ---------------------- |
| text/plain             | 是普通文本             |
| text/css               | 是css文件              |
| application/javascript | 是js文件               |
| image/png jpg gif      | 是图片文件             |
| application/json       | 响应回来的是json字符串 |
| application/xml        | 响应回来的是xml字符串  |

3）响应主体，服务器传给浏览器的数据    

**请求消息和响应消息总结**

| 请求消息头Request Message                                    | 响应消息头Response Message                  |
| ------------------------------------------------------------ | ------------------------------------------- |
| 请求起始行  请求方法/http.1.1/请求的url                      | 响应起始行  请求方法/http.1.1/响应状态码    |
| 请求头                                                       | 响应头                                      |
| host  connection:keep-alive  user-agent  Accept-Encoding  Accept-language  Refere | Date   Connection:keep-alive   Content-type |
| 请求主体                                                     | 响应主体                                    |

##### 5.缓存

客户端第一次访问服务器，将服务器响应回来的数据，在本地进行自动保存

客户端下一次再访问这个请求，直接使用之前保存好的数据，不连接服务器

​     

1）缓存的优点

l 节省了客户端的流量，减少了冗（rong）余的数据传输

l 节省服务器带宽

l 降低了对服务器资源的消耗和运行的要求

l 降低了由于远距离传输而造成的加载延迟

2）缓存的机制

l 请求—无缓存—连接服务器—存缓存—客户端得到

l 请求—有缓存—新鲜—使用缓存—客户端得到

l 请求—有缓存—不新鲜—连接服务器确认是否过期—没过期—更新新鲜度—客户端得到

l 请求—有缓存—不新鲜—连接服务器确认是否过期—已过期—连接服务器—存缓存—客户端

 

##### 6.缓存的消息头信息

1）消息头

Cache-Control: no-cache  没有缓存

Cache-Control: max-age=3600（秒） 缓存处于新鲜的时间是多少

2）设置缓存，前端部分代码

<meta http-equiv=” 消息头名称” content=”值”/>

<meta http-equiv=” Cache-Control” content=”max-age=3600”/>

##### 7.HTTP性能优化

1）http的连接过程

发送请求—建立连接—服务器处理请求—访问资源—构建响应—发送响应—记录日志

2）http连接性能优化

l 减少连接的创建次数（开启持久连接）

l 减少请求的次数(使用缓存)

l 提高服务器端运行速度(硬件和软件配合)

l 尽可能的减少响应数据的长度（响应数据的长度，尽量短）

### （3）安全的http协议（https）

HTTPS 安全版本的http协议

SSL，为数据通信提供安全支持

l 客户端发送请求-->SSL层加密-->服务器接收到加密文件-->在SSL层解密-->得到请求明文

l 服务器端发送响应-->SSL层加密-->浏览器接收到加密文件-->在ssl层解密-->得到请求明文

## 2、ajax前瞻—简易dom操作

为什么学ajax之前，要学习dom？

使用的form表单提交请求，form表单能够自动的收集整理控件中的数据，但是ajax没有自动收集数据的能力，所以，我们需要使用dom，手写代码，收集数据！

注意：

1）form自动收集数据前提，必须有name属性！！

2）ajax就不需要name属性了，使用id。但是当使用单选按钮和多选按钮，还需要使用name，为了分组！！ 

### （1） 完整的JavaScript组成

1） js核心，ECMA Script

2）DOM Document Object Model 文档对象模型

使用js获取标签对象，修改标签的属性值和样式js 

3）BOM Browser object Model  浏览器对象模型

使用js操作浏览器的

 

### （2）使用dom

1）方法一

先使用事件，调用js方法

步骤一：得到要操作的元素对象   

找元素：document.getElementById("元素id")

步骤二：操作对象，调用方法和属性 

获取值：对象变量.属性；设置值：对象变量.属性="值"

| 使用dom操作，通过value操作input元素                          | 使用dom操作，通过innerHTML双标签                             |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| <script  type="text/javascript">  function show**()**{  var inp=document**.**getElementById("uname");   var msg=inp**.**value;                inp.value="abcd";//设置值  }  </script>  <body>  <input id="uname" type="text">  <button  onclick="show()">显示</button>  </body> | <script type="text/javascript">  function show(){  var div1=document.getElementById("d1")    var msg1=div1.innerHTML;    div1.innerHTML=`<a href="#">abc</a>`;  }  </script>  <body>  <div id="d1"></div>  <button  onclick="show()">显示</button>  </body> |

2）方法二

ES6规定，可以直接使用元素id值，当做对象来使用，即直接通过元素id操作对象

获取值：元素id.属性；设置值：元素id.属性="值"

| 直接使用id当做对象来使用                                     | 注意：                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| <script>  function login(){       var  $uname=uname.value;       var  $upwd=upwd.value;       console.log($uname);       }  </script>  <body>       <input  type="text" id="uname"><br>       <input  type="password" id="upwd"><br>       <button  onclick="login()">登录</button>  </body> | js变量的命名规则  1.不能以数字开头       2.可以包含 _ $       3.不能用关键字       4.尽量做到见名知意  注意：  由于直接使用id充当对象，所有有时候变量会发生冲突，要把普通变量名和id区分开。  变量名称自定义，为了便于理解一般是在id名前加**$** |

 

| 提升练习：                                                |                                                              |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| 点击按钮，在div中生成如下表格  表格数据，自己创建对象数组 | 点击按钮，把文本框中输入的值，显示到p标签  点击按钮，把文本框中输入的值，显示到p标签 |
|                                                           |                                                              |

### （3）事件

根据用户的行为，激发的操作，就是事件

1）击事件：onclick=”show()” 用户点击这个元素，调用show()方法

2）页面加载事件：onload=“show()”  onload必须写在body标签中

2） 取焦点事件：onfocus=“方法”

4）失去焦点事件：onblur=”方法”

| <script>  function  show_uname(){  uname_msg.innerHTML="用户名6~12位";}  function show_upwd(){  upwd_msg.innerHTML="密码8~16位";}  function  check_uname(){  var $uname=uname.value;}  if(!$uname){           uname_msg.innerHTML="用户名为空";       }else{           uname_msg.innerHTML="已填写用户名";} | function check_upwd(){  var $upwd=upwd.value;       if(!$upwd){       upwd_msg.innerHTML="密码不能为空";       }else{       upwd_msg.innerHTML="密码已填写";       }  </script> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| <input onblur="check_uname()"  onfocus="show_uname()"  type="text" id="uname">  <span  id="uname_msg"></span><br>  <input onblur="check_upwd()" onfocus="show_upwd()" type="text"  id="upwd">         <span  id="upwd_msg"></span><br>  <button>登录</button> |                                                              |

 

| 提升练习：                                                   |      |
| ------------------------------------------------------------ | ---- |
| 在3个input都正确的情况下，点击登录按钮，弹窗登录成功  有一个input不符合邀请，点击登录按钮，弹窗不能登录 |      |

## 3、Ajax:

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 同步Synchronous：在一个任务进行的过程中，不能开启其他任务

同步的访问：浏览器在向服务器发送请求时，浏览器只能等到服务器的响应，不能做别的任何事情

同步使用场景：1）地址栏输入url是同步2）标签的跳转3）form表单的提交

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 异步Asynchronous：在一个任务开启时，可以进行其他任务！！！

异步访问：浏览器在向服务器发送请求时，浏览器可以做其他操作，不影响任何事

异步使用场景：1）用户名重复的验证2）股票走势图3）百度搜索建议

Ajax：Asynchronous javascript and XML 异步的js和xml 

本质：使用js提供的异步对象（XMLHttpRequest）xhr

使用这个异步对象，向服务器异步的发送请求并接收响应

### （1）ajax的使用

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 浏览器地址栏访问，使用的是get请求，所以只能访问get的接口

get方法，可以使用浏览器地址栏进行验证，其他不能用地址验证

4个步骤：写代码的正确顺序1-->4-->2-->3

| 1）var xhr=new XMLHttpRequest();  2）xhr.open("get",”/ajax/ajaxdemo”,true);  3）xhr.send(formdata);  4）xhr.onreadystatechange=function(){   if(xhr.readyState==4  && xhr.status==200){     var  result=xhr.responseText;     alert（result）;  }  } | 1）创建异步对象xhr     2.打开连接，创建请求  参数1，请求方法，必须放在字符串中  参数2，请求的url，就是接口  参数3，是不是要发送异步请求，true--异步 false--同步     3）发送请求  参数，如果请求没有请求主体，可以使用null,或者不填如果有请求主体，参数就为请求主体formdata     4）创建监听，接收响应  xhr.readyState用于表示xhr对象的请求状态，一共5个状态  ![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif)  0：请求尚未初始化  ![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif)  1：已经打开连接，请求正在发送  ![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif)  2：接收响应头  ![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif)  3：接收响应主体  ![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif)  4：接收响应成功  xhr.readyState的值每改变一次，function就会运行一次，一共会执行4次  xhr.onreadystatechange=function(){  要readyState的第四次，同时响应还是正确的  xhr.status响应状态码  xhr.responseText;保存着响应数据 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

1）原生http的get请求，不带参数

xhr.open("get","url",true)；

| 编写01_ajax.html 点击按钮访问 /ajaxdemo的接口。把响应数据放到div中显示 |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 01_ajax.html  function show(){       var  xhr=new XMLHttpRequest();       xhr**.**onreadystatechange=function(){       if(xhr**.**readyState==4  && xhr**.**status==200){                  var r=xhr.responseText;                  d1**.**innerHTML=r;                }            }            xhr.open("get","/ajax/ajaxdemo",true);            xhr.send();       } | 路由（接口）  router.get("/ajaxdemo",function(req,res){       console.log('接收到请求');       res.send("my  first ajaxdemo");  }); |
| <button onclick="show()"> </button>  <div id='d1'></div>     |                                                              |

2）原生http的get请求，带参数

xhr.open("get","url？"+参数,true)；

| 编写02_login.html,点击按钮访问 /login 的接口并发送参数。把响应数据放到div中显示。 |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 02_login.html  function login(){       var $uname=uname.value;       var $upwd=upwd.value;       var xhr=new XMLHttpRequest();       xhr.onreadystatechange=function(){       if(xhr.readyState==4 && xhr.status==200){            var r=xhr.responseText;            d1.innerHTML=r;}  }  xhr.open("get","/ajax/login?uname="+$uname+"&upwd="+$upwd,true);  xhr.send();} | 路由（接口）  router.get('/login',function(req,res){       var  $uname=req.query.uname;       var  $upwd=req.query.upwd;       res.send($uname+'......'+$upwd);  }); |
| <input id='uname'  type="text"><br>  <input id='upwd'  type="text"><br>  <button onclick="login()">登陆</button>  <div id='d1'></div> |                                                              |

 

  编写03_http_login.html,点击按钮访问  /http_login接口. 接口获取前台uname,upwd.  要求做非空验证，查询数据库，如果查到，返回响应1，如果没查到返回响应0  

3）restful的get请求(不带参数)

restful的get请求和原生http的不带参数的get请求是一模一样的

4）restful的get请求(带参数)

restful的get登录（按照restful要求，所有查询使用get），restful要求，查询字符串的参数，写在url中，参数名称之前添加冒号 **:**  ，所有添加 : 的参数，不能使用query去获取，使用param

后台路由：/restful_login/:uname&:upwd

前台请求：xhr.open("get","/ajax/restful_login/"+$uname+"&"+$upwd,true);

| 编写04_restful_login.html,点击按钮访问  /http_login接口. 接口获取前台uname,upwd.  要求做非空验证，查询数据库，如果查到，返回响应1，如果没查到返回响应0 |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 04_restful_get.html  function login(){       var $uname=uname.value;       if(!$uname){         d1.innerHTML="用户名不能为空";return;}       var $upwd=upwd.value;       if(!$upwd){         d1.innerHTML="密码不能为空";return;}  var xhr=new XMLHttpRequest();  xhr.onreadystatechange=function(){  if(xhr.readyState==4 && xhr.status==200){             var  r=xhr.responseText;             d1.innerHTML=r;            }       }              xhr.open("get","/ajax/restful_login/"+$uname+"-"+$upwd,true);       xhr.send();  } | 路由（接口）  router.get("/restful_login/:uname-:upwd",(req,res)=>{       var  $uname=req.params.uname;       var  $upwd=req.params.upwd;       var  sql="select * from xz_user where uname=? and upwd=?";       pool.query(sql,[$uname,$upwd],(err,result)=>{       if(err)  throw err;       if(result.length>0){         res.send("1");       }else{            res.send("0");       }  });  }); |
| <input  type="text" id="uname"><br>  <input  type="text" id="upwd"><br>  <button  onclick="login()">登录</button>  <div  id="d1"></div> |                                                              |

注：

1.定义接口的时候，参数名称需要添加：,但是调用接口传输参数的时候，没有冒号

2.多个参数的连接，可以使用&和-，但是需要前后端对应

3.restful的非空验证，不能写在后端。只能放在前台验证！！

4）restful的delete请求 

restful的delete与restful的get一模一样，只是把get改成delete

| 编写05_restful_del.html,输入用户id，点击按钮，数据库中删除对应id的数据 |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 05_restful_del.html  function del(){       var  $uid=uid.value;       var  xhr=new XMLHttpRequest();       xhr.onreadystatechange=function(){       if(xhr.readyState==4  && xhr.status==200){            var  r=xhr.responseText;            d1.innerHTML=r;}}      xhr.open("delete","/ajax/restful_del/"+$uid,true);       xhr.send();} | 路由（接口）  router.delete("/restful_del/:uid",function(req,res){       var  $uid=req.params.uid;       var  sql="delete from xz_user where uid=?";       pool.query(sql,[$uid],function(err,result){            if(err)  throw err;            console.log(result.affectedRows);            if(result.affectedRows==0){                res.send("0");            }else{res.send("1");}       });  }); |
| <input type="text"  id="uid"><br><br>  <button onclick="del()">删除</button>  <div id="d1"></div> |                                                              |

5）result的post和put（有请求主体）

http的post/put,与restful的post/put一模一样

| 编写06_post_login.html,点击按钮访问 /post_login接口. 接口获取前台uname,upwd.  要求做非空验证，查询数据库，如果查到，返回响应1，如果没查到返回响应0 |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 06_post_login.html                                           | 路由（接口）  router.post("/post_login",function(req,res){       var  $uname=req.body.uname;       var  $upwd=req.body.upwd;       var  sql="select * from xz_user where uname=? and upwd=?";       pool.query(sql,[$uname,$upwd],function(err,result){            if(err)  throw err;            console.log(result);            if(result.length===0){                res.send("0");            }else{                res.send("1");}             });  }); |
| function login(){       var $uname=uname.value;       var $upwd=upwd.value;       if(!$uname){d1.innerHTML="用户名不能为空";return;}       if(!$upwd){d1.innerHTML="密码不能为空";return;}       var xhr=new XMLHttpRequest();       xhr.onreadystatechange=function(){       if(xhr.readyState==4 && xhr.status==200){            var r=xhr.responseText;            d1.innerHTML=r;}  }  xhr.open("post","/ajax/post_login",true);  //设置请求头信息，能够传递所有文本  xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");  var formdata="  uname="+$uname+"&upwd="+$upwd;  xhr.send(formdata);} |                                                              |

 

  编写07_put_login.html,创建接口  /put_login，使用put，连接数据，登录操作  编写08_put_reg.html,创建接口 /post_reg，使用post完成注册功能  编写09_getlist.html，刷新页面，获取所有用户信息（放入表格中），使用console.log（）打印在控制台。  

6）restful请求方法总结

  restful请求方法 get  delete post put  语义要求  人为的规定 get---->查询，delete--->删除， post---->新增，put---->修改  语法要求，所有查询字符串传参，都可以使用get、delete       所有请求主体传参，都可以使用post、put  

### （2）JSON解析

1）json：javascript object notation 以js对象的格式表现出来的字符串

服务器从数据库得到obj类型，当做响应数据，传递给浏览器，在传递过程中，自动的转换成string类型；前台，会得到一个string的数据。这个string的类型，叫做**json****字符串**，我们如果想要操作这个数据，需要把json字符串解析成obj类型。**var arr=JSON.parse(r)**

2）json的特点

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 在数据的传递过程中，自动生成json串

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) json中对象的属性必须带双引号

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 值是字符串的，也必须带双引号

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 把json字符串解析成js对象 JSON.parse(json串)

### （3）XML解析

1）XML： eXtensible Markup  Language  可扩展标记语言

xml是html的一个变种。xml专门用来承载(盛放)数据，事以标签的方式来放数据的

2）xml和html的区别

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) xml文件的后缀是.xml

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) html中的标签和属性，都是被人预定义好的，可以直接使用，用而xml中的标签和属性，需要我们自己定义

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) xml的标签名称，严格区分大小写 <str></str> 和<Str></Str>是两组标签

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) xml中只有双标签，没有单标签

  编写xml文件，创建后缀以.xml结尾的文件  第一个行做声明<?xml   version="1.0"   encoding="utf-8"?>  有且只有一个根标签  使用var r=xhr.responseXML获取document对象  然后使用dom操作 r.getElementsByTagName("uname")  获取标签是<uname></uname>的所有对象放入一个数组  再进行数组操作就可以了  

## 5、ajax项目

### （1）创建项目结构

1)     routes文件夹中，创建pro.js路由

2)     在app.js 路由挂载

3)     创建静态资源文件夹pro

4)     在app.js中托管静态资源文件夹

### （2）使用restful统一接口风格

1)     登录接口

get  /pro/v1/login/:uname&:uwpd 响应 1为登录成功  0为登录失败

 

2)     查询所有用户信息

get  /pro/v1/list 响应json

 

3)     根据uid删除用户 

delete /pro/v1/del/:uid 响应 1为删除成功，0为删除失败

 

4)     根据uid查询用户信息 

get /pro/v1/search/:uid 响应json

 

5)     根据uid修改用户信息

put /pro/v1/update 响应 1为成功，0为修改失败

 

6)     根据uname 查询用户信息 

get /pro/v1/select/:uname 响应1为查询成功，0为没有此用户

 

7)     注册  post  /pro/v1/reg  响应1位注册成功，0为注册失败

### （3）整合前台文件



 

## 三、css3的概述

Cascading Style Sheets层叠样式表，级联样式表，简称样式表

css的作用修饰html元素，让页面更好看

1）html和css的关系

l html：负责网页的搭建，内容的展示

l css：负责修饰，美化页面

2）CSS和html属性的使用原则

l css：提升了代码重用性，提升了可维护性(css并没有把可维护性提升到极致)

l W3C建议我们尽量使用css的方式，去取代HTML属性

## 1、CSS的语法规范

### （1）css的使用方式

| 行内样式  （内联式） | 任意元素都有style属性，在元素的style属性中，定义样式，如果有多个样式用 **;** 来分隔  <any style=”样式声明1；样式声明2；”></any>  特点：1）不能重用  2）内联式优先级最高  any：代表任意元素  注：项目中，基本不使用行内样式，因为行内样式不能重用，在学习和测试时候使用 |
| -------------------- | ------------------------------------------------------------ |
| 内部样式             | 在head标签中，定义<style></style>，在style标签中，定义样式  在style标签中，写选择器{样式声明1；样式声明2...........}  特点：1）在当前页面内可以反复重用，重用有局限性  注：项目中，使用较少，多在学习和测试的时候使用 |
| 外部样式             | 在外部单独创建一个css文件，*.css，然后在html中的head中，使用 link引入*.css  <link rel="stylesheet"  href="1.css">  特点：1）可以实现在多个页面代码重用了  注：项目中，基本都使用外部样式 |

### （2）css的特性

| 继承性     | a)       大部分的css效果，是可以直接被子元素继承  b)      必须是子元素继承父元素（祖先）的样式  c)       a标签的字体颜色，是不继承的 |
| ---------- | ------------------------------------------------------------ |
| 层叠性     | a)       可以为一个样式设置多个样式规则  b)      规则中，属性不冲突(没有重复)，都可以作用到当前元素上 |
| 优先级     | 如果多个样式规则作用到一个元素上时，样式属性发生了冲突，根据优先级来应用  默认优先级：内联样式>内部样式>外部样式---->就近原则（谁离目标元素近，使用谁）  最低  浏览器默认样式 |
| 调整优先级 | 在值和 **;** 之间添加  !important，可以把优先级提升到最高，比内联都高  同时，内联样式不允许使用!important; |

注：html,css,js属于解释执行，即编译一行执行一行；代码是从上往下执行，css中谁离目标元素近使用谁。 浏览器按F12，css样式是按照优先级高低排序，优先级最高的会被执行。

## 2、基础选择器（重点）

选择器{样式声明}；选择器是一个条件，符合这个条件的元素，会应用后面的样式

### （1）选择器类型

| 通用选择器                                                   | 语法：*{样式声明}   页面中所有元素都应用此样式，效率低，不建议使用  *{margin:0;padding:0}所有元素的内外边距清空，做css reset;  浏览器对同一篇代码的解析有可能不同，我们写代码的时候，需要把一些样式进行统一，或者清除。这个行为就叫做css reset. 项目中唯一使用通用选择器方式： |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 元素选择器  (标签选择器)                                     | 语法：标签名称{样式声明}    一般用于定义页面中某种元素的公共样式 |
| id选择器                                                     | 语法：#id值{样式声明}  对某一个ID生效的选择器，id的特点，页面中没有重复ID，所有id选择器，是针对一个元素的专属定制。 |
| 类选择器                                                     | 语法：**.**类名{样式声明}  把一类样式，封装成一个小模块，起一个类名，使用class调用类名  类名的规范：只能包含- 和_ , 不能以数字开头，做到见名知意 |
| 多类选择器  **.**类名1{样式声明}  **.**类名2{样式声明}  <any class=”类名1 类名2 .....”> |                                                              |
| 分类选择器：1）元素选择器**.**类选择器{样式声明}  引用了这个类名的这个元素，可以应用此样式  2.）**.**类选择器**.**类选择器{样式声明}  同时引用了这两个类名的元素，可以使用此样式 |                                                              |
| 群组选择器                                                   | 语法：选择器1**，**选择器2**，**选择器3**，**.....**{**样式声明**}**  将多个选择器，放在一起，使用 **,** 分隔，定义公共样式 |
| 后代选择器                                                   | 语法：选择器1 选择器2 选择器3......{样式声明}  ex：ul li a{color: red;}  通过元素的后代关系，来匹配元素  后代，一级或者多于一级的嵌套 |
| 子代选择器                                                   | 语法：选择器1**>**选择器2**>**选择器3**{**样式声明**}**  根据元素的父子级关系，匹配元素  子代：一级嵌套  注意：子代选择器和后代选择器是可以混合使用 |
| 伪类选择器                                                   | 语法：选择器:link{样式声明}        /* 链接未访问时的状态 */  选择器:visited{样式声明}     /*  链接已访问的状态 */  选择器:hover{样式声明}     /*  鼠标悬停时候的状态 */  选择器:active{样式声明}     /*  元素被激活时的状态 */  选择器.focus{样式声明}     /*  元素获取焦点时的状态 */  注：当4个伪类同时作用到一个元素上，需要有特定的编写顺序  爱恨原则：love &  hate :link :visited :hover   :active |

### （2）选择器权值

1） 权值：表示当前选择器的重要程度，权值越大，优先级越高

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) !important   >1000

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 内联样式    1000

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) id选择器    100

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 类/伪类     10

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 元素选择器    1

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) *通用选择器   0

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 继承的样式    无

2）权值的特点：

\1.     当一个选择器，包含多个选择器时，需要将所有的选择器权值进行相加，结果大的优先显示

\2.     权值相同，使用就近原则

\3.     群组选择器的权值，单独计算，不能相加

\4.     如果样式后，添加了!important的，直接获得最高优先级，但是内联样式不能加!important

\5.     选择器权值的计算，不会超过本身权值的最大数量级（100个1加一起，也不会大于10）

## 3、尺寸和边框

### （1）尺寸

1）页面中元素的宽度和高度

| 宽度width  取值：以px为单位的数字     rem为单位的数字     %，父元素宽度百分比  max/min-width/height 限制元素最大/最小的宽度/高度（注意给img设置最大宽度的情况） | 高度height  取值：以px为单位的数字     rem为单位的数字     % 父元素没有定义高度，就失效       父元素有定义高度，就是这个高度的百分比 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

尺寸单位

| 绝度值单位  1.px像素  2.in 英寸  1in=2.54cm  3.pt 磅值  1pt=1/72in 修饰字体大小  4.cm  5.mm | 相对单位  % 一般都是父元素的某一个属性的百分比  em以父元素设置的值为一个基本单位，  1.5em就是1.5个基本单位  rem以html标签设置的值为一个基本单位    如果html没有设置值，1rem默认为16px |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

2）页面中允许设置尺寸的元素

| 块级元素        | 可以设置宽高 | 默认宽：父元素宽度100%  默认高：靠内容撑开，没有内容，高度就为0； |
| --------------- | ------------ | ------------------------------------------------------------ |
| 行内元素        | 设置宽高无效 | 默认宽/高，都是被内容撑开，没有内容，就没有宽高              |
| 行内块（input） | 可以设置宽高 | 浏览器会自动给宽/高但是，不同浏览器给的宽高不一样。input是不同浏览器差异最大的元素，需要写css reset |

特殊情况：自带宽高属性的元素，可以设置样式宽高，<img> <table></table>

3）溢出处理

①当内容较大，元素区域较小，就会发生溢出效果，默认情况，都是纵向溢出！

| overflow:visible | 溢出部分可见（默认值）                       |
| ---------------- | -------------------------------------------- |
| overflow:hidden  | 溢出部分不可见                               |
| overflow:scroll  | 添加滚动条                                   |
| overflow:auto    | 溢出的方向，有滚动条，不溢出的方向没有滚动条 |
| overflow-x       | 单独设置x轴滚动条                            |
| overflow-y       | 单独设置y轴滚动条                            |

②默认是垂直溢出，如何写成横向溢出？

要在比较宽的容器上，添加一个窄的父元素，给这个父元素写溢出属性，溢出的底层很特殊很复杂，可以解决很多css中的特殊问题，但是，最佳方案都不是用溢出解决。

附加知识点---合法的颜色值

  1.英文单词(red ,green,yellow.......)  2.#rrggbb 6个16进制的值 #000000 黑色 #ffffff 白色  3.#aabbcc--->#abc   #069--->#006699   #36d--->#3366dd   #f00 #0f0 #00f #ff0 #0ff  #f0f #ddd #000 #fff #999   #eee  4.十进制 rgb(r,g,b) 每一个数的取值范围 0~255  0~ff  5.rgba(r,g,b,a) alpha透明度0~1 1为不透明，0为全透明  不常用的颜色取值  6.rgb(r%,g%,b%) 0~100%  0~255的百分比  7.hsl(h,s,l) 色段，饱和度，亮度   

### （2）边框

1）边框的简写方式

| border:width style color;                                    | width 边框的宽度  style 边框的样式；solid / dotted / dashed / double----  实线/点状虚线/短线虚线/双实线  color 边框的颜色   注：  第三个参数除了color，还可以取transparent（全透明）作用等同于rgb(,,,0)）  border:0;  清除4个方向的边框  border-top/right/bottom/left:width style color; 只设置1条边的3个属性  border-top/right/bottom/left:0; 单独清除某一个方向的边框  border-top/right/bottom/left-width/style/color  单边单属性  border: style; 最简方式 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| border-radius  同时设置4个角，取值是px（取值50%就是圆）  border-top- left/right-radius:    border-bottom- right/left-radius单角定义 |                                                              |

2）边框阴影

| box-shadow | box-shadow:h-shadow v-shadow   blur spread color   inset;  h-shadow 阴影水平偏移距离  v-shadow 阴影垂直偏移距离  blur    阴影模糊距离  spread   阴影大小  color   阴影颜色  inset   把外部阴影变为内部阴影  box-shadow:h-shadow  v-shadow; 最简方式 |
| ---------- | ------------------------------------------------------------ |
|            |                                                              |

3）绘制在边框外边的一圈线，不占页面的空间

| outline:width style color; | outline:0;清除轮廓  outline-width:20px;  outline-style:dotted;  outline-color:#f00; |
| -------------------------- | ------------------------------------------------------------ |
|                            |                                                              |

## 4、框模型--盒子模型（重点）

所有元素都有框--------所有元素在页面上都占据空间

框模型—盒子模型：元素在页面上实际占地空间的计算公式

|      | 元素实际占地宽度：  左外边距+左边框+左内边距+内容区域宽度+右内边距+右边框+右外边距  元素实际占地高度：  上外边距+上边框+上内边距+内容区域高度+下内边距+下边框+下外边距  外边距margin：外边框外的距离(元素与元素之间的距离)  内边距padding：边框到内容区域之间的距离 |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

### （1）外边距margin

改变元素外边距，元素有位移效果，把其他带框的元素挤开

margin没有颜色，优先满足上外边距和左外边距的值保持正确

| margin | margin:v1;同时设置4个方向的外边距  取值：px  以px为单位的数字  %  以%为单位是父元素宽度的百分比，跟父元素高度没关系  auto  让块级元素水平居中（块级元素定义了宽度），对上下外边距无效  margin-top/right/bottom/left 单独设置某一个方向的外边距  简写方式  margin:v1; 设置4个方向外边距  margin:v1 v2; v1:上下  v2:左右   margin:0  auto; margin:100px auto;  margin:v1 v2 v3; v1:上  v2:左右  v3:下  margin:100px  auto 100px;  margin:v1 v2 v3  v4; 上右下左 |
| ------ | ------------------------------------------------------------ |
|        |                                                              |

### （2）外边距的特殊效果

1）外边距合并

两个垂直的外边距相遇时，会发生外边距的合并，最后的值，以大的为准

解决方案：单独设置一个外边距；在页面设计的直接规避

2）可以设置外边距的元素

| 块级元素 | 可以设置宽高 | 默认宽：父元素宽度100%  默认高：靠内容撑开，没有内容，高度就为0；  4个方向外边距都生效 |
| -------- | ------------ | ------------------------------------------------------------ |
| 行内元素 | 设置宽高无效 | 默认宽/高，都是被内容撑开，没有内容，就没有宽高  上下外边距无效，只有左右外边距生效 |
| 行内块   | 可以设置宽高 | 浏览器会自动给宽/高，但是不同浏览器给的宽高不一样。  4个方向外边距都生效，设置一个行内块的上外边距，会连同同一行其他行内元素和行内块元素一起移动。 |

3）自带外边距的元素

body,button,dd,dl,dt,fieldset,form,h1,h2,h3,h4,h5,h6,hr,input,legend,li,ol,p,pre,td,textarea,th,ul

4）外边距溢出

在特殊的情况下，为子元素设置上外边距，会作用到父元素上！！！

特殊情况：a）父元素没有上边框

b）子元素内容区域的上边沿和父元素内容区域的上边沿重合

解决方案：a） 给父元素添加上边框 弊端，增加了父元素的实际占地高度

a)     给父元素添加上内边距 弊端，增加了父元素的实际占地高度

b)     在第一个兄弟位置，添加<br>，弊端，内部多了一行

c)     父元素添加overflow：auto，但是，如果想要溢出显示，就不行了

d)     在第一个元素的位置处，添加一个空的<table></table>这样浏览器就认为上边沿分开了

### （3）内边距padding

边框到内容区域之间的距离，改变内边距，会改变整个元素的占地大小，但内容区域大小没变化

内边距的颜色，和元素背景色相同

| padding | padding:v1; 同时设置4个方向的内边距  取值：px .以px为单位的数字          %   不管上右下左，都是以父元素的宽度为基准           padding没有auto值  padding-top/right/bottom/left:  padding:v1; 设置4个方向  padding:v1 v2;   v1:上下  v2：左右  padding:v1 v2 v3;   v1:上   v2:左右  v3:下  padding:v1 v2 v3 v4; 上右下左 |
| ------- | ------------------------------------------------------------ |
|         |                                                              |

### （4）magin和padding的使用场合

1）margin的使用场合

a)     块级元素本身需要相对父元素水平居中 margin:auto; margin:0 auto;

b)     元素之间，有距离，可以用margin

c)     元素的位置微调

2）padding的使用场合

a)     元素之间，有距离，有的时候使用padding

b)     把元素撑开

### （5）改变框模型的计算方式

1）box-sizing:content-box; 默认框模型，计算方式

元素实际占地宽度为：

左外边距+左边框+左内边距+内容区域宽度+右内边距+右边框+右外边距

margin-left+border-left+padding-left+**width**+padding-right+border-right+margin-right

 此时设置的宽，我们设置的宽，也就是内容区域的宽 

2）**box-sizing:border-box;** 改变盒子框模型的计算方式后

此时设置的width和height等于 **边框+****内边距+****内容区域的大小**

**整个元素实际的宽度：左外边距+****设置的width+****右外边距**

当项目中的尺寸，都是%时，建议使用border-box;

同时，当背景色没有冲突时，可以使用padding做元素之间的空隙

​     

​        width: 200px;    height: 200px;    margin: 20px;    border: 2px solid #00f;    padding: 20px;    没改变框模型计算方式前；    元素实际占地宽度：20*2+2*2+20*2+200=284        

 



​     

​        width: 200px;height: 200px;    margin: 20px;    border: 2px solid #00f;    padding: 20px;    **box-sizing:    border-box;/**/改变框模型计算方式后    元素实际占地宽度：20*2+200=240    我们设置的宽度**width=****内容区域****+****内边距****+****边框**        

 



 

 

## 5、背景

### （1）背景颜色和图片

| 背景颜色                                                     | background-color:#faa;                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 背景图片                                                     | background-image:url(01.png);  url（）中，单引号，双引号，不加引号都正确 |
| background-repeat 背景图片的平铺 （默认缺省值）  no-repeat  / repeat-x / repeat-y /:不平铺/X轴平铺/Y轴平铺 |                                                              |
| background-position: 背景图片的定位：  a)      以px为单位的数字  b)      %  c)      关键字 x:left/center/right y:top/center/bottom  取一个值， 这个值实在控制x轴的位置，y轴默认垂直居中  取两个值，第一个值，设置的x轴，第二个值设置y轴 |                                                              |
| background-size:  背景图片的尺寸  a)      以px为单位的数字  b)      %  一个值，同时设置x轴和y轴  两个值  分别设置x轴和y轴  c)      cover  填充，让图片充满整个容器，保证容器全部被  填充上，图片有可能显示不全  d)      contain  包含，让容器包含一张完整的图片，保证图片是完全显示的，可能会出现空白区域 |                                                              |
| background-attachment: 背景图片的固定  a)      scroll 默认缺省值，背景图会随着窗口的滚动条而滚动  b)      fixed 背景固定在body的某一个位置，不随页面滚动条滚动          但是，只会在原容器中才能显示  会影响background-position的效果，相对于body去定位 |                                                              |
| 背景图片的  简写方式                                         | background:color url()   repeat attachment position;  注意，简写方式中，没有background-size  最简方式：  background:color;  background:image;  开发的初学者，不要用简写方式去重写样式，会把之前所有样式都清除 |

## 6、渐变

渐变：多种颜色，平缓变化 一种显示效果

影响渐变的因素：色标：一种颜色，和这种颜色的出现位置，一个渐变，至少2个色标

### （1）渐变的分类

| 线性渐变 | 以直线的方式来填充渐变色  background-image:linear-gradient(方向,色标1,色标2.......);  方向：1.写终点to right/top/left/bottom  2.角度 0deg/90deg/180deg/270deg/-90deg  ---> to top/ right / bottom / to left  色标： 颜色+位置  位置：1.% 0%~~100%  2.px  如果不写位置，所有颜色平均分配 |
| -------- | ------------------------------------------------------------ |
| 径向渐变 | 以圆形的方式来填充渐变色  background-image: radial-gradient(半径 at 圆心x 圆心y,色标1,色标2,..........);  半径，以px单位的数字  圆心，1.关键字 x:left/center/right y:top/center/bottom     2.以px为单位的数字     3.%  色标，1.位置使用%，是半径的百分比     2.位置使用px，使用px跟半径没关系了 |
| 重复渐变 | 将线性渐变，径向渐变，反复执行几次  1.重复的线性渐变  background-image: repeating-linear-gradient(方向,色标1,色标2......)2.重复的径向渐变  background-image: repeating-radial-gradient(半径 at 圆心x 圆心y,色标1,色标2,..) |

### （2）浏览器兼容问题

低版本浏览器不支持渐变，我们使用css hack来让低版本浏览器可以实现渐变效果，写css兼容的行为，叫做写css hack

在代码中添加，代表内核的前缀,使用不同浏览器打开，会自动执行对应内核的代码

-webkit- chrome/safari

-moz-  firefox

-o-    opera

-ms-   IE

如果线性渐变，添加了前缀做兼容，方向一定写起点(不能有to)，不能写终点

​       不添加前缀，方向要加to，写终点

如果想做兼容，至少写4套

background: -moz-linear-gradient(top, #27b1f6 0%, #0aa1ed 100%);

background: -webkit-linear-gradient(top, #27b1f6 0%, #0aa1ed 100%);

background: -o-linear-gradient(top, #27b1f6 0%, #0aa1ed 100%);

background: -ms-linear-gradient(top, #27b1f6 0%, #0aa1ed 100%);

## 7、文本样式（重点）

### （1）字体属性

| 字体的属性       | font-size: px/pt/rem/em                                      |
| ---------------- | ------------------------------------------------------------ |
| 字体系列         | font-family  font-family:chiller,”curlz  mt”,幼圆,微软雅黑,……  注：如果字体中有空格需要加双引号。 |
| 字体的粗细       | font-weight: normal/bold/bolder/lighter  300—lighter 400—normal  600—bold  700--bolder |
| 字体样式         | font-style:normal/italic;                                    |
| 小型大写字母     | font-variant:small-caps;                                     |
| 字体属性简写方式 | font：style variant weight size family;  最简方式font:size family; |
| 字体颜色         | color                                                        |

### （2）文本属性

| 文本的水平对齐方式 | text-align: left/  center / right / justify两端对齐  text-align:center;  让元素内部的，文本/行内元素/行内块，水平居中对齐  不会让后代块级元素居中对齐，但是后代块级会继承  text-align属性，即后代块级里的元素会居中对齐   想让块级元素水平居中对齐，只能使用margin:0 auto; |
| ------------------ | ------------------------------------------------------------ |
| 文本的垂直对齐方式 | line-height:  行高的特点，如果行高大于文本字号，那么文本会默认在行高的范围内，垂直居中，通常会把行高设置为容器高度，让文本在容器垂直居中显示，但是，多行文本不建议使用。  行高的取值：1.以px为单位的数字        2.不带单位的数字，行高是字号大小的倍数 |
| 文本线条的修饰     | text-decoration:overline上划线/underline 下划线/line-through删除线/none去掉所有线条修饰    a标签去掉下划线需要单独设置 |
| 首行缩进           | text-indent:                                                 |
| 文本阴影           | text-shadow:h-shadow/v-shadow/blur/color;    水平偏移量/垂直偏移量/模糊程度/颜色 |

## 8、表格样式

### （1）表格的常用样式

1）table的样式，之前学习的属性，基本都可以使用

但是，设置table的边框，只会设置最外层边框

2）td/th的样式，尺寸，边框，背景，文本，内边距，都有效，外边距无效

vertical-align:top/middle/bottom: 设置文本垂直对齐方式

3）table是一种特殊的显示方式

同一行中，所有列的高度，以最高的为准

不同行中，相同列的宽度，以最宽的为准

table在浏览器的渲染方式，先把所有内容读取到内存中，再一次性渲染。效率低

### （2）表格的特有属性

| 边框合并           | border-collapse:  1.separate 默认值，边框分离状态  2.collapse 边框合并 |
| ------------------ | ------------------------------------------------------------ |
| 边框的边距         | td不能设置margin,所以使用边框边距来设置  border-spacing:20px  前提，边框是分离状态的时候才有效border-collapse: separate |
| 标题的位置         | caption-side:  默认值 top   标题在上面      bottom   标题在下面 |
| 设置表格的显示规则 | table-layout  取值 1.默认值，自动布局 auto;      2.固定布局 fixed |

### （3）设置表格显示规则

| table-layout:auto；默认值 自动布局表格        fixed; 固定布局的表格 |                                |
| ------------------------------------------------------------ | ------------------------------ |
| 自动布局表格                                                 | 固定布局表格                   |
| 单元格的大小会自动适应内容                                   | 单元格大小，严格遵循设置的尺寸 |
| 表格复杂时，表格的加载速度较慢                               | 任何情况下，都会加速表格加载   |
| 自动布局比较灵活                                             | 不够灵活                       |
| 适用于不确定每列大小，并且不复杂的表格                       | 适用于确定每列大小的表格       |

## 9、定位（重点）

控制元素在页面中的位置，分为

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 普通流定

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 浮动定位

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 相对定位

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 绝对定位

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 固定定位

### （1）普通流定位

普通流定位又称默认文档流

特点：

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 每个元素在页面上都有自己的空间，相互之间不能堆叠

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 每个元素默认是从父元素的左上角开始显示

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 块级元素独立成行，按照从上往下的顺序排列

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 行内元素和行内块，共用一行，一行显示不下，换行显示，从左往右排列

### （2）浮动定位

浮动的目的是让块级元素横向显示。

1）语法：float: none/left/right

2）特点：

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 元素一旦浮动，脱离文档流后：

a)     不占据页面空间

b)     后续元素会上前补位

c)     元素不设置宽度，宽度靠内容撑开

d)     变为块级元素

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 元素浮动之后，浮动元素占位问题：

a)     浮动元素会靠在父元素的最左边/最右边

b)     浮动元素会在浮动方向占据位置，后浮动的元素排在已浮动的元素的后面，横向显示不下，会自动换行，换行的浮动元素，不能去占据已经被占的位置显示

c)     文本，行内，行内块，table是不会被浮动元素压在下面的，而且巧妙的避开，环绕着浮动元素显示

3）清除浮动：清除浮动元素带来的影响，后续没有设置浮动元素不会上前补位。浮动元素重新在页面上占据空间。clear:left/right/both;清除左右和所有浮动的影响

4）高度坍塌：块级元素不设置高的话，它的高度由内容决定，但它内部元素都设置浮动的话，就会脱离文档流，此块级元素就没有内容撑开，也就没有高度了。

解决方案：a）给父元素设置高度，弊端，不是什么时候都能得到父元素的合理高度

b）父元素也浮动，弊端，会影响其他元素的页面效果

c）overflow:auto; 弊端，没办法显示溢出部分了；

​          d）在父元素最后添加一个空的块级元素，这个块级元素设置clear:both

### （3）相对定位、绝对定位、固定定位

1）定位的属性

| 语法和属性 | position:static /relative /absolute  /fixed;  默认文档流//相对定位//绝对定位//固定定位  特性：  1）当一个元素，被设置了position，并且取值为relative、absolute、fixed其中一种时，我们称这个元素叫做已定位元素  2）已定位元素，会解锁4个偏移属性left/right/top/bottom  3）同时定义top/bottom，听top    同时定义left/right   听left |
| ---------- | ------------------------------------------------------------ |
| 相对定位   | position：relative；配合偏移量实现位置移动  1）相对定位是不脱离文档流  2）相对定位参照物,相对自己原来的位置做偏移  3）如果相对定位元素，不写偏移属性，效果和没写定位一样  使用场合：  1）类似于margin，做位置微调  2）.相对定位，一般作为绝对定位元素的祖先级已定位元素，使用！！！！ |
| 绝对定位   | position:absolute;  1）脱离文档流（4件事）  2）绝对定位是相对谁定位的  ![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif)  相对body定位,没有已定位的祖先元素  ![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif)  相对于”最近的”，“已定位的”，“祖先级”元素，左上角去定位  3）已定位元素relative、absolute、fixed        哪种已定位元素，最适合，当做absolute的已定位祖先元素        relative不写偏移属性，对周围布局没有任何影响  使用场合  1）需要调整元素位置  2）还会与其他元素发生堆叠现象 |
| 固定定位   | position:fixed；配合偏移量使用  永远是相对body左上角偏移，脱离文档流 |

2）堆叠顺序

| 默认的堆叠顺序 | 后写的元素（html的编写顺序），堆叠顺序高，永远大于0，小于1   |
| -------------- | ------------------------------------------------------------ |
| 改变堆叠顺序   | z-index: 无单位的整数  注：  float的二楼和index不是一个体系，不能比较  float的二楼，和定位的堆叠，不是一个体系，不能比较  只有已定位元素才支持z-index  堆叠顺序，对父子级关系无效，儿子永远在爹上面显示 |

## 10、显示

### （1）设置显示方式

| 显示方式     | display:inline/ block / inline-block /  table / none;  设置元素在页面上的表现形式(行内，行内块，块级，table......)  none元素隐藏，不占据页面空间的隐藏，none是隐藏，非none就是显示 |
| ------------ | ------------------------------------------------------------ |
| 显示效果     | visibility:visible/ hidden; 可见的/不可见，隐藏  面试题：visibility:hidden和display:none的区别  a)       visibility:hidden 隐藏，但是页面占据空间  b)      display:none   不占空间的隐藏 |
| 透明度       | opacity: 0~1；  1不透明  0全透明  面试题：opacity 和  rgba(0,0,0,0)==transparent的区别？？？  a)       opacity会让元素及元素内部(后代元素)所有与颜色相关的，都变透明  b)      rgba只会让当前颜色透明 |
| 垂直对齐方式 | vertical-align/  top/middle/bottom/baseline:  1）表格，设置表格中文本的垂直对齐方式  取值,默认值middle  top/middle/bottom  2）input,设置input前后的文本,行内,行内块,与这个input的垂直对齐方式  取值,默认值middle top/middle/bottom  3）img,设置img前后的文本,行内,行内块与这个img的从垂直对齐方式  取值，默认值baseline（基线） |
| 光标         | cursor：default /pointer /text /wait/ help/ crosshair   箭头/小手/文本/输入/等到加载/帮助/十字 |
| 列表项       | list-style-type:disc/circle/square/none  设置列表项的样式  list-style-image:url();  设置列表项的样式为图片（需要放小图）  list-style-position:outside/inside  设置标识项在li外部/内部（默认在外部）  简写方式：list-style:type url position;  list-style:none; 去掉标识项（项目中使用最多的方式）  注：ul默认自带上下外边距 **16px**，左内边距 **40px**  什么时候用ul布局？  有多个相似样式单独小模块，使用ul |

## 四、CSS3核心

## 1、复杂选择器

### （1）兄弟选择器

兄弟元素：具备同一个父元素的平级元素之间，称为兄弟元素

兄弟选择器，只能通过哥哥找弟弟，往后找，不能往前找！！

| 相邻兄弟选择器 | 选择器1+选择器2{}  紧紧挨着选择器1的符合选择器2的兄弟        |
| -------------- | ------------------------------------------------------------ |
| 通用兄弟选择器 | 选择器1~选择器2{}  选择器1后面，所有符合选择器2的兄弟        |
| 使用场合       | 经常用于，一组元素，第一个元素不要，后面元素都匹配的样式编写 |

### （2）属性选择器

1）属性选择器不是为了写样式，而是为了dom快速找到对象

| [attr]{}                                  | 匹配页面中，具有attr属性的元素                  |
| ----------------------------------------- | ----------------------------------------------- |
| [attr1][attr2]...{}                       | 匹配页面中，具有attr1,attr2...的元素            |
| elem[attr]{}                              | 匹配页面中，具有attr属性的elem元素              |
| elem[attr1][attr2]{}                      | 匹配页面中，具有attr1，attr2属性的elem元素      |
| [attr=value]{}                            | 匹配页面中，具有attr且值为value的元素           |
| [attr1=value1] [attr2=value2]....  {}     | 匹配页面中，具有attr1，2值且值为value1，2的元素 |
| elem[attr1=value1] [attr2=value2]......{} |                                                 |

2）使用属性选择器进行模糊值查询

| [attr^=value]{} | 匹配attr的值，以value开头的元素           |
| --------------- | ----------------------------------------- |
| [attr$=value]{} | 匹配attr的值，以value结尾的元素           |
| [attr*=value]{} | 匹配attr的值，含有value的元素             |
| [attr~=value]{} | 匹配attr的值，含有value这个独立单词的元素 |

3）下阶段知识点

  html的属性都有：id  class style title align width height href src tager.......  html预定义属性，自定义的属性支持属性选择器  dom可以使用选择器找到元素  

### （3）伪类选择器

es6规定，伪类选择器要用双冒号 :: 开头，但是es6之前就定义好的伪类，还是用单冒号 : 

比如之前学过的伪类选择器就事使用单冒号: ，:link :visited  :hover  :active :focus

| 目标伪类选择器 | selector:target{}  被激活的锚点，会匹配这个伪类的样式  匹配被锚点激活的selector元素 |
| -------------- | ------------------------------------------------------------ |
| 结构伪类选择器 | selector:first-child{}   匹配的是属于其父元素的第一个子元素，     这个子元素还需要符合selector  selector:last-child{}   匹配的是属于其父元素的最后一个子元素，     这个子元素还需要符合selector  selector:nth-child(n){}   n是几个，从1开始 |
| 否定伪类选择器 | :not(selector){}  符合selector的元素，都不要，匹配不符合selector的元素 |
| 空元素         | :empty{}  匹配内部没有任何元素的标签  没有元素：不能有后代元素，也不能有任何文本（包括空格和回车） |
| 独生子女       | :only-child  匹配属于其父元素的唯一子元素  只计算元素，文本/回车/空格不计算在内 |

### （4）伪元素选择器

1）匹配部分内容样式

| 匹配元素第一个字符 | :first-letter 或者 ::first-letter                            |
| ------------------ | ------------------------------------------------------------ |
| 匹配元素第一行文本 | :first-line或::first-line 如果第一行与首字符样式冲突，以首字符为准 |
| 匹配用户选中的文本 | ::selection 只能用双冒号，对首字符无效，只能设置背景色和字体颜色 |

2）使用伪元素选择器给html添加元素（内容生成）

| :before或者::before | 在当前元素内容区域的最开始，添加一个假的元素  新添加的元素默认为行内元素,但是可以使用display修改  使用content添加内容（文本或者url(img)）  可以解决外边距溢出！！！  在父元素上添加:before{content:””;display:table;} |
| ------------------- | ------------------------------------------------------------ |
| :after或者::after   | 在当前元素内容区域的最后面，添加一个假的元素  新添加的元素默认为行内元素,但是可以使用display修改  使用content添加内容（文本或者url(img)）  解决高度坍塌！！！  在父元素上添加::after{  content:””,display:block;clear:both} |

## 2、弹性布局（超重点）

弹性布局：主要解决某个元素中，子元素的布局方式。为布局提供非常大的灵活性。

### （1）弹性布局的相关概念

1)     容器：要弹性布局的子元素们的父元素，也就是定义了display:flex;的元素

（容器本身不是弹性布局）

2)     项目：要弹性布局的元素，也就是定义了display:flex元素的子元素

（仅限于子元素）

3)     主轴：项目们排列方向的一根轴（4条）

项目在主轴排列顺序，称为主轴起点和终点。

如果项目横向排列，主轴就是x轴

如果项目纵向排列，主轴就是y轴

4)     交叉轴：永远与主轴方向垂直的一根轴（2条）

   项目们在交叉轴上的对齐方式，称为交叉轴的起点和终点

### （2）弹性布局语法

display：flex/inline-flex； 将块级元素设置为容器/将行内元素设置为容器

注：当一个元素变为容器后，这个容器的text-align，vertical-align失效

当元素变为项目，项目的float、clear失效

### （3）容器的样式属性

| 设置主轴方向               | flex-direction:  a)       row 主轴是x轴，主轴起点在左侧（默认值）  b)      row-reverse 主轴是x轴，主轴起点在右侧  c)       column 主轴是y轴，主轴起点在顶部  d)      column-reverse 主轴是y轴，主轴起点在底部 |
| -------------------------- | ------------------------------------------------------------ |
| 设置项目换行               | flex-wrap:  a)       nowrap 不换行，压缩（默认值）  b)      wrap 换行,项目在交叉轴的起点，换行往终点方向折行  c)       wrap-reverse  换行反转，项目在交叉轴终点，换行往起点方向折行 |
|                            | 上面两个属性的缩写：flex-flow: direction   wrap;             |
| 设置项目在主轴上的对齐方式 | justify-content:  a)       flex-start/  center / flex-end   主轴的起点对齐（默认值）/主轴的中间/主轴的终点  b)      space-between  / space-around  两端对齐 / 两端有空白，左右间距都相同 |
| 设置项目在交叉轴的对齐方式 | align-items:   a)       flex-start  / flex-end / center   b)      baseline   按照所有项目的文本基线，统一对齐  c)       stretch  前提是项目不写高度，所有项目充满交叉轴所有空间 |

### （4）项目的样式属性

只控制这个项目自己，不影响其他项目

| 设置项目在主轴上的排列顺序           | order: 无单位整数  默认值 0；，值越小，越靠近主轴的起点      |
| ------------------------------------ | ------------------------------------------------------------ |
| 单独设置一个项目在交叉轴上的对齐方式 | align-self  a)       flex-start  / flex-end / center 交叉轴起点 / 中间 / 终点    b)      baseline 所有项目内文本的基线，统一对齐  c)       stretch 前提是项目不能写高度，所有项目充满交叉轴所有空间  d)      auto 使用容器设置的align-items的值 |
| 项目缩小                             | flex-shrink  当主轴方向空间不足时，设置是否缩小，怎么缩小。  默认值：1，压缩； 0，不压缩  不足的空间按比例，在项目原有尺寸上减去对应比例  项目原始宽度-不足空间的比例宽度=项目实际大小 |
| 项目放大                             | flex-grow  当主轴方向上有剩余空间，设置是否放大，怎么放大。   默认值：0，不填充    取值规则：多出的空间，按照取值，分配给各个项目相加  分配宽度+项目原始宽度，就是变大之后的宽度 |
| 设置每个项目占主轴的空间             | flex-basis:  默认值 auto，按照项目设置的尺寸显示  取值：%容器主轴方向的百分比；  px     注：定义了flex-basis，优先级高，不听从之前设置的尺寸值了 |
| 以上3种属性的简写方式：              | flex:0 1 25%;  3个取值分别代表：flex-grow  flex-shrink   flex-basis |

## 3、CSS hack

2015年淘宝宣布不再兼容ie8以下的浏览器。2018年boot4宣布，不再兼容ie8以下的浏览器

用于不同的浏览器(低版本)对css的解析认知不同，会导致一份css在不同浏览器生成的效果不同。

需要开发人员对于不同的浏览器写不同的css

这个行为，就叫做写css hack.让我们兼容不同浏览器，正确显示页面

-webkit-

-o-

-ms-

-moz-

tmooc 拓展视频(上面数第三个)，有css hack所有讲解

## 4、转换（很重点）

改变元素在页面中的位置，大小，角度，以及形状，转化分为2D转换和3D转换。

2D转换，只在x轴和y轴上发生转换效果

3D转换，增加了z轴的转换效果

### （1）转换属性

  transform：转换函数  

### （2）2D转换 

4个转换函数

| 位移                               | transform:translate( )  改变元素在页面中的位置  a)      translateX(x)/translate(x) 设置元素在x轴上的位移距离 + → ，- ←  b)      translateY(y)  设置元素在y轴上的位移距离 +   ↓，- ↑  c)      translate(x,y)   同时设置X轴和Y轴的位移距离  **面试题：**如何让如何让一个宽高200px的div，无论浏览器如何缩放，这个div都在浏览器正中心显示 |                                                              |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 缩放                               | transform:scale( ) 改变元素的大小  a)       scaleX(x) 单独设置x轴的倍数  b)      scaleY(y) 单独设置y轴的倍数  c)       scale(x,y) 分别设置x轴和y轴  d)      scale(value)  同时设置x轴和y轴的倍数  参数问题：  value>1   放大； 0<value<1 缩小； -1<value<0 反转并缩小；value<-1 反转并放大 |                                                              |
| 旋转                               | transform: rotate(ndeg)   改变元素的角度  n:+ 顺时针  ， - 逆时针  transform-origin:x y;  设置旋转原点（默认是该元素的中心）    取值：x y 以px为单位的数字       x%  y%        关键字 x:left/center/right y:top/center/bottom    注：  旋转会带着元素的坐标轴一起旋转，旋转之后的位移方向，会发生变化。 |                                                              |
| 倾斜                               | 1）tranform:skew(ndeg)和skewX(ndeg)  让y轴向着x轴倾斜ndeg  +:逆时针，-：顺时针 | 2）tranform:skewY(ndeg)  让元素x轴向着y轴倾斜ndeg  +:顺时针，-：逆时针 |
| 3.同时设置x,y倾斜 skew(xdeg,ydeg); |                                                              |                                                              |

### （3）3D转换

页面中所有的3D转换都是通过模拟的

| 透视距离 | 模拟人的眼睛到3D转换元素之间的距离，距离不同，效果不同  perspective:透视距离，此属性要加载到3D转换元素的父元素上 |
| -------- | ------------------------------------------------------------ |
| 3D旋转   | transform:  a)       rotateX(xdeg)  以x轴为中心轴，旋转xdeg（烤羊腿，老式爆米花机）  b)      rotateY(ydeg)  以y轴为中心轴，旋转ydeg(旋转门，挂炉烤鸭，土耳其烤肉)  c)       rotateZ(zdeg)  以z轴为中心轴，旋转zdeg(风车，电风扇，印度飞饼，摩天轮)  d)      rotate3D(x,y,z,ndeg)      x,y,z  取值为不带单位的数字 ；0，代表不参与旋转         取值>0 就代表参与旋转，取值越大，在当前轴转的越快 |

## 5、过渡

让css的值，在一段时间内平缓的变化

### （1）语法和属性

| 设置参与过渡的属性 | transition-property:css属性1 css属性2 .........     取值：  1)      一个或多个css属性，多个属性用空格分开  2)      可以取值 all,代表所有支持过渡的属性，都参与过渡  支持过渡的属性有哪些  a)       颜色属性  b)      大多数取值为具体的数字的属性 px %  c)       阴影  d)      转换 |
| ------------------ | ------------------------------------------------------------ |
| 设置过渡的时长     | transition-duration: s/ms                                    |
| 过渡时间曲线函数   | transition-timing-fuction:  取值：  1)      贝塞尔曲线函数cubic-bezier(0, 0, 0, 0);  cubic-bezier(0.57, 0.05, 0.68, 0.19) à自由落体  2)      关键字  a)       ease  慢速开始，中间加速，减速结束（默认值）1  b)      linear 匀速  c)       ease-in 慢慢开始，一直缓慢加速  d)      ease-out 快速的开始，加速，减速结束  e)       ease-in-out  慢速开始，中间快速加速，减速结束 |
| 设置过渡前的延迟   | transition-delay: s/ms                                       |
| 过渡代码的编写位置 | 过渡代码写在原本样式中，过渡效果有去有回  过渡代码写在hover中，过渡效果有去无回 |
| 过渡的简写方式     | transition:property duration   timing-function delay;  最简方式：transition:duration; |

## 6、动画

动画：使元素师从一种样式逐渐变为另一种样式

其实就是过渡的升级版，把多个过渡放到一起的效果

### （1）动画的关键帧

关键帧：使用关键帧来控制动画每一个状态。一个动画中，至少2个关键帧。

1)     动画执行这一帧的时间点

2)     在这个时间点上的样式

### （2）动画的使用

| 定义动画  (使用关键帧) | @keyframes 动画名称{   关键帧1  0%{样式属性}   关键帧2  50%   ……     ……   关键帧n 100%{样式属性}  }  0%和100%可以用from和to替代 |
| ---------------------- | ------------------------------------------------------------ |
| 调用动画               | animation-name: 调用动画的名称  animation-duration: 动画的持续时间  animation-timing-function: 设置动画的时间曲线函数  animation-delay: 2s; |
| 播放次数               | animation-iteration-count: 体的数字 / infinite 无限          |
| 播放顺序               | animation-direction:   a)       normal 0%~~100%（默认值）   b)      reverse  100%~~0%   c)      alternate 轮流播放，奇数次正向，偶数次逆向 |
| 简写方式               | animation:name duration timing-function delay count direction;  最简方式：animation：name duration; |

其他属性

| 填充状态 | animation-fill-mode: 设置播放前后的的填充状态  a)       none 不填充.（默认值）  b)      backwards 动画在延迟时间内，保持在第一帧  c)       forwards  动画在结束后，停留在最后一帧  d)      both; backwards和forwards都兼顾 |
| -------- | ------------------------------------------------------------ |
| 播放状态 | animation-play-state:  running 播放 / paused 暂停            |

### （3）动画的兼容性

如果想要兼容低版本浏览器，需要在动画声明的时候，添加前缀

@-webkit-keyframes 动画名称{}

@-o-keyframes 动画名称{}

@-ms-keyframes 动画名称{}

@-moz-keyframes 动画名称{}

### （4）动画的第三方包使用

https://daneden.github.io/animate.css/ 下载animate.css文件。

在页面上引入这个css文件，然在样式中直接调用动画名称。

### （5）过渡和动画的区别

| 过渡                                   | 动画                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| 两个css值之间的变化  必须使用hover激活 | 两个或者两个以上css值的变化  可以使用hover激活(动画代码写hover)  可以加载激活(动画代码写原样式中) |

 

| 提升练习：       |                                                              |
| ---------------- | ------------------------------------------------------------ |
| 使用动画完成时钟 | 西游动画效果，需要自己自学steps的功能  https://blog.csdn.net/weixin_43500988/article/details/89300629 |
|                  |                                                              |

## 7、CSS的优化

1）CSS优化的目的：减少服务器的压力，提升用户体验。

2）CSS的优化原则：尽量减少http请求个数（缓存，精灵图）

将css和js代码，放到独立的文件中，在头部引入

3）CSS的代码优化：合并样式（能用简写方式，就不单独定义）

​         减少样式的重写（能重用就重用）

​          避免空的href和src

​          代码压缩

## 8、css rest

1）css rest：（样式重置）

由于不同浏览器给元素定义的默认样式不同，导致一份css有可能产生不同的效果。为了统一样式，在开发之前，把这些不同的默认样式，进行清除或统一。

注：

css reset没有严格要求，不同项目的css reset要求不同

css reset往往比较霸道，把一些有用的默认样式也清除了

2）normalize.css

是一种css reset的替代方案，在默认的html元素的样式上，提供跨浏览器的高度一致性，还修复了不同浏览器的bug。保护了有用的浏览器默认样式，而不是完全去掉他们

 

## 五、Bootstrap

中文官网：https://www.bootcss.com/，

 

## 1、响应式

响应式是css3 在2010提出的技术，boot做了简化，可以快速完成响应式开发。

Responsive web page 响应式网页/自适应网页

可以根据 浏览设备不同，而自动的改变布局，图片文字的效果，不影响用户体验

浏览设备，包括硬件(pc,pad,phone)，屏幕尺寸，横竖屏

### （1）响应式开发要求

要求：（针对初学者）

1)     布局，不能使用固定的元素宽度，尽量使用相对单位

所有布局，使用流式布局（默认文档流+浮动），尽量不写定位。

2)     文字和图片大小随着容器的大小而改变（使用相对单位）

3)     使用css3提供的媒体查询技术

在不同设备下，调用不同的样式，导致代码量几何性增加，非常复杂的页面不适合响应式）

### （2）测试响应式网页

1)     使用真实设备测试

优点：真实可靠 

缺点：成本高，测试任务量巨大

2)     使用第三方模拟软件测试（phonegap）

优点：不需要太多真实设备，测试方便 

缺点：测试效果有限，有待进一步验证

3)     使用chrome自带的模拟软件

优点:简单方便 

缺点:测试效果十分有限，一定要进一步验证

### （3）编写响应式布局

1）移动端适配（如果你写的页面不在移动端显示，可以不写）

  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,  user-scalable=0">  content="width=device-width, 视口宽度为设备宽度  initial-scale=1.0, 视口初始缩放，1倍---不缩放    maximum-scale=1.0,  视口最大缩放倍数 ,1倍---不缩放  user-scalable=0"  用户缩放视口的能力，0---不能缩放   最简方式编写视口  <meta name="viewport" content="width=device-width,  initial-scale=1">  

2）所有尺寸，文本的小大都尽量使用相对尺寸，不使用绝对值。（后期特别熟可以随便写）

3）流式布局(默认文档流+浮动)+弹性布局+媒体查询技术，完成响应式布局

4）媒体查询：Media Query css3 做响应式必备的技术

  Media：媒体--->设备（硬件设备，分辨率，刷新率，横屏竖屏）  硬件设备：  a)      screen（pc,pad,phone）  b)      TV （电视）  c)      print（打印机，微波炉屏幕，洗衣机屏幕）  分别率：行业内把屏幕宽度，分成5组    a)      xl 超大屏   屏幕>=1200px  b)      lg 大屏    992px<=屏幕<1200px  c)      md 中屏    768px<=屏幕<992px  d)      sm 小屏    576px<=屏幕<768px  e)      xs  超小屏   屏幕<576px    Media Query 媒体查询，可以自动根据当前浏览设备的不同(尺寸，方向，解析度)，有选择的执行一部分css样式，忽略其他css样式  @media 条件1 and 条件2 and 条件3{    选择器{}    选择器{}  }       @media screen and (min-width:576px) and  (max-width:767.99px) {                .content{                    background:#ffa;                    color:#000;                    font:36px  "jokerman";                }             }       注：  1）条件可不可以省略，逻辑正确的情况下，条件可以省略  2）最简写法，先写小屏幕，从小往大写，只写小的条件    优点：a）代码量急剧减少       b）响应式会向上兼容        sm在sm/md/lg/xl屏幕下有效        md在md/lg/xl有效        lg在lg/xl有效        xl在xl有效  3）条件可以自己随意更改 (min-width:777px)    

 



 

## 2、Bootstrap

boot以类的方式，封装了很多样式，只需要调用类名，就可以使用，能高效提升开发效率。

有些时候，boot的样式不符合我们需求，需要重写样式。很多时候，也需要手写媒体查询。

Boot4需要查看boot4和boot3的两份文档。Boot4只有更新的部分

1)     起步，如何使用boot

2)     全局css

3)     组件和js插件

4)     定制 sass

5)     boot完成学子商城（boot是移动端优先的样式框架）

### （1）使用boot

要想使用boot要按顺序完成以下四个步骤：

| 定义视口            | <meta name="viewport"  content="width=device-width,initial-scale=1"> |
| ------------------- | ------------------------------------------------------------ |
| 导入boot的css       | <link  rel="stylesheet" href="css/bootstrap.css">            |
| 按顺序导入3个js文件 | <script  src="js/jquery.min.js"></script>  <script  src="js/popper.min.js"></script>  <script  src="js/bootstrap.min.js"></script> |
| 添加div容器         | <div  class="container">所有boot代码写在此处</div>           |

### （2）全局样式

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) boot封装了4个屏幕的响应式，没有超小屏，

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) boot中1个rem=16px

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) .container 在不同屏幕下有最大宽度，定宽容器，左右内边15px，水平居中。

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) .container-fluid 定宽容器，宽度是body的100%

.btn 按钮的基本类， 行内块，文本字体的设置，伪类的设置一共42行

| 按钮颜色     | btn-danger  红色；warning 黄色；success 绿色；info 青色；  primary 蓝色；secondary灰色；dark深色；light 浅色 |
| ------------ | ------------------------------------------------------------ |
| 带边框的按钮 | btn-outline-danger/warning........                           |
| 按钮的大小   | btn-lg/ sm 大按钮/小按钮                                     |
| 特殊按钮     | btn-block/ link  块级按钮/链接按钮                           |

图片相关(boot3有相关类，boot4更新)

| 圆角4px    | rounded                                           |
| ---------- | ------------------------------------------------- |
| 圆角50%    | rounded-circle                                    |
| 缩略图     | mg-thumbnail                                      |
| 响应式图片 | img-fluid（图片等比缩小，但是图片最大就是原尺寸） |

文本相关的类

| 文本颜色           | text-danger/warning/info......text-muted浅灰色               |
| ------------------ | ------------------------------------------------------------ |
| 字母的控制         | text-uppercase/ lowercase / capitalize 转大写 /转小写 /首字母大写 |
| 字体的粗细         | .font-weight-normal/light/bold                               |
| 字号大小           | .h1~.h6 不同字号大小                                         |
| 文字的水平对齐方式 | text-center/left/right/justify                               |

列表相关的类

| 去除标识项 | list-unstyled                                    |
| ---------- | ------------------------------------------------ |
| 生成列表组 | list-group（弹性，y的主轴）                      |
| 列表项     | list-group-item（边框---第一项和最后一项带圆角） |
| 列表项颜色 | list-group-item-danger/warning/info..            |
| 激活项     | active                                           |
| 禁用状态   | disabled                                         |

表格相关的类

| 基本类       | table   宽度100% th，td上边框·                               |
| ------------ | ------------------------------------------------------------ |
| 边框         | table-bordered    给table添加边框，给table下的th，td添加边框 |
| 背景色       | table-info/warning/danger....                                |
| 隔行变色     | table-striped    给奇数行，添加一层0.05的透明度的黑纱        |
| 鼠标悬停变色 | table-hover    给鼠标悬停的行，添加一层0.075透明度的黑纱     |

辅助类（所有元素都能用的类）

| 边框     | 基本类     border / .border-top/right/bottom/left  清除边框    border-0 /  border-top/right/bottom/left-0   边框颜色    border-danger/warning/info...... |
| -------- | ------------------------------------------------------------ |
| 浮动     | 基本类     float-left/right/none;  响应式     float-*-left/right/none; *:sm/md/lg/xl  解决高度坍塌  clearfix （写在父元素上） |
| 显示效果 | 可见的     visible  visibility：visible;  不可见的    invisible visibility:hidden |
| 圆角     | 基本类     rounded （4个角4px）  一方向的两个角 rounded-top/right/bottom/left  50%的圆角   rounded-circle   清除圆角    rounded-0 |
| 背景颜色 | 基本类     bg-danger/warning/.....white/dark/light  透明      bg-transparent |
| 内外边距 | 外边距     m/mt/mr/mb/ml/mx/my-sm/md/lg/xl-0/1/2/3/4/5/auto  内边距     p/pt/pr/pb/pl/px/py-sm/md/lg/xl-0/1/2/3/4/5（内边距没有auto）  0--->0rem；1--->0.25rem；2--->0.5rem；3--->1rem；4--->1.5rem；5--->3rem |
| 尺寸     | w-25/50/75/100   width:25%/50%/75%/100%  h-25/50/75/100  height:25%/50%/75%/100% |

## 3、栅格布局grid

web页面一般有三种布局方式：

1）table布局 优点：简单，容易控制；

缺点：语义错误，渲染效率极低

2）div+css   优点：语义正确，渲染效率高；

缺点：控制起来很麻烦手写媒体查询，才能变成响应式页面，代码量巨大

3）Boot封装的栅格布局

​    优点：简单，容易控制，语义正确，渲染效率高，支持响应式（做响应式页面首选）

​    缺点：非常复杂的页面不适用

### （1）栅格的使用

栅格布局（grid布局）把每一个布局都看成一行，每一行分成12份。

  row   弹性，默认x轴主轴，可换行  左右-15px外边距  col-n;  n:1~12    左右15px内边距  

### （2）响应式栅格

快速完成页面的响应式布局

  col-*-n  n:1-12   *:sm/md/lg/xl  每一个col自带左右15px内边距，经常要清空  no-gutters可以清除row的-15px外边距和col的15px内边距  

### （4）列偏移

  offset-*-1/2/3/4/5/6/7/8/9/10/11  *：sm/md/lg/xl  

### （5）不带数字的col类

  自动根据数量平分整个row，而且数量可以超过12个，取决于内容大小  

## 4、弹性布局

| 设置元素显示方式     | d-*-none/block/inline/inline-block/table/flex    *:sm/md/lg/xl |
| -------------------- | ------------------------------------------------------------ |
| 设置弹性容器         | d-*-flex / inline-flex                                       |
| 响应式主轴的方向     | flex-*-row/column/row-reverse/column-reverse                 |
| 响应式换行           | flex-*-no wrap/wrap                                          |
| 响应式主轴对齐方向   | justify-content-*-between/around/start/center/end            |
| 响应式交叉轴对齐方式 | align-items-*-start/center/end/baseline                      |

弹性和栅格的关系

只要是设置了弹性 主轴是x轴 可换行的都可以当栅格的row来使用。 

## 5、form表单

| 表单元素的排列方向 | form-group 堆叠表单，垂直方向排列  form-inline 内联表单，水平方向排列（可以完美替代row） |
| ------------------ | ------------------------------------------------------------ |
| 表单元素的样式     | form-control   块级，w100，圆角，内边距，字号， 边框，过渡   |

## 6、组件

页面中一些复杂的效果，之前我们必须使用js.dom.jq去完成。boot为了让开发者快速完成，把很多的复杂效果给封装了。boot把js进行了封装，我们要调用js的时候，使用自定义属性执行事件。

boot调用事件要注意：

1.调用事件的方式（靠自定义属性控制）2.事件影响的对象（自定义属性）

### （1）常用组件

| 按钮组     | 横向按钮组 btn-group  垂直按钮组 btn-group-vertical  按钮的大小 btn-group-lg/sm |                                                              |      |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| 下拉菜单   | ①样式结构  div.dropdown（相对定位）   >.btn.dropdown-toggle（画向下小三角）   +ul.dropdown-menu（display:none;） | ②事件  button自定义属性：data-toggle="dropdown"  目标元素：由于ul和button有共同的父元素，所以不需要设置ul为目标 |      |
| 信息提示框 | ①样式结构  div.alert alert-warning设置提示框颜色  .alert-dismissible 让小x改变字体颜色  >span.close（右浮动） | ②事件  span自定义属性：data-dismiss="alert"  （自动把父元素div关闭） |      |
| 水平导航   | ul.nav（弹性，x轴主轴，可换行，去点，去左内边距）   .nav-justified（让item等宽显示）   >li.nav-item   >a.nav-link |                                                              |      |
| 选项卡导航 | ①样式结构  ul.nav.nav-tabs（设置成选项卡）   >li.nav-item   >a.nav-link  .active 让选项被选中  div.tab-content  让内部div都隐藏   >div.tab-pane      .active   隐藏div显示 | ②事件  激活元素 a.nav-link  data-toggle="tab"  href="#d1"  目标元素：div.pane   给对应的div添加id，在对应的a的href使用#id设置目标 |      |
| 胶囊导航   | ul.nav nav-pills  a data-toggle="pill" 其他与选项卡导航一样  |                                                              |      |
| 导航栏     | div.navbar （弹性，x轴主轴，可换行，交叉轴居中，两端对齐）    .navbar-expand-*  *:sm/md/lg/xl  作用，在*屏幕以上，ul的主轴变为x轴   >ul.navbar-nav （弹性，主轴y轴）  >li.nav-item      >a.nav-link |                                                              |      |
| 折叠效果   | ①样式结构  button  div#id.collapse  效果display:none         | ②事件  button：data-toggle="collapse"data-target="#id"       |      |
| 卡片       | div.card  弹性，y轴，背景，边框  >div.card-header  +div.card-body  +div.card-footer使用场合，把纵向排列的内容，放到卡片中使用 |                                                              |      |
| 手风琴     | ①样式结构  div#parent     >div.card      >div.card-header >a     +div.collapse      >div.card-body | ②事件  a标签： data-toggle=”collapse” href=”折叠div的id”  div.collapse： data-parent=”#最外层div的id” |      |
| 折叠导航栏 | ①样式结构：   div.navbar  .navbar-dark  让内部所有文本颜色变成浅色，但是需要单独写bg-dark  .bg-dark 设置背景颜色  .navbar-expand-* 作用3个  配合button.navbar-toggler，让按钮在*之上的屏幕隐藏 在*以下的屏幕显示  配合ul.navbar-nav， 让li*以上横向显示  *以下纵向显示  让折叠部分.navbar-collapse的宽度在*以上是自动（不用折行）                  *以下变成100%(需要折行)                     ****任何情况都显示的第一个****a****标签****-->**   a. navbar-brand让a标签行内块，设置字号。配合父元素.navbar-dark，让当前字体为白色  ****以上不显示，****md****以下显示的按钮，按钮还是激活折叠的按钮**  **-->**  button.navbar-toggler 内边距，背景和边框透明   >span .navbar-toggler-icon 三条线，颜色受.navbar-dark控制  ****折叠的****div,div****内部的****ul>li****，在****md****以上横向显示，****md****以下纵向显示****-->**    div#d1.collaspe   .navbar-collapse  让div在*以上可以显示，在*以下隐藏  >ul.navbar-nav>li.nav-item>a.nav-link  ②事件：button data-toggle=”collapse” data-target=”#d1” |                                                              |      |
| 焦点轮播图 | 样式结构分为3部分  div.carousel    相对定位  1）轮播图片  >div.carousel-inner  相对定位，溢出隐藏, w-100   >div.carousel-item  相对定位，display:none, w-100     .active 在一个item上添加active，让这张图片显示  >img.w-100  事件：最外层div.carousel 添加 data-ride="carousel"  2）轮播指示器  ul.carousel-indicators  绝对定位，弹性主轴为x   >li    可以根据需要重写li样式  事件：li data-target="#demo" 目标是div.carousel的id  data-slide-to="0" 图片的下标  3）左右箭头  a .carousel-control-prev/next   >span.carousel-control-prev/next-icon 画箭头  可根据需求重写左右箭头样式  事件：data-slide="next/prev"  href="#demo" demo是最外层carousel的id |                                                              |      |
|            |                                                              |                                                              |      |

### （2）其他组件

| 媒体对象         | div.media  弹性  x轴主轴   >img   +div.media-body            |
| ---------------- | ------------------------------------------------------------ |
| 模态框           | 模态框modal是覆盖在父窗体上的子窗体  div.modal  固定定位，相当于给页面蒙上一层黑纱   >div.modal-dialog 把内容位置，居中显示  >div.modal-content 背景，圆角，弹性 y轴主轴    >div.modal-header    +div.modal-body    +div.modal-footer |
| 徽章  （小按钮） | badge 基本类  badge-danger 颜色  胶囊徽章 badge-pill         |
| 巨幕             | jumbotron 巨大的内边距和背景色                               |
| 分页             | ul.pagination 弹性，x主轴   >li.page-item   .active  li设置active 让内部的a标签显示为选中状态  .disabled   li设置disabled 让内部的a标签显示禁用状态     >a.page-link  bootstrap封装的样式不满足需求的话，可根据需求修改样式，如修改圆角和每一项间距  /* 每一个项的圆角 */  .page-link{border-radius:  .25rem;}  /* 每一项的间距 */  .pagination .page-item+.page-item{margin-left:  .5rem;} |
| 面包屑导航       | 早期，是为了显示有层进关系的导航  现在，只要每一项之间有内容，都可以使用面包屑导航  ul.breadcrumb   >li.breadcrumb-item   >a  bootstrap封装的样式不满足需求的话，可根据需求修改样式，如修改连接符：  .breadcrumb-item +  .breadcrumb-item::before{   content:">";  } |
| 进度条           | div.progress  进度条的槽   >div.progress-bar .w-75：通过宽度来控制进度 bg-dange：可以改变背景色     .progress-bar-striped 带条纹进度条     .progress-bar-animated 条纹带动画  特点：  一个槽中有多个条，需要把所有条的宽度相加，在看某一个条的占比 |

 

## 7、SCSS/sass

boot阶段，重点只有3个，手写媒体查询+栅格布局+scss

SCSS：动态样式语言

动态样式语言赋予css新的特性，包括变量，嵌套，混合，函数，指令等等新特性，提高代码复用，提高代码的可维护性。scss加入和多代码复用机制，让css代码更加的强大且优雅。

常见的css动态语言

1)     scss是sass的升级版，让语法更接近传统的css，但是输入的命令还是用sass

2)     stylus

3)     Less（boot3使用less完成）（boot4使用scss完成）

### （1）SCSS使用

scss文件的后缀.scss，前台不能识scss文件，需要在后台转换为css才能使用。

1）scss的安装

l 在线安装：访问的国外的网站 npm install -g node-sass）

如果网速不好，下载过程会丢包，丢包就报错

l 离线安装：参考scss安装文档，在发送的资源中有

2）scss文件转换成css文件

l 单文件转换，一次转换一个scss文件：node-sass scss/文件路径   css/文件路径

l 多文件转换，一次转一个文件夹的文件：node-sass scss文件夹  -o css文件夹

l 单文件监听，监听开启，保存后自动转换：node-sass -w  scss文件路径 css文件路径

l 多文件监听，监听开启，保存后自动转换：node-sass -w scss文件夹 -o  css文件夹

### （2）scss基础语法

##### 1.变量

1）声明变量： 使用 **$** 声明变量，变量的值可以被其他变量引用。$变量名:值;

2）变量名称： 变量名可以有 - _ ，变量的命名规则基本同选择器命名规则。

3）变量的作用域：同js，只在最近的大括号中有效

##### 2.嵌套

1）结构嵌套：可以在选择器中嵌套其他的选择器，生成后代结构关系

2）群组嵌套：div,h2,p{a{color:#ccc;}}；生成div a, h2 a, p a { color: #ccc; }

3）属性嵌套：一般要求css能简写，就不要分开写

##### 3.导入

1）局部scss文件

文件名称以_开头，就是局部scss文件，局部scss文件不会被转换成css文件

可以在一个全局scss文件中，导入多个局部scss文件，最后生一个css文件

2）全局scss文件

不以_开头的scss文件，可以导入其他全局文件和局部文件

导入的语法：_aaa.scss,如果导入局部scss，掐头去尾，@import "aaa";

bbb.scss如果导入全局，可以@import "bbb" 也可以 @import "bbb.scss"

除了整合的时候很方便，被导入文件中的变量，可以在导入文件中使用

##### 4.混合器

1）把一段样式进行封装，需要使用的地方直接调用混合器名称

| 普通混合器     | @mixin 混合器名称{    样式申明  }  调用混合器 @include 混合器名称 |
| -------------- | ------------------------------------------------------------ |
| 带参数的混合器 | @mixin 混合器名称($形参,$形参.....){}  调用混合器  @include混合器名称(实参,实参.....){} |

 

2）混合器使用最多的场景 是css hack

@mixin my_bg1($direction,$color1,$color2){

​     background: -webkit-linear-gradient($direction,$color1,$color2);

​     background: -o-linear-gradient($direction,$color1,$color2);

​     background: -ms-linear-gradient($direction,$color1,$color2);

​     background: -moz-linear-gradient($direction,$color1,$color2);

}

##### 5.继承

一个选择器可以继承另外一个选择器所有的样式

通过关键字@extend #d1; 继承最后使用群组选择器方式展现

##### 6.运算

①加，字符串拼接

  带""的字符串去拼接不带""的，结果带""  不带""的付出去拼接带""的，结果不带""  

②减法

  由于scss变量可以使用-  系统分辨不出-到底是减法运算还是变量的一部分  所以写减法的时候，减号前后添加空格，做区分  

③除法

  在scss中 / 会被认为是分隔符  在以下情况下，被认为是除法  1.当除号两边有变量的时候，被认为是除法  2.除法计算式，被括号包裹，被认为是除法  3.除法计算式，是其他计算式的一部分，我们认为是除法  

④插值操作

  content:"chengliang ate #{30+50}  baozis";  使用#{}做插值  

⑤颜色的运算

  颜色需要分段运算，红+红  绿+绿 蓝+蓝  分段运算之后，结果超过255，就取值255  特殊：rgba的运算，要求alpha值相同才可以计算  

 

 

### （3） scss的函数

1.scss预定义的函数

①数学函数

  round($val) 四舍五入  ceil($val);向上取整  floor($val);向下取整  min($v1,$v2,$v3.....) 取最小值  max($v1,$v2,$v3....) 取最大值  random（）随机数  

②字符串函数

  unquote("111") 去掉双引号  quote();添加双引号  to_upper_case("abc") 转换成大写  to_lower_case("ABC") 转换成小写  

③自定义函数

  @function show($a,$b){      @return $a+$b;  }  关键字之前添加@符号，变量之前添加$  

四.指令(if-else)

  @if(){  }@else if(){  }@else{}  

 



# 学子商城项目

完成学子商城首页

## 1、补充









# 第三阶段

## 一、JS高级

## 1、正则表达式

正则表达式（Regular Expression）：由一些普通字符和特殊字符组成的，用以描述一种特定的字符规则的表达式。

（因为程序不认识人类语言中的词汇，所以才需要程序员用正则表达式教程序认识人类语言中的词汇）

​                               

正则表达式常用在一段文本中搜索、匹配或者替换特定形式的文本。如：词语出现频率的统计，验证字符串格式、查找敏感词（查水表）。

### （1）定义正则表达式

##### 1）普通字符

所有的单个大小写字母，数字都是一个正则表达式，用以匹配单个字符，这个字符与它本身相同。

正则表达式中有些字符有特殊的语法含义，是不能直接使用的，必须使用**\**进行转义后才能使用。

  ·    \   / * +   [ ( )   ] { }   ^ $ |  

对不是元字符的字符进行转义是不会出现问题的；但未对元字符进行转义就会有错误。

注：正则表达式中不能有任何多余的字符：如空格，逗号，回车等

ex：

  定义正则表达式：我草  那天，我去了她家，我说：我草！你家真大  

##### 2）字符集

正则表达式使用如下语法匹配一个范围内的字符

| **语法**        | **含义**                                   |
| --------------- | ------------------------------------------ |
| [abc]  [^abc]   | 匹配指定集合内 / 集合外的任一个字符        |
| [0-9]           | 要匹配任意一个数字                         |
| [A-Z]  [a-z]    | 要匹配一位大写  / 小写字母（共26个）       |
| [A-Za-z]        | 要匹配一位字母（共52个）                   |
| [0-9A-Za-z]     | 要匹配一位字母或数字（共62个）             |
| [\u4e00-\u9fa5] | 要匹配一位汉字（19968  ~ 40869 共20902个） |

ex：

| 定义一个规则同时匹配“我草” ，“我艹” “我槽” 三种敏感词        | 修改规则，使其进一步匹配“卧槽 |
| ------------------------------------------------------------ | ----------------------------- |
| 我[草艹槽]                                                   | [我卧][草艹槽]                |
| 利用字符集简写定义车牌号规则                                 |                               |
| [\u4e00-\u9fa5][A-Z]·[0-9A-Z][0-9A-Z][0-9A-Z][0-9A-Z][0-9A-Z] |                               |
| 利用字符集简写定义电话号码规则                               |                               |
| 1[3-9][0-9] [0-9] [0-9] [0-9] [0-9] [0-9] [0-9] [0-9]        |                               |

##### 3）预定义字符集

正则表达式中可以使用如下元字符引用来进行简化

| **语法** | **含义**                                  |
| -------- | ----------------------------------------- |
| \d       | 匹配一个数字                              |
| \D       | 匹配一个非数字                            |
| \w       | 匹配一个数字/字母/下划线                  |
| \W       | 匹配一个非数字/字母/下划线                |
| \s       | 匹配一个空白字符（空格、制表符Tab等空白） |
| \S       | 匹配一个非空白字符                        |
| ·        | 匹配除了回车和换行外的任何单个字符        |

ex：

| 利用\s匹配一句英文中的每个空格 | 利用预定义字符集简写定义电话号码规则 |
| ------------------------------ | ------------------------------------ |
| 答案： \s                      | 答案：1[3-8]\d\d\d\d\d\d\d\d\d       |

字符集存在的问题：一个字符集（\d或[0-9]）只能匹配一位字符。如：手机号规则中\d写了9遍，车牌号规则中[0-9A-Z]也写了五遍

##### 4）数量词

数量词，是专门规定一个字符集出现次数的规则，今后，只要一个字符集在规则中可能连续反复出现多次，就要用数量词以简写方式定义出现次数。

如何使用：数量词紧跟在其修饰的字符集之后，默认修饰相邻的前一个字符集

数量词包括两大类：有明确数量边界的数量词；没有明确数量边界的数量词

| **语法** | **含义**             |
| -------- | -------------------- |
| n?       | 匹配零次或一次字符n  |
| n*       | 匹配零次或多次字符n  |
| n+       | 匹配一次或多次字符n  |
| n{x}     | 匹配字符n出现x次     |
| n{x,y}   | 匹配字符n出现x到y次  |
| n{x,}    | 匹配字符n的出现>=x次 |

ex：

| 利用数量词进一步简写车牌号规则            | 利用数量词进一步简化电话号码规则 |
| ----------------------------------------- | -------------------------------- |
| 答案： [\u4e00-\u9fa5][A-Z]·[0-9A-Z]{5}   | 答案：1  [3-8]\d{9}              |
| 匹配手机短信中的验证码：连续的4位~6位数字 | 匹配字符串中的一组连续空字符     |
| 答案：\d{4,6}                             | 答案：\s+                        |

##### 5）选择和分组

屏蔽敏感词时，屌丝把字换成拼音就查不出来了；

错误的做法:：直接将拼音放入[]中作为字符集中的备选。比如：[草cao]

字符集只认识单个字字符集只认识单个字，[草cao] 就代表 草 c a o 四个字符

正确的做法：选择：指在多个子规则中选其一匹配。只要在多个子规则中选其一匹配，就用选择

如：草|cao 匹配一个“草” 字或“cao”这个拼音

分组：将多个子规则视为一组，再和分组外的规则匹配只要希望将多个子规则视为一个整体，再和其它规则匹配时，就用分组

如：我(草|cao)  匹配“我草”或“我cao”

| **语法**              | **含义**                                                   |
| --------------------- | ---------------------------------------------------------- |
| 子规则1 \| 子规则2    | 满足规则1 或 满足规则2  “\|”选择符只分左右，不考虑单个字符 |
| 其它规则 (多个子规则) | 使用括号() 指定分组——子表达式                              |

注：

| 不遵守贪婪模式，而是采用类似短路逻辑的模式。如果前一个规则已经匹配，则后一个规则，不再匹配！ 如(w|wo|我) 只能匹配到w，匹配不到wo。

ex：

| 同时验证同音字或拼音                 | “我” 字也可能是“卧”或“wo”         |
| ------------------------------------ | --------------------------------- |
| 答案：我 ([草艹槽]\|cao)             | 答案：([我卧]\|wo)([草艹槽]\|cao) |
| 可能在中间加不确定个数的空字符       | 匹配字符串中的一组连续空字符      |
| 答案：([我卧]\|wo)\s*([草艹槽]\|cao) | 答案：\s+                         |
| 定义完整手机号规则：                 | 定义完整身份证号规则:             |
| 答案：((\+86\|0086)\s+)?1[3-8]\d{9}  | 答案：\d{15}(\d\d[0-9x])?         |

ex：

| 匹配“微信”，“weixin”，“w x”等情况，并防止中间加空格 | 定义电子邮箱                 |
| --------------------------------------------------- | ---------------------------- |
| 答案：(微\|w\|wei)\s*(信\|x\|xin)                   | 答案：\w+@[\w-]+\.\w+(\.cn)? |

##### 6）指定匹配位置

如果只希望匹配特殊位置上的关键词时，就可用特殊符号表示特殊位置。

| **语法** | **含义**                                                     |                                            |
| -------- | ------------------------------------------------------------ | ------------------------------------------ |
| ^        | 表示字符串开头                                               | ^\s+（仅匹配开头的空字符）                 |
| $        | 表示字符串结尾                                               | \s+$ (仅匹配结尾的空字符)                  |
| \b       | 表示单词边界，可匹配：空格，标点符号，字符串开头和结尾等可将一个单词与其它单词分割开的符号。 | **\b[a-z] (****匹配每个单词的首字母****)** |

### （2）string提供正则相关的函数

String类型提供的正则相关的函数：

##### 1）查找敏感词（4种情况）

①查找一个固定的敏感词出现的位置：

​               a. var i=str.indexOf("要找的敏感词", fromi)

​       位置 的 要找的敏感词

​    b. 意思: 在字符串str中，从fromi位置开始，查找下一个指定的敏感词出现的位置

​    c. 简写: 其实大部分情况下都是从开始位置开始查找(fromi=0)，所以fromi可省略。

​           如果省略第二个参数fromi，则默认从开始位置(0位置)开始查找.

​    d. 返回值: 如果找到敏感词，就返回敏感词第一个字在字符串中的下标位置i

​           如果没找到敏感词，返回-1

​    e. 示例: 查找用户输入的消息中是否包含我草

​    f. 问题: 只能找一种固定的敏感词，不支持正则

②用正则查找多种敏感词的位置:

a. var i=str.search(/正则表达式/i)

​    b. 意为: 在str中从开始位置向后查找第一个符合正则表达式要求的敏感词的位置

​    c. 返回值: 同indexOf是完全一样的

​         i.     如果找到，返回敏感词第一个字在字符串中的位置

​        ii.     如果没找到，返回-1

​    d. 坑: 

​         i.     正则表达式默认区分大小写的！

​        ii.     想忽略大小写: 在第二个/后加i, 意为ignore 忽略大小写

f. 问题: 只能获得敏感词的下标位置i，无法获得敏感词的内容

③查找第一个敏感词的内容和位置

​    a. var arr=str.match(/正则/i)

​    b. 意为: 在字符串str中查找第一个符合正则要求的敏感词的内容和位置，并将内容和位置

放在一个数组中返回！

​    c. 返回值: 

​       i. 如果找到敏感词，就会将敏感词的内容和位置放入数组中返回: 

​        arr[ "0": "敏感词内容", "index":敏感词位置下标i ]

​       ii. 如果找不到敏感词返回 null

④查找所有敏感词的内容，但是无法获得位置了

a..var arr=str.match(/正则/ig)  g意为global 全部

​    b. 意为: 查找str中所有符合正则要求的敏感词的内容，放入一个数组中返回。但是，不包

含每个敏感词的位置了！

​    c. 返回值: 

​       i. 如果找到敏感词，就会将敏感词的内容都放入一个数组中返回

​       ii. 如果找不到敏感词，就返回null

  总结: 返回值的规律:   1. 如果函数返回下标位置i，如果找不到，返回-1  2. 如果函数返回一个数组，如果找不到，返回null  

js中数组的本质: 

  1. 其实js低层只有一种数组: 关联数组(下标为自定义的字符串名称的数组)    比如: var ym=[]  ym["math"]=89; ym["chs"]=69;  ym["eng"]=95;    内存中: [      "math" : 89,      "chs" : 69,      "eng" : 95    ]  2. 其实js中根本就没有真正的索引数组(下标都是数字的数组)。索引数组的底层也是一个关联数组。索引数组的下标其实也是一个字符串。    比如: var arr=[1,2,3];    内存中: [       "0"  : 1,       "1"  : 2,       "2"  : 3    ]   3. 索引数组 vs 关联数组:     相同: 都可用 数组名["下标名"] 获得某个元素值      比如: ym["math"] arr["1"]    不同的简写:       ym["math"] 可简写 ym.math      arr["1"] 可简写 arr.1  arr[1]  

##### 2）替换敏感词

①简单替换：将所有找到的敏感词都替换为统一的新值

a. str=str.repalce(/正则/g,"新值")

​    b. 意为: 查找字符串str中所有符合要求的敏感词，并统一替换为指定的"新值"

​    c. 示例: 替换字符串中的敏感词并统计共替换几处

  补: js中字符串是不可变类型  1. 不可变类型: 一旦创建，内容不可改变，只能整体替换  2. 后果: 所有字符串类型提供的函数，都无权修改原字符串，只能返回加工后的新字符串。如果想获得加工后的结果，必须用变量接住返回的新字符串。原字符串始终保持不变。  其实, 数组是可变类型，所以数组类型提供的大多数函数，都可直接修改原数组，而不用变量接住。  比如: arr.sort() arr.reverse()  

②高级替换: 根据每个敏感词的不同，动态选择不同的新值替换。

a）str=str.repalce(/正则/g,fallback)

代码详解：str=str.replace(/正则/ig, 

​       function(keyword){ //replace每找到一个敏感词就自动调用一次回调函数

​           //keyword: 自动接收到本次找到的敏感词内容-信任

​           return 根据本次找到的不同敏感词keyword不同，动态选择不同的新值

​       }//replace会将回调函数返回的新值，替换到字符串中敏感词的位置

​     )

​     说明: 形参keyword，可以随便改名，但是必须见名知义！

​    b.）示例:将每个单词首字母改为大写（复习敲三遍）

③衍生操作：删除敏感词，其实就是将敏感词替换为""而已

​    a.）str=str.replace(/正则/ig, "")

​    b.）示例: 去掉字符串开头和结尾的空字符（复习敲三遍）

##### 3）切割字符串

①简单切割：按一个固定的切割符号，将字符串切割为多段子字符串

​    a）var arr=str.split("切割符")

​    b）强调: 在切割之后的结果中，不再包含切割符

​    c）固定套路: 将字符串打散为字符数组: 按""切割 var arr=str.split("")

​    d）示例: 翻转字符串（复习敲三遍）

②复杂切割：切割符不是固定的，可能有很多种

​    a）var arr=str.split(/正则表达式/)

​    b）意为：用str中所有符合正则要求的敏感词当做切割符，切割字符串

​    c）说明：split中的正则不加g，照样可以找所有敏感词

​    d）示例：利用正则切割字符串“you can  you up,no can no bibi”

### （3）RegExp对象

在js程序中专门保存一条正则表达式的对象。正则表达式的语法是独立所有编程语言之外的一种全新的语法，js语言不认识正则表达式语法。所以，才需要一种专门的对象，将正则表达式翻译为js语言能明白的格式。

只要在js语言中使用正则表达式都要创建RegExp对象保存一条正则表达式。

##### 1）创建RegExp对象

① 用//创建: （首选）

a. var reg=/正则/ig

​    b. 问题: //之中只能写死一个固定不变的正则表达式，//之中不支持用js语句动态生成正则表达式

​    c. 何时: 如果正则表达式是固定不变的，比如: 手机号，电子邮件地址，身份证号

② 用new创建: 

​    a. var reg=new RegExp("正则表达式" , "ig")

​    b. 强调: 用new创建正则表达式，不要再写//了！

​    c. 何时: 如果正则表达式不是固定的，可能根据其他变量的值动态生成正则表达式，就只能用new 来创建。因为new RegExp()的参数是字符串，而再js中有无数种办法动态拼接出我们想要的任何字符串——灵活。

​    d. 示例: 动态生成正则表达式; （复习敲三遍）

##### 2）RegExp对象提供的函数

①验证字符串格式

a)   var bool=正则表达式对象.test(要检查的字符串)

b)   意为: 用test前的正则表达式，检查()中的字符串是否符合格式要求

c)   返回值: 

​         i.     如果()中的字符串符合test前的正则表达式的要求，则返回true

​        ii.     如果()中的字符串不符合test前的正则表达式的要求，则返回false

d)   坑: test默认只要在字符串中找到部分内容符合正则的要求，就返回true，不要求从头到尾都完整匹配的！

e)   解决: 今后只要验证格式，都要在正则表达式中 **前加^****，后加$****，**表示从头到尾必须完整匹配！

f)    示例: 验证手机号格式（复习敲三遍）

②既查找每个敏感词的内容，又查找每个敏感词的位置

a)   var arr=正则表达式.exec(可能包含敏感词的字符串)

​       强调: 如果希望exec()可以继续找下一个敏感词，最终找到所有敏感词，则正则表达式必须加g

b)   意为: 用正则表达式在可能包含敏感词的字符串中查找下一个敏感词的内容和位置

c)   问题: 每执行一次exec()也只能找一个敏感词——同match()不加时相同

d)   解决: 用循环反复调用exec()，exec()函数自动知道要找下一个敏感词——比match()聪明！

e)   返回值：

​         i.     如果本次调用函数时，找到了敏感词，就返回一个数组：同match()不加g的情况: arr:[ 0:"本次找到的敏感词内容", index:本次找到的敏感词位置 ]

​         i.     如果本次调用函数时，没找到敏感词，就返回null

f)    示例: 查找一个字符串中所有敏感词的内容和位置（复习敲三遍）

## 2、函数

### （1）知识回顾

  1)     什么是函数：内存中保存一段可重用的代码片段的存储空间，再起一个名字  2)     何时用函数：当程序中一段代码片段可能被反复使用时，都要将这段代码片段定义为一个函数，然后反复调用函数。——重用  3)     如何使用函数：  (1). 先定义函数: 创建一个函数对象，其中保存一段代码片段，再起一个名字      a.  function 函数名(形参列表){         函数体;         return  返回值;       }      b.  形参: 专门保存函数调用时必须的数据的局部变量         1).  何时: 当函数必须提供某些数据才能正常执行时，就要定义形参      c.  返回值: 一个函数的执行结果数据，通过return返回到函数外部，被外部变量接住         1).  何时: 当调用者需要获得函数的执行结果时，函数就要定义返回值      (2).  调用函数      a.  var 变量=函数名(实参值列表)      b.  过程:          1).  Js引擎在内存中找到指定函数名的函数         2).  将实参值列表中的实参值赋值给函数的形参变量         3).  执行函数体中定义的代码片段         4).  如果有返回值，则将返回保存到=左边的变量中  4） 创建函数共有3种方法:       (1).  用声明方式创建函数:                                                                                        a. function 函数名(...){         ... ...         声明       }      b. 会被声明提前: 打乱程序正常的执行顺序      (2).  用赋值方式创建函数:      a. var 函数名= function (...){         ... ...          不是声明         }      b.  不会被声明提前:       c.  示例: 判断程序的输出结果      d.  揭示了: 函数的本质         1).  其实js中函数也是一个对象，只不过对象中保存的不是数据，而是代码片段         2).  其实js中的函数名只是一个普通的变量而已。         3).  函数名变量中通过函数对象的内存地址值，引用着函数对象。         4).  当我们调用函数时，都是先找到函数名变量，再通过函数名变量中保存的内存地址，找到函数对象，并执行函数对象中保存的代码片段。      (3).  用new创建函数:       a.  var 函数名=new Function("形参1", "形参2", ...,  "函数体;return 返回值");      b.  基本不用。      c.  揭示了函数的本质: 其实前两种方法的小写function，都是new Function()的简写  

### （2）重载（overload）

l 重载（overload）：相同函数名，不同形参列表的多个函数，在调用时可自动根据传入的实

​         参值不同，自动选择匹配的函数执行

1)   何时使用：能根据传入的实参值不同，执行不同的操作逻辑时，都应该用重载.

2)   为什么使用： 减少函数名的数量，减轻调用者的负担。

3)   如何使用：

​        a. 问题: JS语言不支持其他语言那样的重载语法

​         因为: JS语言不允许多个同名的函数同时存在。

​         结果: 如果多个同名函数同时存在，最后一个同名函数会覆盖之前的所有同名函数

​        b. 解决: JS中借助于arguments对象来变通实现重载效果

l arguments：每个函数中都自带的：无需创建，在函数内可直接使用，专门自动接收所有传

入函数的实参值:。

1)   类数组对象，长得像数组的对象。和数组相比：

​       相同点: 1. 下标， 2. Length

​       不同点: 类型不同！类数组对象是Object家的孩子，不是Array家的孩子

​              导致类数组对象无法使用数组家的函数

​    2)  何时使用: 只要在js中使用重载时，都要借助于arguments对象

​    3)  如何使用: 

​       a. 只创建一个函数，不要定义形参，但是要包含多种不同的逻辑

​       b. 函数内通过判断arguments对象的长度或arguments对象中的实参值内容来决

定该执行哪种逻辑

5)  将来普通js函数还要不要写形参？

​        a. arguments名字太长！不好用！自定义形参都普遍简短！好用！

​        b. arguments中的下标0、1、等没有具体意义！自定义形参！都是见名知义的！

结论: 普通函数该用形参，还用形参。只有在不确定参数个数的重载时，才被迫用arguments

6)   示例: 使用重载实现三种付款方式（复习敲三遍）

ex：

| 定义一个函数add，可以计算任意多个整数的和 |
| ----------------------------------------- |
|                                           |

### （3）匿名函数

l 匿名函数：定义函数时不指定函数名的函数。

目的：节约内存；避免产生全局变量，造成全局污染。

几乎所有的回调函数都要定义为匿名函数。

？为什么回调函数都要定义为匿名函数？为了节约内存！

##### 1）回调函数

l 回调函数：自己定义了函数，但是不由自己调用，而是交给另一个函数，由另一个函数按需自动调用。

比如：

  想将一个数字内容的数组升序排列：  arr.sort(function(a,b){ return  a-b})  想根据不同的敏感词，动态选择不同的新值替换  str=str.replace(/正则/ig, function(keyword){ return 不同新值 })  

##### 2）匿名函数自调用

l 匿名函数自调用：定义一个匿名函数后，立刻调用该函数执行，调用后立刻释放！

目的：避免产生全局变量，造成全局污染

何时：今后一切js代码都应该放在一个大的匿名函数自调内！尽量不要使用全局变量！

如何：① 标准写法: 

  var 返回值=(function( 形参变量列表 ){   ... return 返回值   })( 实参值列表 )  

② 杀马特/非主流写法:

  +function(){ ... }()  ! function(){ ... }()             ...  ...  注意：不用()包裹function(){  ... }，但是结尾的()，必须要加！  

示例：使用匿名函数自调避免全局污染:

### （4）作用域和作用域链:

l 作用域：从作用来说就是一个变量的可用范围

目的：为了避免不同范围之间的变量互相干扰

本质：作用域其实是保存变量的特殊对象。

​    Js中包括2级作用域：全局作用域和函数作用域

##### 1）全局作用域

l 全局作用域：在程序任何位置都可随意访问的，专门保存全局变量的存储空间

Ø 在浏览器中，全局作用域由window对象担当！

Ø 当打开网页的一刹那，浏览器就会自动提前创建window对象，等待着保存后续创建的所有全局变量。

Ø 我们创建的所有全局变量都默认保存在window对象中。

Ø 保存在window对象中的变量，可在程序的任何位置被访问到。

​     

示例: 验证全局变量到底存在哪里？

##### 2）函数作用域

l 函数作用域：专门保存仅函数内可用的局部变量的存储空间

Ø Js中一个函数的作用域不调用是不存在的！只有调用函数时，才临时创建该函数的作用域，临时保存局部变量，函数调用后，函数作用域对象以及本次函数调用使用的局部变量一同释放！

Ø 函数作用域对象创建和释放的过程：

1）  当定义一个函数时，都会创建一个函数对象（New Function），但是每个函数对象上都会保存一个"好友列表"

 

2）  当调用函数时：会临时创建一个"函数作用域对象"，在函数作用域对象中添加函数中所需的所有局部变量（形参和函数内用var声明的变量），并将函数作用域对象的地址，临时保存到"好友列表"中离函数近的格子中。

 

3）  当函数执行过程中：函数会按照先局部，再全局的顺序，使用变量。如果局部有要用的变量，则优先使用局部的变量。除非函数作用域中没有要用的局部变量，才被迫去window中找变量使用。

 

4）  调用函数后：函数会释放函数作用域对象，导致函数作用域对象中的所有局部变量一同释放。所以，所有的局部变量都不可重用！

 

##### 3）作用域链

l 作用链：由多级作用域对象连接起来组成的数据结构，就叫作用域链

​    其实就是上例中的"好友列表"，

Ø 保存了一个函数可用的所有变量。

Ø 控制着变量的使用顺序: 先局部，后全局

​     

### （5）闭包

l 闭包：从作用来说，既重用一个变量，又保护变量不被污染的一种编程方式。

本质：外层函数的作用域对象，被内层函数函数引用着而无法释放，就形成了闭包对象。

使用闭包的原因：因为js中，全局变量和局部变量都有不可兼得的优缺点

1）  全局变量：可重用！但极易被污染和篡改——将来开发中几乎禁止使用全局变量

2）  局部变量：因为只能在函数内使用，不会被外部篡改，但不可重用

何时才使用闭包：今后只要想重用一个变量，而且还想保护这个变量不会被别人篡改时，都要用闭包！

如何：三步

1）  用外层函数包裹要保护的变量和内层函数

2）  外层函数将内层函数对象返回到外部

3）  想使用内层函数的人，调外层函数，就可获得返回出来的内层函数的对象，再保存在变量中，就可反复使用内层函数对象了

  1）闭包的原理

笔试题：一句话概括闭包如何形成的

外层函数调用后，由于外层函数的作用域对象被内层函数对象引用着，无法释放形成了闭包！

 

##### 2）闭包的缺点

比一般的函数多占用一块内存空间——多占外层函数的作用域对象

如何解决：当闭包不再使用时，要尽早释放闭包。

赋值null  //导致内层函数对象被释放，导致外层函数的作用域也别释放

ex：

|      |
| ---- |
|      |

 



 

## 3、对象

### （1）面向对象

l 面向对象：程序中先用对象结构保存现实中一个事物的属性和功能，然后再按需使用事物的属性和功能，这种编程方法，就叫面向对象编程

Ø 为什么要用面向对象：因为便于大量数据的管理和维护

Ø 何时：今后所有项目几乎都用面向对象思想开发

Ø 如何：3步/三大特点: 封装、继承、多态

### （2）封装

l 封装：创建一个对象，集中保存现实中一个事物的属性和功能

Ø 为什么：便于大量数据的管理和维护

Ø 何时：今后只要使用面向对象的编程方式，都要先创建所需的所有对象，备用。

Ø 如何：创建对象有3钟方式

1）使用大括号**{ }**创建一个对象。

2）用**new**创建 

3）用构造函数反复创建多个相同结构的对象

##### 1）使用大括号**{ }**创建对象

① 写法

| 语法：  var 对象名={  属性名**:**属性值**,**   **……**  方法名:function(){  },   **……**  } | 访问对象中的成员（属性和方法）  a）访问对象中的一个属性: 对象**.**属性名  b）调用对象中的一个方法: 对象**.**方法名() |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

② 使用 {} 创建对象存在的问题：

对象自己的方法中，想使用对象自己身上的属性，报错！自己的属性名未定义。因为任何情况下不加任何前缀的普通变量，默认只能在函数作用域对象和全局作用域对象window中查找变量使用。无权擅自闯入一个对象中读取对象的属性。对象中的大括号不是作用域。

F 解决方法一：在变量前写死当前对象的对象名: lilei.sname,  lilei.sage

但是此时对象名仅仅是一个普通的变量名而已，很可能随时发生变化。如果方法中写死旧对象名，则对象名一边，方法中的执行立刻出错，因为找不到旧的对象名了。被迫也要修改方法中写死的对象名—紧耦合—联系的过于紧密，不灵活。

​        

F 解决方法二：**this**关键字

this：是每个函数中自带的——不用创建，可直接使用。

自动指向正在调用函数的**.**前的那个对象。

Ø 何时：this今后只要在对象的方法中，想用当前对象身上的另一个属性时，都必须加this**.**属性名。

Ø 优点：松耦合

即使对象名将来发生变化，也不用修改方法中的this。因为this会在调用方法时，自动获得当前正在使用的对象名。

​        

ex：

| 使用{}创建一个对象和方法，并方法中使用对象中的方法           |
| ------------------------------------------------------------ |
| var Student={//对象的大括号不是作用域！仅仅是new Object()的简写  name:"dong",  age:26,  introduce:function(){  console.log(`I'm ${this.name},I'm ${this.age}`)  }  } |

##### 2）使用new创建对象

① 写法：

| 语法：  //1.0  先用new创建一个空对象  var 对象名=new  Object()  //2.0  给新的空对象赋值新属性和新方法  对象名.新属性名=属性值  对象名.新方法名=function(){  ... ... } | 访问对象中的成员（属性和方法）  a）访问对象中的一个属性: 对象**.**属性名  b）调用对象中的一个方法: 对象**.**方法名() |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

拓展：用new创建对象揭示js中对象低层最本质的秘密:：js中对象低层也都是关联数组

  a）存储结构完全相同：都是名值对儿的集合。  b）都可用2种方式访问成员：    标准: 数组名["下标名"]  对象名["属性名"]    简写: 数组名.下标名  对象名.属性名  c）都可随时向不存在的下标位置，强行添加新属性，而不会报错！  d）都可访问不存在的下标位置，不会报错，而是返回undefined  d）都可用for in遍历其中每个成员  总结: 对象低层其实就是关联数组，对象只不过是关联数组的简化用法而已。  

ex：

| 鄙视题: 克隆一个对象                                         |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 原对象：  var lilei={       sname:"Li Lei",       sage:11      } | 克隆对象  var person={       name:"dong",       age:11,       sex:0      }  // //错误做法:       // var person2=person;   //按值传递，不是克隆    原理如下：           //正确做法：  function clone(oldObj){  //1.0 创建一个空对象       var newObj={};  //新对象地址，肯定和oldObj不同！  //2.0 遍历旧对象中的每个属性      for(var key in oldObj){  //3.0 给对象强行赋值和对象同名的属性，且属性值也要相同  //newObj.key=oldObj.key;//错误:.key自动翻译为["key"]  //newObj["key"]=oldObj["key"];//错误:key是个变量，每循环一次，key的值可能发生变化，但是如果把变量key放入""中，就无法作为变量反复变化了。  newObj[key]=oldObj[key];//正确做法      }      return newObj;  }  var person2=clone(person); |
| 思考：clone(oldObject)，如果传递的对象是空或者不是一个数组？ |                                                              |

以上做法属于浅克隆，深克隆去小程序中学习：

  浅克隆：只克隆第一级属性，如果某个属性又是一个内嵌的子对象，不会进入子对象中克隆子对象的内容。     深克隆则可以进入子对象中，继续克隆内嵌子对象及内容。  

##### 3）用构造函数反复创建多个相同结构的对象

前两种创建对象的方式，一次只能创建一个对象。如果需要反复创建多个相同结构的对象时，代码会很繁琐。今后只要需要反复创建多个相同结构的对象时，都用构造函数来创建对象

① 写法：

  //1.0  定义一个构造函数，描述多个相同结构的对象的统一结构。  function 类型名(形参变量列表){  this.属性名=形参;  ......  this.方法名=function(){ ... }  ......  }  //2.0用new  调用构造函数，反复创建多个相同结构的对象。  var 新对象=new 构造函数名(属性值列表)  ……  

② 原理：new做了4件事: 

​     i     new先创建一个新的空对象

​    ii     自动为新对象添加"_ _proto_ _"属性，将"_ _ proto_ _"属性指向当前构造函数的原型对象。（祥见继承）

​    iii     调用构造函数，new自动将构造函数中的this指向正在创建的这个新对象。

F 所以构造函数中的this都指向要创建新对象

F 构造函数中每个this.属性名=形参，都在给新对象通过强行赋值新属性的方式，添加新属性。

F 所以，构造函数中所有要加入到新对象中的属性前都要加this.

F 构造函数中所有加this.属性名的属性，最终都会添加到新对象中

   iv     返回新创建的对象地址保存到=左边的对象名变量中

   

ex：

| 定义一个构造函数，来描述所有学生类型的对象的统一结构（要有学生姓名，学生年龄两个属性 以及自我介绍） |
| ------------------------------------------------------------ |
| //1.0  想定义一个构造函数，来描述所有学生类型的对象的统一结构  function Student(sname, sage){    this.sname=sname;    this.sage=sage;  this.intr=function(){console.log(`I'm ${this.sname}, I'm ${this.sage}`)}  }  //2.0   创建两个学生对象  var lilei=new Student("Li Lei",11);  var hmm=new Student("Han Meimei",12); |

### （3）继承

构造函数的优点虽然可重用结构代码，便于维护，但是构造函数却无法节约内存，反而浪费内存。因为，放在构造函数中的方法，会为每个子对象都反复创建一个函数对象的副本！

所以，将来在构造函数中就不应该包含方法定义！用继承来解决

l 继承：父对象中的成员，子对象无需重复创建，就可以直接使用，像自己的成员一样使用。

Ø 何时：只要多个子对象，希望共用同一个方法或属性，就可用继承方式来只定义一次，

反复使用——节约内存。

Ø 如何：js中的继承都是借助于原型对象实现的

##### 1）原型对象

l 原型对象：其实在创建每个构造函数时，都会自动附赠一个空对象，名为原型对象(prototype)

Ø 通过构造函数.prototype属性，可获得这个构造函数对应的一个原型对象。

  比如：想获得Student类型的原型对象： Student.prototype。  

Ø 当用构造函数创建对象时，new的第二步自动为新对象添加"_ _proto_ _"属性，

将"_ _ proto_ _"属性指向当前构造函数的原型对象。

  比如：如果var lilei=new Student("Li  Lei",11)  则new会自动: lilei._ _proto_  _=Student.prototype。  

Ø 凡是这个构造函数创建出的新对象，都是原型对象的孩子(子对象)

Ø 放在原型对象中的属性值或方法，所有子对象无需重复创建，就可直接使用。

2）原型对象的使用

① 为空的原型对象中添加共有的属性或方法: 强行赋值：

  构造函数.prototype.方法名=function(){      ...  ...   }  

② 原型对象中的方法子对象可以直接调用，像调用自己的方法一样

  子对象.原型对象中的方法名()  

  原理：js引擎会先在当前子对象中查找是否包含该方法。

F 如果找到，就优先使用当前子对象自己的方法

F 如果在当前子对象中没找到想用的方法，则自动延"_ _proto_ _"去父对象(原型对象)中查找方法使用。

③ 总结：今后，构造函数中应该只包含属性结构的定义

所有的方法，都应该强行添加到原型对象中，所有子对象共用一份——节约内存

注："原型对象"就是"父对象", "父对象"就是"原型对象"，都是同一个东西，只是称呼不同

原型对象是老外起的学名，父对象是为了大家理解简化的口语

ex：

| 为Student的原型对象中添加共有方法                            |
| ------------------------------------------------------------ |
| //1.0  想定义一个构造函数，来描述所有学生类型的对象的统一结构  function Student(sname, sage){   this.sname=sname;   this.sage=sage;   //从此构造函数中不要再包含任何方法定义了  }  //2.0 为所有学生的公共的父对象——原型对象中强行添加共有方法intr()   Student.prototype.intr=function(){   console.log(`I'm ${this.sname}, I'm ${this.sage}`)  }  //3.0 创建两个学生对象  var lilei=new Student("Li Lei",11);  //lilei.__proto__=Student.prototype //自动  var hmm=new Student("Han Meimei",12);  //hmm.__proto__=Student.prototype //自动  lilei.intr();hmm.intr();  console.log(lilei);console.log(hmm);  console.log(lilei.__proto__==Student.prototype);//true  console.log(hmm.__proto__==Student.prototype);//true |

总结this的四种情况：判断this，不要看定义在哪儿！！！只看被谁调用！！

  1. obj.fun()  fun中的this->.前的obj对象  2. new Fun()  Fun()中的this->new正在创建的新对象  3. 构造函数.prototype.方法=function(){ ... this ... }   原型对象方法中的this->将来调用这个方法的.前的某个子对象  4. 匿名函数自调或普通函数调用fun() 在没有.没有new时，this->默认指window  

ex：

| 判断this指的是？                                             |
| ------------------------------------------------------------ |
| <script>    (function(){ console.log(this) })();    function fun(){     console.log(this)    }    fun();  </script>  输出结果：  window  window |

补充

  函数也是一个对象，既保存函数体，同时也有自己的属性  <script>   function Student(sname, sage){    this.sname=sname;    this.sage=sage;   }   Student.prototype.intr=function(){    console.log(`I'm ${this.sname}, I'm ${this.sage}`)   }   console.log(Student);  //输出的是函数中保存的函数体内容，并不是函数对象在内存中的存储结果   console.dir(Student);  //输出一个对象在内存中的存储结构   </script>  以上两个输出的内容合起来，才是一个完整的函数对象。         

##### 3）自有属性和共有属性

l 自有属性：保存在子对象中，只归子对象独有的属性

l 共有属性： 保存在原型对象中，归当前类型下所有子对象共有的属性

Ø 获取属性值： 都可用"子对象.属性名"，无差别

Ø 修改属性值： 

| 如果修改一个子对象的自有属性 | 子对象.自有属性=新值             |
| ---------------------------- | -------------------------------- |
| 如果修改多个子对象共有的属性 | 构造函数.prototype.共有属性=新值 |

原理：

 

注：如果强行用子对象直接修改共有属性: 结果，原型队形中的共有属性保持不变，而是只给当前这一个子对象添加一个新的同名的自有属性。从此，这个子对象，因为已经有了同名的自有属性，就不会再使用共有属性。从此，共有属性变化，当前子对象的这个同名自有属性也不会跟随变化。从此，这个子对象和其他子对象，在这个属性的使用上，分道扬镳

 

ex：

| 修改共有属性                                                 |
| ------------------------------------------------------------ |
| <script>  function Student(sname,sage){    this.sname=sname,    this.sage=sage   }  Student.prototype.className="初一2班";  var dong=new Student("zhangdong",14);  var ran=new Student("liran",14);  console.log(dong);  console.log(ran);  console.log(dong.className,ran.className);  //过了一年，同学们升了一级  //错误做法：在子对象修改共有属性，相当于在子对象中添加一个新的自有属性  // dong.className="初二2班"  //正确做法：共有属性应在原型对象中修改  Student.prototype.className="初二2班";  console.log(dong.className,ran.className);  //过了一年，同学们又升了一级  Student.prototype.className="初三2班";  console.log(dong.className,ran.className);  </script> |

##### 4）内置类型的原型对象

l 内置类型/对象： ES标准中已经规定的，浏览器已经定义好的，我们可以直接使用的类型/对象。

Ø 共11种，其中9种都可以new。

  String   Number  Boolean —— 包装类型（扩展）  Array Date RegExp   Math(不是类型，而是一个对象，不能new)  Error  Function    Object  global(不是类型，而是一个对象，不能new，且在浏览器中被window代替)  除了标灰的两种之外，其余9种都可new  

Ø 凡是可以new的，都是构造函数。只要有构造函数，都会牵扯出一个大家庭，每个大家庭中，至少包含2个人。

F 构造函数(妈妈)：负责反复创建多个相同结构的子对象。

​        构造函数肚子里的属性，会成为将来子对象中的自有属性

F 原型对象(爸爸)：负责替该类型所有孩子集中保管共有的方法。

​        爸爸中有什么功能，孩子也有什么功能

 

① 内置类型Array： 包含2部分

| 构造函数 | function Array(){ ... 内部代码 看不见 ... }    |
| -------- | ---------------------------------------------- |
| 原型对象 | Array.prototyp：所有数组共用的函数，都放在其中 |

注：

如果想用的数组函数，原型对象中没有，可以自己手动向数组的原型对象中添加一个新函数，结果，将来所有数组家的孩子，都可用这个自定义的公共函数。

ex:

| 为数组家添加求和的函数sum                                    |
| ------------------------------------------------------------ |
| <script>  //Array实际上也是构造函数创建的对象  console.log(Array);//ƒ Array() { [native code] } 其中native code为内部代码，看不见  //Array的原型对象中的属性值或方法，所有子对象无需重复创建，就可直接使用  console.log(Array.prototype);  // length: 0  // constructor: ƒ Array()  // concat: ƒ concat()  // lastIndexOf: ƒ lastIndexOf()  // pop: ƒ pop()  // push: ƒ push()  // reverse: ƒ reverse()  // slice: ƒ slice()  // sort: ƒ sort()  // splice: ƒ splice()  // ........   // __proto__: Object （原型对象的父对象为Object）  var arr1=new Array(1,2,3,4);//arr1为Arryay的子对象可以使用父对象(原型对象)中的方法  //简写arr1=[1,2,3,4,5,6,7,8,9]  //如果原型对象中没有我们想要的方法，我们可以自定义。  //比如：为数组家添加一个可对数组内容求和的函数。  Array.prototype.sum=function(){  console.log(`调用Array.prototype中自定义的sum()`);   var result=0;   for(i=0;i<this.length;i++){//this: 指将来调用这个函数的某个数组家的孩子,  如： //arr1.sum()，则this->arr1       //arr2.sum()，则this->arr2   result+=this[i]   }   return result;  }  console.log(Array.prototype);//原型对象中就会多了个方法： sum: ƒ ()  console.log(arr1.sum());//子对象可以直接调用父对象(原型对象)中的方法   //输出结果：10  </script> |

##### 5）原型链

l 原型链：由多级父元素逐级继承形成的链式结构

Ø 保存着一个对象可用的所有属性和方法

Ø 控制着成员的使用顺序: 先自有，再共有

 

ex:

| 验证原型链:                                                  |
| ------------------------------------------------------------ |
| <script>    function Student(sname, sage){     this.sname=sname;     this.sage=sage;    }    Student.prototype.intr=function(){     console.log(`I'm ${this.sname},I'm ${this.sage}`)    }    var lilei=new Student("Li Lei",11);    console.log(lilei);    //lilei的爸爸是Student的老公    console.log(lilei.__proto__==Student.prototype);    //lilei的爷爷是Object的老公    console.log(lilei.__proto__.__proto__==Object.prototype)    //lilei的妈妈的爹是Function的老公    console.log(Student.__proto__==Function.prototype);    //lilei的妈妈的爹的爹是Object的老公    //     姥爷 的爹  爷爷    console.log(Student.__proto__.__proto__==Object.prototype);  </script>  输出结果：  ture  ture  ture |

### （4）多态

l 多态：同一个函数，在不同情况下表现出不同的状态。

Ø 包括2种情况: 重载和重写(override)

##### 1）重写

l 重写：子对象中定义了和对象中同名的成员。

何时：从父对象中继承的方法如果不是我们想要的就需要重写。

如何：只要在子对象中，定义和父对象中名称相同的一个成员，从此子对象再使用这个成

员时，都会优先使用自己定义的成员，而不再使用父对象的成员。

ex:

| 在自定义类型和对象中重写Object原型对象里的toString()方法     |
| ------------------------------------------------------------ |
| <script>  function Student(sname,sage){      this.sname=sname;      this.sage=sage;    }    var lilei=new Student("Li Lei",11);    var obj={x:1,x:2}    var arr=[1,2,3]    var now=new Date();    console.log(lilei);    console.log(lilei.toString());//[object Object]    console.log(obj.toString())//[object Object]    console.log(arr.toString())//1,2,3   //因为Array原型对象中toString的方法已经被重写    console.log(now.toString())//Mon Apr 27 2020 15:15:38 GMT+0800 (中国标准间)   // 因为Date原型对象中toString的方法已经被重写   //需求：所有学生类型的对象，都有toString可用，可输出学生的属性值      //在Student的原型对象中重写和父对象中同名的toString()方法    Student.prototype.toString=function(){     return `sname:${this.sname},sage:${this.sage}`    }    console.log(lilei.toString());//sname:Li Lei,sage:11   //需求：obj也有好用的toString()    var obj={ //new Object()     x:1,     y:2,     toString:function(){      return `{x:${this.x},y:${this.y}}`     }     };    console.log(obj.toString());//{x:1,y:2}  </script> |

##### 2）自定义

l 自定义继承：如果子对象觉得整个父对象都不好用，可以换爹：2种

Ø 只修改一个对象的父对象

Ø 同时修改多个子对象的爹

① 只修改一个对象的父对象

  方法一：子对象.__proto__=新父对象

​      不推荐：因为不是所有浏览器都开放__proto__让我们随意使用的。

  方法二：Object.setPrototypeOf(子对象, 父对象)

​      推荐：设置 原型 的 子对象 为 父对象

 ex:

| 仅修改hmm的爹                                                |
| ------------------------------------------------------------ |
| <script>    function Student(sname, sage){     this.sname=sname;     this.sage=sage;    }//赠: prototype->{ }    var lilei=new Student("Li Lei",18);    var hmm=new Student("Han Meimei",19);    var father={     bal:1000000000000,     car:"infiniti"    }    //hmm想用father中的成员,可让hmm继承father      //hmm.__proto__=father;    Object.setPrototypeOf(hmm, father);    console.log(lilei);    console.log(hmm);    console.log(hmm.bal, hmm.car);    console.log(lilei.bal, lilei.car);  </script>  输出结果: |

② 同时修改多个子对象的父对象

只要更换构造函数的prototype属性，指向新的原型对象即可

  构造函数.prototype=新原型对象  

时机: 应该在创建子对象之前就要更换。好处: 今后再创建的子对象，都自动继承新爹。

 

ex:

| 同时更换lilei和hmm的爹                                       |
| ------------------------------------------------------------ |
| <script>    var father={     bal:1000000000000,     car:"infiniti"    }    function Student(sname, sage){     this.sname=sname;     this.sage=sage;    }//赠: prototype->{ }    //先改构造函数的原型对象    Student.prototype=father;    father.constructor=Student;    //再创建子对象    var lilei=new Student("Li Lei",18);    var hmm=new Student("Han Meimei",19);    console.log(lilei);    console.log(hmm);    console.log(hmm.bal, hmm.car);    console.log(lilei.bal, lilei.car);  </script> |

 



 

## 4、ES5

ES5：ECMAScript语言（js语言的核心语法）标准的第五个升级版本。

   （学习ES5、ES6是不系统的，都是在给js语言打补丁，学的时候要各个突破）

### （1）严格模式

l 严格模式：比普通js运行机制要求更严格的模式

Ø 为什么：旧的js语言存在很多广受诟病的缺陷

Ø 何时：今后所有js程序，都要运行在严格模式下！

Ø 如何启用严格模式：在当前代码段的顶部添加字符串: "use strict";

Ø 新要求： 4个

F 禁止给未声明的变量赋值

F 静默失败升级为错误

F 普通函数调用和匿名函数自调中的this默认指undefined，而不再指window

F 禁止使用arguments.callee

##### 1）禁止给未声明的变量赋值

旧js：强行给未声明的变量赋值，会自动在全局创建该变量。

——极容易造成全局污染！

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 严格模式下，强行给未声明的变量赋值会报错。

ex：

| 旧js中，非严格模式下给未声明的变量赋值                       | 严格模式下，强行给未声明的变量赋值                           |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| <script>    // "use strict";//启用严格模式    function send(){     var gf;     qgf="今晚308, w84u";//不小心写错变量名了     console.log(gf)    }    send();    console.log(qgf);  </script>  输出结果： | <script>    "use strict";//启用严格模式    function send(){     var gf;     qgf="今晚308, w84u";//不小心写错变量名了，严格模式报错！     console.log(gf)    }    send();    console.log(qgf);   </script>  输出结果: |

##### 2）静默失败升级为错误

l 静默失败：执行不成功，但是还不报错！

——极其不便于调试

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 严格模式下，已经将所有的静默失败都升级为了错误。

——极其便于调试，避免歧义

ex：

| 在非严格模式下执行错误的操作                                 | 在严格模式下执行错误的操作                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| <script>    // "use strict";    var eric={     eid:1001,//只读     ename:"埃里克"    }    //暂时不要问,后边重点讲:     Object.defineProperty(eric,"eid",{     writable:false //设置eric的eid属性为不可修改——只读    });    //尝试修改eric的eid    eric.eid=1002;    console.log(eric);   </script>  输出结果： | <script>    "use strict";    var eric={     eid:1001,//只读     ename:"埃里克"    }    //暂时不要问,后边重点讲:     Object.defineProperty(eric,"eid",{     writable:false //设置eric的eid属性为不可修改——只读    });    //尝试修改eric的eid    eric.eid=1002;//报错:     //Cannot assign to read only property 'eid'     //不能给只读属性eid赋值    console.log(eric);   </script> |

##### 3）普通函数调用和匿名函数自调中的this默认指undefined

旧js：普通函数调用和匿名函数自调中的this默认指window

——增加导致全局污染的概率

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 严格模式下：普通函数调用和匿名函数自调中的this指undefined，而不再指window。

——大大减少了因为this导致的全局污染

ex：

| 在非严格模式下错误的使用构造函数                             | 在严格模式下错误的使用构造函数                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| // "use strict";  function Student(sname,sage){    this.sname=sname;    this.sage=sage;}  //正确使用构造函数的用法  var lilei=new Student("Li Lei",11);  console.log(lilei);  //错误的使用构造函数的用法  var hmm=Student("Han Meimei",12);  //Student前没有.也没有new，所以Student中的this暂时指window  //window.sname="Han Meimei"  //window.sage=12  console.log(hmm);  console.log(window.sname);  console.log(window.sage); | "use strict";  function Student(sname,sage){   this.sage=sage;   this.sname=sname;}//报错、、//Cannot set property 'sname' of undefined  //不能设置undefined的sname属性  //说明出错时this临时指向undefined  //正确使用构造函数的用法  var lilei=new Student("Li Lei",11);  console.log(lilei);  //错误的使用构造函数的用法  var hmm=Student("Han Meimei",12);  console.log(hmm);  console.log(window.sname);  console.log(window.sage); |

 

##### 4）禁止使用arguments.callee

l arguments.callee： 是在函数内部，获得当前函数本身的一种关键词

Ø 何时：递归

Ø 问题：如果在函数内递归调用时写死当前函数的函数名，则一旦当前函数名改变，总

要记得必须同时修改函数体中写死的函数名，一旦忘改就错了——紧耦合

Ø 解决：在函数内用arguments.callee自动获得当前函数对象本身，直接用当前函数对

象进行递归调用，与函数名无关了。

ex：

| 使用递归实现斐波那契数列                                     |
| ------------------------------------------------------------ |
| <script>    //斐波那契数列:     //1 1 2 3 5 8 13 21 34 55    //1 2 3 4 5 6 7 8 9 10    //数学公式: f(1)=1, f(2)=1, n>2时 f(n)=f(n-1)+f(n-2);    //人话: 第一个数是1， 第二个数也是1    //   从第三个数开始，每个数都是它相邻的前两个数的和    function f(n){     if(n<3){//如果n<3，则直接返回1      return 1;     }else{      var fun=arguments.callee;//自动获得当前函数本身这个对象      return fun(n-1)+fun(n-2);     }    }    //测试:     console.log(f(10));//55  </script> |

![*](file:///C:\Users\jiefe\AppData\Local\Temp\msohtmlclip1\01\clip_image001.gif) 严格模式要禁用arguments.callee：因为递归调用效率极低（重复计算量太大），所以严格模式强烈不建议使用递归调用: arguments.callee报错！今后多数递归调用都可用循环来解决。但是难度极高！

今后工作中，该用递归还是首先递归。——简单

​    除非递归在你的项目中却是影响效率了，才被迫找循环的方式代替

拓展： 

| 用循环实现斐波那契数列  |
| ----------------------- |
| 小程序->在线 搜斐波那契 |

 



 

### （2）保护对象

旧的js中的对象毫无自保能力，对象的结构和属性值可以被任意修改。ES5中，提供了保护对象属性和结构的新方法。

##### 1）保护对象的属性

阻止对对象的属性值进行不符合规定的篡改。

① 对象属性的开关

ES5中已经把每个对象的属性，变成了一个缩微的小对象

 

| value                   | 替对象实际保存属性值                                      |
| ----------------------- | --------------------------------------------------------- |
| writable:true/false     | 控制是否可修改属性                                        |
| enumeranle:true/false   | 控制是否可被for in遍历该属性                              |
| configurable:true/false | 控制2事件：控制是否可删除该属性  控制是否可修改前两个开关 |

获得对象中一个属性的描述小对象

  var 属性的描述对象=Object.getOwnPropertyDescriptor(对象, "属性名")  

修改对象属性的开关： 禁止使用.直接访问属性的开关，必须用专门的函数

| 修改一个对象的属性的开关                   | Object.defineProperty(对象, "属性名", {      开关名: true或false,      ...  : ...  })  defineProperty方法一次只能修改对象中一个属性的开关。如果多个属性都要需要修改开关，代码就会很繁琐 |
| ------------------------------------------ | ------------------------------------------------------------ |
| 用一个函数批量修改一个对象的多个属性的开关 | Object.defineProperties(对象, {      属性名:{      开关: true或false,      ...  : ...  },      属性名:{        ... : ...      },      ...  : { ... }  }) |

 

ex:

| 使用开关保护eric对象的属性（defineProperty()版本）           |
| ------------------------------------------------------------ |
| <script>    "use strict";    var eric={     eid:1001, //只读     ename:"埃里克", //不能删除     salary:12000 //不能随便用for in遍历}    //(了解)尝试获得eric对象中eid属性的描述对象    var eid_obj=Object.getOwnPropertyDescriptor(eric,"eid");    console.log(eid_obj);    //让eric的eid只读！    Object.defineProperty(eric,"eid",{     writable:false,     configurable:false //不允许再修改writable//不可逆    });    //让eric的ename属性禁止删除    Object.defineProperty(eric,"ename",{     configurable:false //不允许删除ename属性//不可逆    });    //让eric的salary属性不能随便被for in遍历    Object.defineProperty(eric,"salary",{     enumerable:false,     configurable:false //不允许修改enumerable开关//不可逆    });    //试图重新打开eid属性的writable开关    // Object.defineProperty(eric,"eid",{    //  writable:true,    //  configurable:true    // });     //报错: Cannot redefine property: eid  不能重定义属性eid     //试图修改eid属性值    //eric.eid=1002;//报错: Cannot assign to read only property 'eid'      //试图删除ename属性    //delete eric.ename;//报错: Cannot delete property 'ename'    //试图遍历eric所有属性，包括salary    for(var key in eric){     console.log(`${key} : ${eric[key]}`)    }//仅遍历到eid和ename两个属性，遍历不到salary属性    console.log(eric);    //强行用.访问salary属性    console.log(`eric的工资是:${eric.salary}`) //12000  </script> |

 

ex:

| 使用开关保护eric对象的属性 defineProperties()版本            |
| ------------------------------------------------------------ |
| <script>    "use strict";    var eric={     eid:1001, //只读     ename:"埃里克", //不能删除     salary:12000 //不能随便用for in遍历    }    //让eric的eid只读！    //让eric的ename属性禁止删除    //让eric的salary属性不能随便被for in遍历    Object.defineProperties(eric,{     eid:{      writable:false,      configurable:false //双保险，不可逆     },     ename:{      configurable:false     },     salary:{      enumerable:false,      configurable:false     }    })    //试图重新打开eid属性的writable开关    // Object.defineProperty(eric,"eid",{    //  writable:true,    //  configurable:true    // });     //报错: Cannot redefine property: eid不能重定义属性eid    //试图修改eid属性值    //eric.eid=1002;//报错: Cannot assign to read only property 'eid'                 //不能给只读属性赋值    //试图删除ename属性    //delete eric.ename;//报错: Cannot delete property 'ename'    //试图遍历eric所有属性，包括salary    for(var key in eric){     console.log(`${key} : ${eric[key]}`)    }//仅遍历到eid和ename两个属性，遍历不到salary属性    console.log(eric);    //强行用.访问salary属性    console.log(`eric的工资是:${eric.salary}`)  </script> |

② 访问器属性

  开关的保护功能很弱，不灵活，无法使用自定义的规则保护属性值。给程序的属性请保镖——访问器属性

l 访问器属性：不实际存储属性值，仅提供对另一个保存数据的属性的保护。

Ø 何时：今后，只要用自定义规则，灵活保护属性值时，都用访问器属性

Ø 如何：2步

​         i     定义访问器属性保护另一个保存数据的属性

第一步： 先将要保护的属性，隐姓埋名，半隐藏

第二步： 为受保护的属性，请保镖

​    （保镖要冒名顶替原属性名，保镖一请就是一对儿）

​         ii     通过访问器属性来操作受保护的数据属性

用访问器属性保护数据属性不是为了阻止大家使用，而是为了保证大家在合理的范围内使用属性，希望外界必须通过访问器属性来操作受保护的属性。所以，访问器属性的用法与普通的数据属性完全一样！并无差别！

  当外界想获得属性值时：  对象.访问器属性  

原理: 当外界试图获得属性值时，访问器属性会自动调用自己的get函数

  当外界想修改属性值时: 对象.访问器属性=新值  

原理: 当外界试图修改属性值时，访问器属性会自动调用自己的set函数，同时将=右边的新值，自动交给set函数的value形参变量，先验证，再保存到受保护的数据属性中

 

示例:

| 使用访问器属性保护对象的eage属性                             |
| ------------------------------------------------------------ |
| <script>     //要求年龄可修改，但是年龄必须介于18~65之间    var eric={     eid:1001,     ename:"埃里克",     _eage:25 //隐姓埋名 —— 不想让外人随意使用    }    Object.defineProperties(eric,{     _eage:{ //半隐藏      enumerable:false,      configurable:false     },     //请保镖:      eage:{//冒名顶替      //保镖一请就是一对儿      //专门负责从受保护的属性中，获取属性值      get:function(){       console.log("自动调用eage的get()")       //返回受保护的属性_eage的值       return this._eage;      },      //专门负责将要修改的新值，结果验证后，才保存到受保护的属性中      set:function(value){       console.log(`自动调用eage的set(${value})`)       if(value>=18&&value<=65){        this._eage=value;       }else{        throw Error(`年龄必须介于18~65之间！`)       }      },      enumerable:true, //让eage替_eage抛头露面      configurable:false //不能轻易删除保镖      //因为保镖不实际保存属性值，所以没有value属性      //因为writable开关无法灵活保护属性值，所以保镖也没有writable开关     }    })       //外界    //试图读取eric的年龄时    console.log(eric.eage)    //试图修改eric的年龄为26    eric.eage=26;    console.log(eric.eage)    //试图修改eric的年龄为-2    eric.eage=-2;   </script>  输出结果： |

访问器属性中的this: 

 

##### 2）保护对象的结构

保护对象的结构: 3种级别
 ① 防扩展：阻止为对象添加新属性

旧js中：可以随时给对象添加新属性

F 禁止为对象添加新属性：Object.preventExtensions(对象)

ex:

| 阻止为对象添加新属性                                         |
| ------------------------------------------------------------ |
| <script>    "use strict";    var eric={     eid:1001,     ename:"埃里克"    }    //希望eid只读    Object.defineProperty(eric,"eid",{     writable:false,     configurable:false    })    //防止对eric添加新属性:   Object.preventExtensions(eric);       //试图修改eid:     //eric.eid=1002;//报错: Cannot assign to read only property 'eid'    //          不能  赋值 给 读  只  属性   eid    //          不能给只读属性赋值    //试图为对象添加新的不同名的eid属性，另起炉灶    eric.Eid=1003; //报错:     //Cannot add property Eid, object is not extensible    // 不能 添加 属性  Eid(因为)对象是 不  扩展 可以    //                  不可扩展    console.log(eric);   </script> |

② 密封：既阻止给对象添加新属性，又阻止删除对象的现有属性

Ø 为什么：因为几乎对象中的所有属性，都应该是禁止删除的，但是每个属性都要写

configurable:false，太麻烦了！

Ø 何时：今后几乎所有的对象都要密封！

Ø 如何：Object.seal(对象)

Ø 原理：seal()做了两件事

​         i     自动调用Object.preventExtensions()阻止对当前对象的扩展

​         ii     自动为每个属性都添加configurable:false，从此我们不需要再手动为每个属性添加configurable:false

ex:

| 密封一个对象                                                 |
| ------------------------------------------------------------ |
| <script>    "use strict";       var eric={     eid:1001,     ename:"埃里克"    }    //希望eid只读，且不能删除    //希望ename也不能删除    Object.defineProperties(eric,{     eid:{      writable:false,      //configurable:false     },     // ename:{     //  configurable:false     // }    })    //密封对象:     Object.seal(eric)       //试图添加新属性:     //eric.Eid=1003;//报错:     //Cannot add property Eid, object is not extensible    //试图删除eid属性    //delete eric.eid; //报错: Cannot delete property 'eid'    //试图删除ename属性     //delete eric.ename; //报错: Cannot delete property 'ename'    console.log(eric);   </script> |

 

 

③ 冻结：既不能添加删除现有属性，又不能修改属性值

Ø 何时: 如果多个模块共用的对象，就不应该让某一个模块擅自修改对象的属性值，一旦

修改，牵一发而动全身。

Ø 如何: Object.freeze(对象)

Ø 原理: 做了三件事

​        i     也自动调用preventExtensions()阻止添加新属性

​       ii     也自动为每个属性添加configurable:false

​       iii     自动设置每个属性的writable:false

ex:

| 冻结对象                                                     |
| ------------------------------------------------------------ |
| "use strict";    var obj={     host:"192.168.0.100",     port:3306,     db:"xz" }    //希望obj对象中所有属性，禁止修改，禁止删除，且禁止给obj添加新属性    Object.freeze(obj);    //尝试给obj添加新属性:     //obj._host="127.0.0.1"; //报错: Cannot add property _hosts    //尝试删除obj中现有属性    //delete obj.host; //报错： Cannot delete property 'host'    //尝试修改obj中的host属性值:     //obj.host="localhost"; 报错Cannot assign to read only property'host' |

### （3）Object.create()

l Object.create() ：基于一个现有对象，创建新的子对象，来继承这个父对象

没有构造函数，也能创建子对象，继承父对象

Ø 何时: 没有构造函数时，也想创建子对象

Ø 如何: 

​         i     只创建子对象：

  var 子对象=Object.create(父对象)  

Object.create()做了两件事：创建一个新的空对象

自动设置新的空对象的__proto__继承父对象

​         ii     既创建子对象，又为子对象添加自有属性

  var 子对象=Object.create(父对象, {  //必须采用defineProperties函数同样的格式添加自有属性  自有属性名:{  value:属性值,  writable:true,  enumerable:true,  configurable:false  },  ………..  })  

Object.create()做了3件事：

​       创建一个新的空对象

​       自动设置新的空对象的__proto__继承父对象

​       为新对象添加自有属性

ex:

| 基于父对象，创建一个子对象，并为子对象添加自有属性           |
| ------------------------------------------------------------ |
| <script>    var father={     bal:1000000000,     car:"infiniti"    }    //创建一个子对象hmm，继承父对象father    var hmm=Object.create(father,{     //并为子对象hmm添加两个自有属性     bao:{      value:"LV",      writable:true,      enumerable:true,      configurable:false     },     phone:{      value:"浴霸",      writable:true,      enumerable:true,      configurable:false     }    });    console.log(hmm);    console.log(hmm.bal, hmm.car);    console.log(hmm.bao, hmm.phone);   </script>  输出结果： |

 

 

### （4）call/apply/bind

Ø call/apply/bind： 能替换函数中不想要的this为想要的对象

Ø 何时: 如果一个函数中的this不是你想要的，可以用call/apply/bind将this替换为想要对象

Ø 如何: 

​         i     只在调用函数时，临时替换一次this为指定的对象（call，apply）

​         ii     如果要调用的函数需要多个实参值，但是多个实参值却是放在一个数组中给的，出现不一致。

​        iii     基于原函数，创建一个新函数副本，并永久替换this（bind）

##### 1）call

只在调用函数时，临时替换一次this为指定的对象

  要调用的函数.call(替换this的对象, 实参值列表)  

原理：call做2件事

a）会调用一次该函数，并将实参值列表传递给函数的形参变量，用于函数内执行

b）在本次调用时，临时将函数中的this替换为一个指定的对象(call的第一个实参)

ex:

| 使用call替换一次函数中的this                                 |
| ------------------------------------------------------------ |
| <script>    //一个公共的计算薪资的函数    function jisuan(base, bonus1, bonus2){   //  底薪  奖金1  奖金2     console.log(`${this.ename}的总工资是:${base+bonus1+bonus2}`);}    //两个员工希望计算自己的薪资    var lilei={ename:"Li Lei"};    console.log(lilei);    var hmm={ename:"Han Meimei"};    //lilei想计算自己的薪资:    //jisuan(10000,2000,3000);//错误: this->window    //lilei.jisuan(10000,2000,3000);//报错: lilei.jisuan is not a function //因为李磊和lilei的原型链上都没有计算函数，所以李磊用不了jisuan()函数    //正确:     jisuan.call(lilei,10000, 2000, 3000);    //jisuan(   ↓  base bonus1 bonus2)    //    ...this.ename...    //call本意是打电话，程序中call指"调用"，所以，call会调用jisuan函数执行一次，并将call从第二个实参值开始的所有实参值传递给jisuan()的形参变量    //同时call会将jisuan()中的this，临时替换为lilei，调用后，恢复原样    //hmm也想计算自己的薪资:     jisuan.call(hmm,4000, 5000, 3000)    //      \|  ↓   ↓   ↓    //jisuan(  ↓ base bonus1 bonus2)    //   ...this.ename...   </script>  输出结果： Li Lei的总工资是:15000   Han Meimei的总工资是:12000 |

##### 2）apply

如果要调用的函数需要多个实参值，但是多个实参值却是放在一个数组中给的，出现不一致。可用apply代替call，既可替换this，又能打散数组参数

  要调用的函数.apply(替换this的对象, 数组 )  

原理: 

a). Apply拥有和call相同的功能，都能调用函数，并替换其中的this为指定对象

b). 但apply比call多一个功能，apply先打散数组为多个值，再传参！

何时用apply: 

只要要调用的函数需要多个实参值，但是多个实参却是放在一个数组中给的，出现了这种不一致！都要用apply，打散数组，再传参。

ex:

| 用apply替换this，并打散数组参数                              |
| ------------------------------------------------------------ |
| <script>    //一个公共的计算薪资的函数    //       底薪  奖金1  奖金2    function jisuan(base, bonus1, bonus2){     console.log(`${this.ename}的总工资是:${base+bonus1+bonus2}`);    }       //两个员工希望计算自己的薪资    var lilei={ename:"Li Lei"};    var hmm={ename:"Han Meimei"};    //lilei想计算自己的薪资，但是李磊的工资条是一个数组:    var arr=[10000,2000,3000];    jisuan.apply(lilei,    arr     );    //       \|   先打散arr为多个值    //       \|  10000, 2000, 3000    //       \|  ↓    ↓   ↓ 再传参    //jisuan(   ↓  base, bonus1, bonus2)    //     ...this.ename...    //apply英文中是使用的意思，所以具有call相同的功能    //但是比call多一个功能：打散数组后再传参    var arr2=[4000,5000,3000]    jisuan.apply(hmm,arr2);   </script>  输出结果：  Li Lei的总工资是:15000  Han Meimei的总工资是:12000 |

##### 3）bind

① 如果需要反复使用替换this后的函数，那么每次都.call(对象名)，就很繁琐。

用.bind()代替.call()，为指定对象创建一个专属的函数副本。永久绑定函数副本中的this为指定的对象。

  var 新函数名=原函数.bind(替换this的对象)  

原理：bind()会创建一个和原函数一模一样的新函数副本，原函数保持不变。只不过.bind()将新函数副本中的this，永久替换为指定的对象。将来反复调用新函数，即使不传入替换this的对象，也可以保证this为指定对象

② 如果部分实参值也可以永久固定不变，也可以用.bind()提前绑定到形参变量上

  var 新函数名=原函数.bind(替换this的对象, 固定不变的一个或多个实参值)  

原理：bind()会创建一个和原函数一模一样的新函数副本，永久绑定新函数副本中的this为指定对象，而且永久绑定一个或多个实参值到形参变量上。（可以绑定多个实参值，但是按顺序绑定）

强调：已经被.bind()永久绑定的实参值，将来调用函数时，无需重复传入。只要从后续未绑定的实参值继续传入即可！

何时使用bind()： 今后如果希望反复使用替换this后的函数时，不止使用一次，都要用.bind()代替.call()。

ex:

| 使用bind永久绑定函数的this                                   |
| ------------------------------------------------------------ |
| <script>    //一个公共的计算薪资的函数    //       底薪  奖金1  奖金2    function jisuan(base, bonus1, bonus2){     console.log(`${this.ename}的总工资是:${base+bonus1+bonus2}`);    }       //两个员工希望计算自己的薪资    var lilei={ename:"Li Lei"};    var hmm={ename:"Han Meimei"};    //lilei不想总是call(lilei)这么麻烦，于是想自己买一个专属的jisuan()函数    var js_lilei=jisuan.bind(lilei,10000);//没有输出，没有调用函数    //        复制函数副本,不改变原jisuan()函数    //js_lilei=function(base=10000, bonus1, bonus2){    // console.log(`${lilei.ename}的总工资是:${base+bonus1+bonus2}`);    //}    js_lilei(2000,3000);      //this->lilei    js_lilei(1000,2000);      //this->lilei    js_lilei(2000,2000);      //this->lilei    //hmm依然可以使用原来公共的jisuan()，不受影响    jisuan.call(hmm,3000,4000,2000)   </script>  输出结果：   Li Lei的总工资是:15000  Li Lei的总工资是:13000  Li Lei的总工资是:14000  Han Meimei的总工资是:9000 |

### （5）数组新增函数

数组新增函数有三大类：判断、遍历、过滤和汇总

##### 1）判断（2个）

###### ① 判断数组中是否包含符合条件的元素

| var  bool=arr.some(function(val){  return 判断条件  }) | a）some中封装了for循环，自动遍历数组中每个元素  b）每遍历一个元素，就自动调用一次回调函数，在调用回调函数时：自动将当前正在遍历的元素值传递给回调函数的形参val, 回调函数内判断当前元素值是否符合要求，并且返回判断结果  c）some函数会根据回调函数返回的判断结果，决定有没有必要继续向后执行  F 如果当前元素判断结果返回true，说明当前元素符合条件，则循环不再继续，整体返回true，说明找到了符合要求的元素  F 如果当前元素判断结果返回false，说明当前元素不符合条件，则循环继续向后执行。如果循环结束都没有找到符合要求的元素，则整体返回false，说明没找到符合条件的元素 |
| ------------------------------------------------------ | ------------------------------------------------------------ |
|                                                        |                                                              |

ex:

| 判断数组中是否包含符合条件的元素                             |
| ------------------------------------------------------------ |
| <script>    var arr1=[1,2,3,4,5];    var arr2=[2,4,6,4,2];    //想判断哪个数组包含偶数    var result1=arr1.some(function(val){     console.log(`arr1.some()自动调用了一次回调函数，val=${val},返回${val%2==0}`);     //val:自动接住当前元素值     //返回当前元素是不是偶数的判断结果     return val%2==0;    });    var result2=arr2.some(function(val){     console.log(`arr2.some()自动调用了一次回调函数，val=${val},返回${val%2==0}`);     return val%2==0;    })    console.log(result1, result2)  </script>  输出结果: |

###### ② 判断数组中是否所有元素都符合条件

| var bool=arr.every(function(val){      return  判断条件  }) | a）every中封装了for循环，自动遍历数组中每个元素  b）每遍历一个元素，就自动调用一次回调函数，在调用回调函数时：自动将当前正在遍历的元素值传递给回调函数的形参val，回调函数内判断当前元素值是否符合要求，并且返回判断结果  c）every函数会根据回调函数返回的判断结果，决定有没有必要继续向后执行：  F 如果当前元素判断结果返回false，说明当前元素不符合条件，则循环结束，并整体返回false，说明当前数组不是所有元素都符合要求  F 如果当前元素判断结果返回true，说明当前元素符合条件，则循环继续执行。如果可以走到最后一个元素，而中途不退出循环，则说明所有元素都符合要求，则整体返回true。 |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
|                                                             |                                                              |

ex:

| 判断数组是否全由偶数组成                                     |
| ------------------------------------------------------------ |
| script>    var arr1=[1,2,3,4,5];    var arr2=[2,4,6,4,2];    //想判断哪个数组全由偶数组成    var result1=arr1.every(function(val){     console.log(`arr1.every()自动调用了一次回调函数，val=${val},返回${val%2==0}`);     //val:自动接住当前元素值     //返回当前元素是不是偶数的判断结果     return val%2==0;    });    var result2=arr2.every(function(val){     console.log(`arr2.every()自动调用了一次回调函数，val=${val},返回${val%2==0}`);     return val%2==0;    })    console.log(result1, result2)   </script>  输出结果： |

##### 2）遍历（2个）

###### ① 仅单纯遍历原数组中每个元素

| arr.forEach(function(val){      对val的操作  }) | a）forEach中也自带for循环，自动遍历数组数组中每个元素  b）每遍历一个元素就自动调用一次回调函数，并自动将当前元素值传入回调函数的形参val  c）在回调函数中对当前元素执行操作 |
| ----------------------------------------------- | ------------------------------------------------------------ |
|                                                 |                                                              |

普通for循环vs forEach

|                  | 普通for循环                                                  | forEach                                                 |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------- |
| 是否可更简化     | 固定写法，几乎不可简化                                       | 可用箭头函数简化                                        |
| 灵活性           | 极其灵活: 可改变遍历顺序(反向遍历)，可改变遍历的步调，可随时break退出循环 | 不够灵活: 只能从前向后挨个遍历，且不支持break随时退出。 |
| 可遍历的对象类型 | 可遍历一切数字下标的东西: 索引数组和类数组对象都行(都是数字下标) | 数组家函数，只能被索引数组使用。类数组对象无法使用      |
| 结论             | 绝大多数循环都不需要改变遍历的顺序和步调，所以，能用forEach，当然用forEach简写。除非特殊循环，才被迫改用for循环。 |                                                         |

ex:

| 点名                                                         |
| ------------------------------------------------------------ |
| <script>    var arr=["亮亮","然然","东东"];    //用for:没有可再简化的空间了    // for(var i=0;i<arr.length;i++){    //  alert(`${arr[i]} - 到！`);    // }    //用forEach:    arr.forEach(function(val){     console.log(`arr.forEach()自动调用了一次回调函数，自动传入val=${val}`);     alert(`${val} - 到！`);    })    //简写: //暂时不要问！    //arr.forEach(val=>alert(`${val} - 到！`));   </script> |

###### ② 遍历元素数组中每个元素，修改后，放入新数组中返回

| var 新数组=arr.map(function(val){  return 根据当前元素值val，修改后的一个新值  }) | a）arr.map()先创建一个新的空数组等着  b）然后再开始遍历原数组中每个元素  c）每遍历到一个元素，就自动调用一次回调函数，每次调用时，也会自动将当前元素值传入回调函数的形参变量val中  d）回调函数内部，根据传入的当前元素值val，修改得到一个新值，并返回给主函数map  e）map()会将回调返回的新值自动加入到新数组中相同位置  f）遍历结束后，map()返回装满新值的新数组，原数组保持不变 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

ex:

| 动态生成页面元素                                             |
| ------------------------------------------------------------ |
| <!-- 动态生成页面元素 如下列表，而是根据传入的数据不同而变化 -->    <ul id="scores">      <!-- <li>85</li>      <li>88</li>      <li>99</li>      <li>65</li> -->    </ul>    <script>      var arr=[85,88,99,65];      //方法一：用for      //先创建一个空字符串，等着接每个数组元素转化后的li元素      // var html="";      // 遍历数组中每个元素      // for(var i=0;i<arr.length;i++){      // 每遍历一个元素，就将当前元素变成li的样子，拼接到html变量中      // html+=`<li>${arr[i]}</li>`      // }      //方法二：用map      //遍历裕原数组arr，将原数组中的每个元素都变成一个<li>元素，并放入到新数组arr2中返回      var arr2=arr.map(      //var newArr=[];      function(val){      // console.log(`arr.map()自动调用了一次回调函数，自动传入val=${val}，返回新值"<li>${val}</li>"，放入新数组中`)        return `<li>${val}</li>`      });      console.log(arr);  //[85, 88, 99, 65]      console.log(arr2);  //["<li>85</li>", "<li>88</li>", "<li>99</li>", "<li>65</li>"]      //将新数组中每个<li>字符串无缝拼接为一个完整的多个<li>相连的字符串      var html=arr2.join("");      //方法三: 最简化版本: //不要问为什么      //var html=arr.map(val=>`<li>${val}</li>`).join("");         console.log(html);  //<li>85</li><li>88</li><li>99</li><li>65</li>      var ulScores=document.getElementById("scores")      ulScores.innerHTML=html;      </script> |

 

##### 3）过滤和汇总

###### ① 过滤

l 过滤（filter）：复制出原数组中符合条件的元素组成新数组返回，原数组保持不变 

​    何时: 只要想仅获得数组中所有符合条件的元素时，都用过滤

​    如何:

| var  新数组=arr.filter(function(val){  return 判断条件  }) | a）arr.filter()先创建一个新的空数组等着  b）然后arr.filter()才开始遍历数组中每个元素  c）没遍历一个元素就自动调用一次回调函数，并将当前元素值自动传入回调函数形参val中  d）回调函数内判断当前元素是否符合要求，并返回判断结果  e）Filter根据会回调函数返回的判断结果，决定，只有那些符合条件的元素，才会被复制一个副本，然后追加到新数组中返回  f）当遍历结束，filter返回新数组，原数组保持不变 |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
|                                                            |                                                              |

ex:

| 过滤出数组中的偶数                                           |
| ------------------------------------------------------------ |
| var arr=[1,2,3,4,5];    //只希望获得数组中的偶数    var arr2=arr.filter(function(val){     console.log(`arr.filter自动调用了一次会回调函数，并传入val=${val}，返回${val%2==0}`)                                                                                       //只有那些%2==0的偶数元素，才希望加入新数组中返回     return val%2==0    })    console.log(arr2);    console.log(arr); |

###### ② 汇总

l 汇总（reduce）：遍历数组中每个元素，对所有元素进行统计，最终得出一个统计结果。

Ø 何时： 今后只要希望根据数组中的内容，统计出一个结果时，就用汇总

Ø 如何： (仅以数组元素求和来举例)

| var  统计结果=arr.reduce(  function(prev, val){  prev+=val;  return prev  },  起始值  ) | a）Reduce开始执行时，会将起始值保存在一个变量prev中  b）然后才开始遍历数组中每个元素  c）每遍历一个元素，就自动调用一次回调函数，并启动传入2个值！变量prev中的临时汇总值，会交给形参prev；当前元素值交给形参val。  d）回调函数中应该将当前元素值累加到临时汇总值prev变量上。并返回新的临时汇总值  e）Reduce会将回调函数返回的新的汇总值保存到变量prev上，供下一轮汇总使用  e）当循环结束后，reduce会返回变量prev中保存的最终的汇总值 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

ex:

| 对一个数组中的元素求和                                       |
| ------------------------------------------------------------ |
| <script>    var arr=[1,2,3,4,5];    var result=arr.reduce(     function(prev,val){      console.log(`arr.reduce()自动调用一次回调函数，并自动传入截止到当前的临时汇总值prev=${prev}，同时传入当前元素值val=${val}，计算prev+=val，并返回新汇总值prev=${prev+val}，为下一轮循环继续汇总下一个元素做准备`)      prev+=val; //将当前元素累加到临时汇总值prev中      return prev //必须: 返回这次的新的临时汇总值，共下一轮使用     },     0 //从0开始累加，强烈不建议省略    );    console.log(result);//15   </script>         输出结果:  arr.reduce()自动调用一次回调函数，并自动传入截止到当前的临时汇总值prev=0，同时传入当前元素值val=1，计算prev+=val，并返回新汇总值prev=1，为下一轮循环继续汇总下一个元素做准备  arr.reduce()自动调用一次回调函数，并自动传入截止到当前的临时汇总值prev=1，同时传入当前元素值val=2，计算prev+=val，并返回新汇总值prev=3，为下一轮循环继续汇总下一个元素做准备  arr.reduce()自动调用一次回调函数，并自动传入截止到当前的临时汇总值prev=3，同时传入当前元素值val=3，计算prev+=val，并返回新汇总值prev=6，为下一轮循环继续汇总下一个元素做准备  arr.reduce()自动调用一次回调函数，并自动传入截止到当前的临时汇总值prev=6，同时传入当前元素值val=4，计算prev+=val，并返回新汇总值prev=10，为下一轮循环继续汇总下一个元素做准备  arr.reduce()自动调用一次回调函数，并自动传入截止到当前的临时汇总值prev=10，同时传入当前元素值val=5，计算prev+=val，并返回新汇总值prev=15，为下一轮循环继续汇总下一个元素做准备  15 |

 

## 5、ES6

ES5：ECMAScript语言（js语言的核心语法）标准的第六个升级版本。

### （1）模板字符串（重点）

l 模板字符串：支持换行和动态生成内容的特殊字符串（用于替换）

Ø 为什么： 替换用用+实现的字符串拼接，因为传统的用+实现的字符串拼接和算数计算

的加法极容易混淆

Ø 何时: 今后，只要动态拼接字符串，都要用模板字符串代替普通的+拼接

Ø 如何:

​         i     整个模板字符串必须用一对儿反引号包裹`——键盘左上角ESC正下发那个按键

​         ii     在模板字符串中支持换行

​        iii     模板字符串中用js变量和表达式动态生成的部分，必须用${}包裹

Ø 强调：模板字符串最终也是一个普通的字符串，只不过需要动态拼接内容而已。所以，

能用字符串的地方，都能用模板字符串。

Ø 模板字符串中${}里都能放什么：

F 能放: 变量、各种计算/比较等js表达式、三目、访问数组元素、调用方法，可以创建对象——凡是有返回值的合法的js表达式，都可放在${}中

F 不能放: 程序结构(分支和循环)以及没有返回值的js表达式

ex:

| 对一个数组中的元素求和                                       |
| ------------------------------------------------------------ |
| <script>    var uname="dingding";    var sex=1;    var count=5, price=12.5;    var orderTime=1588140934056;//下单时间    var week=["日","一","二","三","四","五","六"]    //     0  1  2  3  4  5  6    console.log(`     用户名: ${uname},     性别: ${sex==1?"男":"女"},     小计: ¥${(count*price).toFixed(2)},     下单时间: ${new Date(orderTime).toLocaleString()},     今天星期${week[new Date().getDay()]}    `)   </script>  输出结果:  用户名: dingding,  性别: 男,  小计: ¥62.50,  下单时间: 2020/4/29 下午2:15:34,  今天星期三 |

### （2）let

l let：专门代替var来声明变量的新的关键词

Ø 为什么：var存在缺陷 

F var会被声明提前——打乱程序正常的执行顺序

F var没有块级作用域——代码块(分支和循环)内的变量很有可能影响块外的代码

Ø 何时用let：今后几乎所有的var，都会被let代替！

Ø let的优点

F 不会被声明提前

F 为js程序增加了块级作用域(分支和循环的{}从此也变成了一级作用域)

Ø let的原理

F let会被自动翻译为匿名函数自调！形成一级临时的作用域，就阻止了变量被声明提前

F 双保险: let在底层根据需要自动改变变量名

Ø 总结: let=匿名函数自调+自动修改变量名

ex:

| 使用let代替var                                               |
| ------------------------------------------------------------ |
| <script>    var t=0;//全局变量，准备累计每个函数的执行时间    function f1(){     console.log(`f1执行耗费0.3s`)     t+=0.3;    }    function f2(){        console.log(`f2执行耗费0.8s`)     t+=0.8;     //今后维护中，增加了一段新代码(不要纠结代码的意义！)     var err=true;     if(err==true){//也成了作用域      //var t=new Date();//旧的做法,会被声明提前，也没有块作用域      //(function(){      let t=new Date();//好的做法，不会被声明提前，也有了块作用域      //var _t=new Date();      console.log(`出错啦！at:${t.toLocaleString()}`)      //console.log(`出错啦！at:${_t.toLocaleString()}`)      //})();     }    }    f1(); f2();    console.log(`共耗时${t}s`);   </script>  输出结果：  f1执行耗费0.3s  f2执行耗费0.8s  出错啦！at:2020/4/29 下午3:20:00  共耗时1.1s |

Ø let的小脾气 

F 在全局let一个变量，这个变量也不会保存在window中！

F 不能在let创建一个变量前，提前使用该变量，会报错

F 同一作用域内不允许重复let两个同名的变量

Ø const:

F const原本是专门声明常量(值不能改变的变量)的关键词——第一阶段讲过

F 随着es6标准的提出，let具有的特征，const也具有了，只不过const的变量值不能改变而已

F 但是const的效率稍微比let高一点儿，所以，如果将来一个变量的值不会再改变，则首选用const声明。——也不是必须

ex:

| let和const的小脾气                                           |
| ------------------------------------------------------------ |
| <script>    var a=10;    let b=100;    //(function(){      //var _b=100;    //})();    console.log(window); //window中没有b       //在let之前不能提前使用let声明的变量    console.log(c); //不报错,而是undefined    var c=10;    //console.log(d); //报错:     //Cannot access 'd' before initialization    // 不能  访问  d 在...前 初始化(第一次创建变量并赋值)    // 不能在创建变量之前是调用d变量    //let d=100;    //(function(){     //var _d=100;    //})();       let e=10;    //let e=100;//报错:    //Identifier 'e' has already been declared    //标识符/变量名e  已经    被  声明过了       const f=100;    console.log(window); //window中没有f    f=101;//报错: Assignment to constant variable    //       赋值   给 固定不变的 变量    //    (不能)给常量赋值   </script> |

### （3）箭头函数

l 箭头函数：专门简化所有函数的新定义函数的语法

Ø 为什么: 主要因为总是写function，太繁琐！

Ø 何时: 今后几乎程序中是看不到任何function的！

Ø 如何: 3句话:

​         i     去掉function，在()和{}之间加"=>"

​         ii     如果只有一个形参变量，则可以省略()，但是如果没有形参时，不能省略()

​        iii     如果函数体只有一句话，可省略{}，和结尾的;

​          如果仅有的一句话还是return，则必须省略return！

Ø 剪头函数特点: 箭头函数的内部this和外部的this保持一致！

F 如果希望函数中的this与函数外的this保持一致时（代替bind），或函数中根本不涉及this时，才能随意改为箭头函数！

F 如果今后函数中的this刚好不希望与外部this保持一致时，就不能用箭头函数简写！

| ex：使用箭头函数代替function                                 |
| ------------------------------------------------------------ |
| <script>    var add=(a,b)=> a+b;  console.log(add(3,5));//8    (()=>console.log(`我是匿名函数自调!`))();    var arr=[12,3,123,2,1,23];    arr.sort((a,b)=>a-b)  console.log(arr);       var str="you can you up";    str=str.replace(/\b[a-z]/g,kw=>kw.toUpperCase())    console.log(str);       var arr=["亮亮","然然","东东"];    arr.forEach(val=>console.log(`${val} - 到！`))       var arr=[96,72,85,65,56];    var arr2=arr.map(val=>`<li>${val}</li>`)    console.log(arr2);       var n=10;    var timer=setInterval(()=>{     console.log(n);     n--;     if(n==0){      console.log("boom!");      clearInterval(timer);     }    },1000)  </script> |

ex:

| 箭头函数内外this保持一                                       |
| ------------------------------------------------------------ |
| <script>    //全局this->window    var lilei={//对象的{}本来就不是墙！所以也拦不住this！     sname:"Li Lei",     friends:["亮亮","然然","东东"],     //intr:function(){//是墙——可以拦住this     //ES6新规定，所有对象的方法可省略":function"     //但是，省略了:function的方法，绝不等于箭头函数！只是单纯的简写而已！不改变this！     intr(){//还是墙——可以拦住this      this.friends.forEach(       //function(val){//是作用域——墙，隔绝内外this无法保持一致       val=>{//不是墙，拦不住this了！        console.log(`${this.sname} 认识 ${val}`)       }      )     }    }    lilei.intr();  </script> |

### （4）for of

l for of：专门对普通for循环的简写

Ø 何时: 只有那些从头到尾正向遍历所有元素的标准for循环才能用for of简写

Ø 如何: 

| for(var 变量 of 索引数组或类数组对象或字符串){  ... ...   } | of会自动遍历后边数组或类数组对象中每个元素的元素值，依次保存到of前的变量中。但是of无法获得下标位置！所以操作中涉及下标位置的循环，也不能用for of简写。 |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
|                                                             |                                                              |

Ø for of的局限：

​         i     只能从头到尾正向遍历，无法改变遍历的顺序

​         ii     只能逐个遍历数组中的每个元素，无法隔着蹦着遍历

​        iii     无法在遍历时获得当前正在遍历到的下标位置

Ø 总结: 遍历：

|                      |               | for循环 | for of | arr.forEach | for in |
| -------------------- | ------------- | ------- | ------ | ----------- | ------ |
| 数字下标  有规律     | 索引数组      | √       | √      | √           |        |
| 类数组对象           | √             | √       |        |             |        |
| 字符串               | √             | √       |        |             |        |
| 自定义下标  没有规律 | 关联数组/对象 |         |        |             | √      |

 

ex:

| 用for of遍历数组，类数组对象和字符串                         |
| ------------------------------------------------------------ |
| <script>    var arr=["亮亮","然然","东东"];    //     0   1   2    for(var ename of arr){     //if(ename!=="然然")      console.log(`${ename} - 到！`)     //else       //break; //支持break    }    function add(){     var sum=0;     for(var n of arguments){      sum+=n;     }     return sum;    }    console.log(add(1,2,3,4,5));//15    var str="hello";    //    01234    for(var c of str){     console.log(c);}  </script> |

### （5） 参数增强

l 参数增强：ES6对函数参数的使用提供了一些新的方法

##### 1）参数默认值

Ø 何时: 即使调用函数时，没有传入实参值，也希望形参变量又默认值使用时

专门解决仅最后一个形参变量不确定有没有的情况

Ø 如何: function 函数名(形参变量=默认值, ... , ...){ ... }

Ø 结果: 

​         i     如果将来调用这个函数时，提供了实参值，则形参变量采用用户提供的实参值

​         ii     如果将来调用这个函数时，没有提供实参值，则形参变量自动采用提前准备好的默认值当备胎。

| ex:使用参数默认值                                            |
| ------------------------------------------------------------ |
| <script>    function intr(msg="主人很懒，什么也没有留下"){     document.write(`<h1>然哥的自我介绍: ${msg}</h1>`)    }    intr("日照香炉生紫烟");    intr();  </script> |

参数默认值的局限性：

| ex: 局限: 通常只能解决最后一个实参值不确定有没有的情况。如果多个形参都不确定有没有，单靠参数默认值时无法解决的，比如: |
| ------------------------------------------------------------ |
| <script>    //定义一个点餐函数order，让用户可以快速点默认套餐，也可以自由搭配。    //其实，这个需求: 多个形参都不确定有没有时，是不能用参数默认值来解决。    //应该用: 明天再讲！    function order(zhushi="香辣鸡腿堡",xiaochi="薯条",yinliao="可乐"){     console.log(`您点的套餐是:      主食:${zhushi},      小吃:${xiaochi},      饮料:${yinliao}     `)    }    order();//只想要套餐默认的搭配    order("鳕鱼堡","菠萝派","雪碧");//想把套餐中的默认搭配都换掉    order("奥尔良烤腿堡");//只想换第一个主食    order("巨无霸","土豆泥");//只想换主食和小吃       //order(,,"奶茶")//只想换饮料！报错！    //order("","","奶茶")//也不对！  </script> |

##### 2）剩余参数

l 剩余参数：专门代替arguments来处理不确定实参值个数的情况

Ø 为什么: arguments问题

​        a. 箭头函数不支持arguments

​        b. 是类数组对象，不是数组家孩子，用不了数组家的函数

​        c. 只能获取所有实参值，不能有选择的获得部分实参值

​        d. 名字太长，且下标没有意义。

Ø 何时: 今后只要不确定传入函数的实参值个数时，都用剩余参数语法代替arguments

Ø 如何: 在定义函数时，形参变量列表中: 

  function 函数名(形参1, 形参2, ...数组名){  //...专门负责收集  除前几个形参已经匹配的实参值之外的  所有多余的实参值      //如果没有之前的形参，则...也可以获得所有实参值。      //...会将收集到的所有实参值，放入一个自定义名称的标准的数组中！  }  

Ø 优点: 

​        a. 箭头函数支持剩余参数语法

​        b. 是标准的数组，剩余参数可使用数组家的所有函数

​        c. 只能获取所有实参值，不能有选择的获得部分实参值

​        d. 名字太长，且下标没有意义。

ex:

| 使用剩余参数计算多个数的和，以及计算工资                     |
| ------------------------------------------------------------ |
| <script>  //计算不确定个数的数值的和  // var add=(...nums)=>{  //  var sum=0;  //  //for(var n of arguments){//报错: arguments is not defined  //  for(var n of nums){  //   sum+=n;  //  }  //  return sum;  // }  var add=(...nums)=>nums.reduce((prev,val)=>prev+val,0);  console.log(add(1,2,3,4,5))//15  //计算薪资: 要求必须输入员工姓名，但是工资由几部分组成，不确定  function jisuan(ename ,...arr){   console.log(`${ename}的总工资是:${    arr.reduce((prev,val)=>prev+val,0)   }`)  }  //调用时:  jisuan(    "Li Lei",10000,2000,3000)  jisuan(  "Han Meimei",3000,4000,5000,1000)  </script> |

##### 3）打散spread

l 打散（spread）：先将数组打散为多个值，然后再分别传给函数的形参变量。

Ø 何时：当调用函数时，函数本来需要多个实参值，但是，给定的实参值确实放在一个

   数组中给的，发生了不一致。就要先打散数组为多个值，再分别传给函数的形

参变量

Ø 如何：调用函数时 

| 函数名(...数组); | 执行过程: ...先将数组打散为多个值，然后再将打散后的多个值分别一对一传给函数的形参变量 |
| ---------------- | ------------------------------------------------------------ |
|                  |                                                              |

Ø 总结

​        a. 定义函数时，形参变量列表结尾的...arr是收集剩余实参值放入数组中的意思

​        b. 调用函数时，实参值列表结尾的...arr是打散数组再传参的意思

ex：

| 先打散数组再传参                                             |
| ------------------------------------------------------------ |
| <script>    function jisuan(ename,base,bonus1,bonus2){     console.log(`${ename}的工资明细是:      底薪:${base}, 奖金1:${bonus1}, 奖金2:${bonus2}      总计: ${base+bonus1+bonus2}`);}    var arr=[10000,2000,3000];    jisuan("Li Lei", ...arr);  </script> |

### （6）解构

l 解构：从一个大的对象或数组中仅提取出个别属性或方法单独使用——简化程序

Ø 为什么: 

​         i     访问数组中一个元素值，比如: 数组名[下标]，但是这种语法麻烦，且下标是数字，没有意义

​         ii     访问对象中的属性或方法时，总要带着"对象名."前缀，很麻烦

Ø 何时: 今后如果只想使用一个大的对象或数组中的个别成员时，就用解构

Ø 如何: 分为数组解构、对象解构、参数解构

##### 1）数组解构

l 数组结构：从一个大的数组中提取出个别元素值单独使用

Ø 如何：

  //先将要接收元素值的所有变量，装扮成一个数组的样式  var [变量1, 变量2, ...]=数组  //相同下标位置的变量，自动收到数组中相同下标位置的元素值  变量1=数组[0]  变量2=数组[1]  ... = ...  从此，数组中某个元素值，就可以脱离开数组，以变量方式单独使用  

ex：

| 从数组中解构出年月日                                         |
| ------------------------------------------------------------ |
| <script>    var arr=[2020,4,30];    //从数组中解构出年，月，日，分别保存在三个变量,y,m,d中    //var   [ y ,m,d ]=arr;    //console.log(`今天是${y}年${m}月${d}日`);    //如果只要月和日    var   [  ,m,d ]=arr;    console.log(`今天是${m}月${d}日`);  </script>  今天是4月30日 |

##### 2）对象解构

l 对象结构：从一个大的对象中提取出个别成员单独使用

Ø 如何：

  //先将要接收对象成员的变量装扮成和对象完全相同的结构  var{属性名: 变量1, 属性名: 变量1, ……..}=对象  //等号左边{}中相同属性名的变量会自动获得等号右边相同属性名的属性值。  注：如果等号左边写的属性名，等号右边的对象中没有，则不会报错，而是返回undefined而已。  

Ø 简写: 如果对象中原来的属性名或方法名已经很好了，不需要改名，则解构时，等号左边的{}中每个属性只写一个名字就够了。

  var {成员名1, 成员名2, ...}=对象  //{}中的每个成员名，一个名字两用: 既当做属性名配对，又当做变量名接受属性值，所以将来对象解构时，属性名和变量名只写一个名字就够了  

ex：

| 仅解构出user对象中的uname属性值和logout方法                  |
| ------------------------------------------------------------ |
| <script>    var user={     uname:"dingding",     email:"dingding@tedu.cn",     phone:"18301092802",     //login:function(){//ES6中可以简写     login(){console.log(`登录...`) },     changePwd(){ console.log(`修改密码...`) },     logout(){console.log(`注销...`) }    }    //  属性名 : 变量名    //   配对  接属性值    //var {uname:uname, logout:logout}=user;    var {uname,logout}=user;//ES6简写    //一个名字两用: 既当做属性名配对，又当做变量名接受属性值，所以将来对象解构时，属性名和变量名只写一个名字就够了。    console.log(`欢迎:${uname}`);  logout();//注销  </script> |

##### 3）参数解构

l 参数解构：其实就是对象解构在函数传参时的应用

Ø 何时：如果多个形参变量不确定将来有没有值，而且又要求传入的实参值，必须传给

指定的形参变量，不能错位。

Ø 如何：2步

  //1.0定义函数时，所有的形参变量都要放在一个对象结构中，将形参列表装扮成对象的样子  function 函数名({    //   配对   : 变量名      属性名1: 形参名1,      属性名2: 形参名2,  }){  //函数体  }  //2.0调用函数时：实参值列表也要装扮成对象，且实参值列表中对象结构的属性名，应该和定义函数时形参列表中的属性名对应  函数名({  //  配对 : 值  属性名1: 实参值1,  属性名2: 实参值2,  })  

Ø 结果：当调用函数时，实参值对象中相同属性名的实参值，自动赋值给函数的形参对

象中相同属性名对应的形参变量。比如：

形参名1=实参值1

形参名2=实参值2

Ø 简写：通常情况下因为配对的属性名和形参变量名名称相同。所以，定义函数时，保

   对象结构中，只写一套名字即可！一套名称两用：

  function 函数名({  //既配对又变量名      属性名1,      属性名2  }){  //函数体  }  

ex：

| 定义一个订套餐的函数，用户可以随意更换套餐中的各个部分       |
| ------------------------------------------------------------ |
| <script>    //定义一个点餐函数order，让用户可以快速点默认套餐，也可以自由搭配。    //其实，这个需求: 多个形参都不确定有没有时，是不能用参数默认值来解决。    //应该用: 明天再讲！    // function order({    // // 配对  形参变量    //  zhushi:zhushi,    //  xiaochi:xiaochi,    //  yinliao:yinliao    // }){    // function order({zhushi, xiaochi, yinliao}){    //  //默认值: (短路)    //  //条件满足     才  执行    //  zhushi===undefined&&(zhushi="香辣鸡腿堡")    //  xiaochi===undefined&&(xiaochi="薯条")    //  yinliao===undefined&&(yinliao="可乐")    function order({zhushi="香辣鸡腿堡",xiaochi="薯条",yinliao="可乐"}){                                                                               console.log(`您点的套餐是:      主食:${zhushi},      小吃:${xiaochi},      饮料:${yinliao}     `)    }  order({});//只想要套餐默认的搭配，  即使什么都不该，也必须传一个空对象                                                                               order({                 zhushi:"鳕鱼堡",    xiaochi:"菠萝派",    yinliao:"雪碧"  });//想把套餐中的默认搭配都换掉        order({    zhushi:"奥尔良烤腿堡"                                                                                 });//只想换第一个主食  order({    zhushi:"巨无霸",    xiaochi:"土豆泥"  });//只想换主食和小吃  order({//只想换饮料！报错！     yinliao:"奶茶"    })  order({//只想换小吃！     xiaochi:"鸡块"    })   </script> |

### （7）class

l class：集中保存一个类型的构造函数和原型对象方法的储存空间

Ø 为什么：因为旧js中构造函数和原因对象虽然同属一个类型，但是写法上是分开的，

不符合封装的要求

Ø 何时：今后要创建一种新类型，想反复创建相同结构的对象时，都要用class代替原来

   的构造函数和原型对象分散的写法

Ø 如何：

​              i     用class{}来包裹原来分散写的构造函数和原型对象方法

​             ii     所有构造函数的类型名都提升为整个class的类型名，所有构造函数从此统一用constructor关键词创建

​             iii     所有直接放在class中的方法，默认自动会保存到原型对象中，不用再加“构造函数.prototype”前缀

| ex：用class定义一个学生类型                                  |
| ------------------------------------------------------------ |
| <script>    //定义一个学生类型:     class Student{//新瓶     constructor(sname, sage){//新瓶      this.sname=sname; //旧酒      this.sage=sage; //旧酒     }     intr(){//新瓶     //Student.prototype.intr=function(){ ... }//旧酒      console.log(`I'm ${this.sname},I'm ${this.sage}`)//旧酒     }    }    var lilei=new Student("Li Lei",11);    console.log(lilei);    lilei.intr();  </script> |

##### 1）class间继承 

​    (1). 问题: 程序中两个class之间包含部分相同的属性结构定义和方法定义

 

​    (2). 解决: 再额外定义一个父级class，统一保管两个子级class相同部分的内容

​    (3). 如何: 2大步

​    a. 第一步: 先额外定义一个父类型: 2小步

​       1). 在父类型的构造函数中，集中定义所有子类型相同部分的属性结构

​       2). 在父类型的class中，集中定义所有子类型相同的方法定义

​    b. 第二步: 让子类型class，继承父类型class: 2小步

​       1). 使用extends关键词，让子类型继承父类型

​       结果: 子类型.prototype._ _proto_ _ = 父类型.prototype

​       结果: 将来子类型new出来的孙子一级对象，即可用子类型的原型对象方法，又可用父类型的原型对象方法

​       2). 在子类型构造函数内，先用super关键词，调用父类型的构造函数。

​       (super关键字是extends赠送的，专门指向父类型构造函数的关键词)

​       结果: 父类型的构造函数和子类型的构造函数共同协作创造出将来的子类型的子对象。

​       结果: 将来子类型的子对象身体里，包含着来自于父类型构造哈数和子类型构造函数，两个构造函数中规定的所有属性结果。

 

​    (4). 示例: 两种类型间的继承

  <script>    //创建父级类型Flyer，替Plane和Sun两个子类型保管相同部分的属性结构定义和方法定义    class Flyer{     constructor(x,y){      this.x=x;      this.y=y;     }     fly(){      console.log(`飞到x=${this.x},y=${this.y}位置`)     }    }       //定义敌机类型Plane，继承父类型Flyer    class Plane extends Flyer{     constructor(x,y,score){      super(x,y); //借用父类型的Flyer的构造函数，帮助子类型为孩子添加相同部分的属性定义      this.score=score;     }     getScore(){      console.log(`击落一架敌机得${this.score}分`)     }    }    //定义降落伞类型，继承父类型Flyer    class San extends Flyer{     constructor(x,y,award){      super(x,y);//借用父类型Flyer的构造函数，来帮助子类型为孩子添加相同部分的属性定义      this.award=award;     }     getAward(){      console.log(`击落降落伞得到${this.award}奖励`)     }    }        //无论上边怎么改，下边代码不应该受影响才对！    var p1=new Plane(10,50,5);    p1.fly();    p1.getScore();    var s1=new San(30,100,"100发子弹");    s1.fly();    s1.getAward();   </script>  输出结果:   飞到x=10,y=50位置  击落一架敌机得5分  飞到x=30,y=100位置  击落降落伞得到100发子弹奖励  

### （8）promise

l Promise：专门解决回调地狱问题的新编程方法。

Ø 什么是回调地狱(callback hell)：多个异步函数需要顺序执行，如果单纯顺序调用多个异步函数，无法保证多个异步函数顺序执行，因为异步函数之间默认谁也不等谁。用回调函数虽然可以使异步函数顺序执行，但是如果要求多个一个函数必须顺序执行，则回调函数的嵌套会很深！——回调地狱。

 

Ø 今后只要多个异步任务需要顺序执行，都可用Promise技术来代替传统的回调地狱

如果打算用promise，就不要定义回调函数参数

##### 1）用回调函数实现多个异步函数顺序执行

 

两步：

a）在前一个异步函数定义时，增加一个形参变量"回调函数"（在前一个异步函数内，当异步

任务最后一句话执行完之后，自动调用形参中传入的回调函数）

b）在调用前一个异步函数时，提前将调用下一个异步函数的语句，包裹在一个匿名函数

function()内，提前保存到前一个异步函数的回调函数形参变量上

结果：当前一个异步函数执行完自己的最后一句话之后，自动调用回调函数，则回调函数中提前保存的下一个异步函数才开始执行

示例：

| 使用回调函数实现多个异步任务顺序执行                         |
| ------------------------------------------------------------ |
| <script>    //定义函数，描述亮哥跑步的过程    function liang(筐){     //筐:function(){ ran() }     console.log(`亮哥起跑...`);     setTimeout(function(){//异步，互相之间默认不等待      console.log(`亮哥到达终点!`);      console.log(` 亮哥放下筐...`);      //当亮跑完之后，放下筐，筐中的函数才开始执行      筐(); //(function(){ ran() })()     },6000)    }    //定义函数，描述然哥跑步的过程    function ran(筐){     //筐:function(){ dong() }     console.log(`然哥起跑...`);     setTimeout(function(){//异步，互相之间默认不等待      console.log(`然哥到达终点!`);      console.log(` 然哥放下筐...`);      //当然跑完之后，放下筐，筐中的函数才开始执行      筐(); //(function(){ dong() })()     },4000)    }    //定义函数，描述东哥跑步的过程    function dong(){     console.log(`东哥起跑...`);     setTimeout(function(){//异步，互相之间默认不等待      console.log(`东哥到达终点!`)     },2000)    }    //错误: 无法保证顺序执行！因为互相之间谁也不等谁    liang(     function(){//筐装着ran      ran(//调用ran的语句       function(){//筐装着dong        dong();//调用dong的语句       }      );     }    );       </script> |

 

##### 2）用promise实现多个异步函数顺序执行

 

两步：

​    a）先改造原异步函数，变成一个格子间

  function 前一项任务函数(不要写回调函数参数了){      return  new Promise( //创建一个格子间，包裹原异步任务的代码         function(door){  //赠送了一个门             //原异步任务代码             //异步任务最后一句话执行完             //手动调用door()开门——结果: 才开始执行.then()链接的下一项任务         }      )  }  

​    b）调用

  前一项异步任务.then(下一项任务函数).then(...)      //如果下一项任务函数也是一个格子间      强调: .then()中的下一项任务函数因为不是立刻执行，所以不要加()！  

示例：

| 使用promise实现多个异步任务顺序执行                          |
| ------------------------------------------------------------ |
| <script>    //定义函数，描述亮哥跑步的过程    function liang(){     //固定套路！——信任     return new Promise(//造一个格子间      function(door){//赠了一个门       console.log(`亮哥起跑...`);       setTimeout(function(){//异步，互相之间默认不等待        console.log(`亮哥到达终点!`);        //在异步任务最后一句话执行完，手动调用door函数，开门！        console.log(` 亮开门...`);        door();       },6000)      }     )    }    //定义函数，描述然哥跑步的过程    function ran(){     return new Promise(      function(door){       console.log(`然哥起跑...`);       setTimeout(function(){//异步，互相之间默认不等待        console.log(`然哥到达终点!`);        console.log(` 然开门...`);        door();       },4000)      }     )         }    //定义函数，描述东哥跑步的过程    function dong(){     console.log(`东哥起跑...`);     setTimeout(function(){//异步，互相之间默认不等待      console.log(`东哥到达终点!`)     },2000)    }    //调用时依次调用每个异步函数，但是异步函数之间用.then()相连    liang().then(ran).then(dong);    // ↓     ↓      ↓    //格子间.then(格子间).then(不是格子间)不能继续.then()    //串联，无论多少异步任务需要顺序执行，都不会发生嵌套！   </script> |

## 二、DOM

广义js分为3部分：

\1. ECMAScript：规定了js的核心语法标准，没有规定如何操作网页内容

\2. DOM：专门操作网页内容的对象和函数

\3. BOM：专门操作浏览器窗口的对象和函数

l DMO（Document Object Model）：专门操作网页内容的一套对象和函数的统称。

Ø 为什么要使用DMO：DOM是唯一的能够操作网页内容的对象和函数。

Ø 何时使用DOM：今后只要想操作网页内容，只能用DOM提供的对象的函数

（前端js框架：jquery，vue，ng，react，底层都是基于DOM实现的）

Ø DOM标准

F 旧DOM：打有浏览器那天开始，就有DOM了。但是，各个浏览器厂商提供的DOM对象和函数没有标准。导致在一个浏览器上实现的页面效果，换到另一个浏览器上就无法正常执行。被迫使用另一个浏览器提供的不同的对象和函数重新开发一遍。

F DOM标准：1998年W3C组织出面制定了国际统一的DOM标准。所有浏览器都必须遵照执行

F 使用DOM标准开发网页的功能，几乎所有浏览器100%兼容。但是，IE8没有赶上DOM标准制定，所以IE8对DOM的支持不好。好在，现在几乎不用考虑IE8

Ø DOM可以做的事：增删改查+事件绑定

## 1、DOM树

l DOM树：网页中所有HTML内容在内存中都是保存在一棵树形结构上的，内存中这棵树保

存一个网页中所有内容的树形结构，就称为DOM树

Ø 为什么：因为树形结构是最直观的保存上下级包含关系的结构。而HTML内容中的元

素恰好也是上下级包含的关系。所以用树型结构保存HTML内容，一目了然

Ø 何时：只要浏览器扫描到一个.html文件，在将.html内容显示到浏览器窗口中给人看

之前，都会在内存中自动创建一棵DOM树来保存HTML内容中每项细节

Ø 如何：

F 当浏览器窗口扫描到一个.html文件时，会先在内存中自动创建一个document对象。作为整个DOM树的树根。将来网页中所有的HTML内容，都会成为document树根对象的子节点或后代节点。整个DOM树的树根document对象——也称为根节点对象

F 浏览器窗口开始扫描网页内容。每扫描到一项内容，都会在DOM树上对应位置，创建一个对象，保存这项扫描到的内容的属性值或其他细节。也就是说，网页中的每一项HTML内容(元素或文本)都会成为DOM树上的一个对象——称为节点(node)对象

 

## 2、查找元素

### （1）不需要查找就可以直接获得的元素

a）<html>元素对象  document.documentElement

b）<body>元素对象  document.body

c）<head>元素对象  document.head

### （2）按节点间关系查找元素

##### 1）按节点树关系查找（不使用）

节点树：旧DOM标准中使用的包含网页中所有内容（元素、文本、注释...）的完整树结构

2大关系，6个属性

① 父子关系：4个属性

a）获得当前节点对象的父级节点对象: 节点对象.parentNode

b）获得当前节点对象的所有直接子节点对象的集合: 节点对象.childNodes

  返回的是一个包含多个直接子节点对象的类数组对象

  可用节点对象.childNodes[i]方式，获得某个位置上的子节点

c）获得当前节点对象的第一个直接子节点对象: 节点对象.firstChild

d）获得当前节点对象的最后一个直接子节点对象: 节点对象.lastChild

② 兄弟关系：2个属性

a）获得当前节点的前一个兄弟节点对象：节点对象.previousSibling

b）获得当前节点的后一个兄弟节点对象：节点对象.nextSibling

注：按节点树关系查找，连看不见的空格换行等空字符，也识别为节点对象，严重干扰了正常的查找秩序。因为程序员普遍只关心元素，不关心其余类型的节点对象，所以新DOM标准中新建了一棵新树——元素树

##### 2）按元素树关系查找

l 元素树：只包含元素类型节点对象的树结构，不再包含空格、文本、注释等程序员不关心的节点。不会受到看不见的空字符的干扰。

2大关系，6个属性

① 父子关系：4个属性

a）获得当前元素对象的父级元素对象: 元素对象.parentElement

  （特例: 因为parentElement太长，且parentNode通常不会选中那些非元素节点（因为在HTML中能当爹的只有元素），所以parentNode依然可以代替parentElement继续使用。）

b）获得当前元素对象的所有直接子元素对象的集合: 元素对象.children

  返回的是一个包含多个直接子元素对象的类数组对象

可用元素对象.children[i]方式，获得某个位置上的子元素

c）获得当前元素对象的第一个直接子元素对象: 元素对象.firstElementChild

d）获得当前元素对象的最后一个直接子元素对象: 元素对象.lastElementChild

② 兄弟关系：2个属性

a）获得当前元素的前一个兄弟节点对象：元素对象.previousElementSibling

b）获得当前元素的后一个兄弟节点对象：元素对象.next Sibling

 

何时使用按节点间关系查找元素？

如果已经获得一个元素对象在手，想找这个元素周围附近的元素时，首选按节点间关系查找

| 示例：使用节点间关系查找元素                                 |
| ------------------------------------------------------------ |
| <!DOCTYPE HTML>  <html>   <head>    <title>DOM Tree</title>    <meta charset="utf-8" />   </head>   <body>    <span id="s1">Hello</span>    <h1>标题一</h1>    <script>     //不要用live server运行//直接在硬盘打开     console.log(document.documentElement);//html元素及其内容     console.log(document.head);//head元素及其内容     console.log(document.body);//body元素及其内容     var body=document.body;//获得body元素及其内容     //获得body下第一个孩子:      var span=body.firstElementChild;     console.log(span);     //获得body下最后一个孩子:     var script=body.lastElementChild;     console.log(script);     //获得body下第二个孩子     var h1=body.children[1];     console.log(h1);     var h1=span.nextElementSibling;     console.log(h1);     var h1=script.previousElementSibling;     console.log(h1);     //输出body下所有直接子元素的集合: 3个元素     console.log(body.children);    </script>   </body>  </html> |

### （3）按HTML特征查找元素

HTML特征有4种：id、标签名称、class名、name名

| 按id查找一个元素对象  | var  一个元素对象=document.getElementById("id名")  意为：在整个页面范围内，查找id为指定id名的一个元素  返回值：  a）如果找到指定id的一个元素，就返回这一个元素的对象  b）如果没找到指定id的元素，则返回null  c）如果页面中包含多个相同id名的元素，只返回第一个指定id名的元素对象  注：  F .前的主语必须是document  F 函数名中的Element是单数，没有s |
| --------------------- | ------------------------------------------------------------ |
| 按标签名查找多个元素  | var  类数组对象=任意父元素.getElementsByTagName("标签名")  意为：在一个指定的父元素范围内，查找指定标签名称的多个元素  返回值：  a）如果找到多个符合指定标签名称的元素，则返回类数组对象包含多个找到的元素对象  b）如果没找到返回，返回一个length=0的空类数组对象：{ length:0 }  注：  F 前的主语可以是任意父元素，用来限制查找范围  F 函数名中的Elements是复数，有s  F 不仅查找直接子元素，而是在所有后代中查找所有满足的元素 |
| 按class名查找多个元素 | var  类数组对象=任意父元素.getElementsByClassName("class名")  意为：在指定的一个父元素下，查找多个带有指定class名的元素对象  返回值：  a）如果找到多个符合要求的元素，则返回一个类数组对象，包含找到的多个元素对象  b）如果找不到，则返回空类数组对象：{ length:0 }  注：  F .前的主语可用任意父元素，用来限制查找范围  F 函数名中的Elements是复数，有s  F 不仅查找直接子元素，而是在所有后代中查找满足的元素  F 如果一个元素同时被多个class名修饰，则只使用其中一个class名，就能找到该元素 |
| 按name名查找表单元素  | var  类数组对象=document.getElementsByName("name名")  意为：在当前网页中，按name名查找多个符合条件的表单元素  返回值：  a）如果找到指，则返回类数组对象，包含多个元素对象  b）如果找不到，则返回空类数组对象：{ length:0 }  注：  F .前的主语必须是document  F 函数名中的Elements是复数，有s |

说明：

  按标签名查找、按class查找、按name名查找永远返回类数组对象。  即使只找到一个符合要求的元素，也会将这唯一的一个元素放在类数组对象中返回！  也就是我们无法直接获得这个找到的唯一的元素对象。  必须用[0]方式，再从类数组对象中0位置，取出这个唯一的元素，才是我们想要的元素对象！  

示例：

| 使用4种查找函数，查找想要的元素                              |
| ------------------------------------------------------------ |
| 详见：G:\Web2020\Stage  03\02.DMO\day01\course\ 02_iterator.html |

### （4）按选择器查找元素

按选择器查找一个或多个符合选择器条件的元素

| 只查找一个元素 | var  一个元素对象=任意父元素.querySelector("任意选择器")  意为：在一个指定父元素内，查找第一个符合选择器要求的元素对象  返回值：   a）如果找到，当然返回DOM元素  b）如果没找到，返回null  注：.  F 前可以是任意父元素，限制查找的范围  F 即使多个元素符合选择器条件，也只返回第一个找到的元素 |
| -------------- | ------------------------------------------------------------ |
| 查找多个元素   | var  类数组对象=任意父元素.querySelectorAll("任意选择器")  意为：在指定父元素范围内，查找所有符合选择器要求的多个元素对象  返回值：  a）如果找到，返回一个类数组对象  b）如果没找到，返回空类数组对象: { length:0 } |

强调：

  强调: 选择器一定不要超出.前父元素的范围。因为querySelector()和querySelectorAll()默认是在.前父元素范围内查找。如果选择器查找父元素的范围，则可能报错！  比如: table.querySelector("tbody>tr>td:last-child")  正确     table.querySelector("table>tbody>tr>td:last-child")  可能报错，因为table下不会再有  table元素了。  

示例：（重要）

| 使用Selector API实现购物车客户端计算                         |
| ------------------------------------------------------------ |
| 详见：G:\Web2020\Stage  03\02.DMO\day01\course\ 03_shoppingCart.html |

 

| 笔试题：递归遍历一个父元素下所有后代元素 |
| ---------------------------------------- |
| 在后代元素中调用与父元素一样的遍历函数   |

 

| 笔试题：多个按钮，点哪个按钮，就提示，点的第几个 |
| ------------------------------------------------ |
|                                                  |

拓展：

  其他扩展视频：web问题速查小程序-在线  

## 2、修改元素

一个元素身上3种东西可修改：内容，属性、样式

### （1）修改内容

修改元素中的内容有3种：

| 元素.innerHTML   | 获取或修改元素开始标签到结束标签之间的原始的HTML内容  a） 获取元素的HTML内容时：返回原始的HTML代码内容  b） 修改元素的HTML内容时：先将新的HTML代码内容交给浏览器解析后，再显示在元素内部 |
| ---------------- | ------------------------------------------------------------ |
| 元素.textContent | 获取或修改元素开始标签到结束标签之间的纯文本内容  a） 获取元素的纯文本内容时：textContent会去掉内嵌标签，还会将特殊符号翻译为正文  b） 修改元素的纯文本内容时：不会将新内容交给浏览器解析，而是直接原样显示在元素内部 |
| 表单元素.value   | 获取或修改表单元素的值  因为大多数表单元素都是单标记，没有结束标签，所以不能用innerHTML或textContent |

注：

凡是从页面上获得的一律是字符串类型！尤其是进行后续算术计算之前，都要先转为数字，再计算！

示例：(常用)

| 开关门效果                                                   |
| ------------------------------------------------------------ |
| 详见：G:\web2020\Stage  03\02.DMO\day02\course\  02_door.html |

### （2）修改属性

3种属性可以修改：字符串的HTML标准属性、Bool类型的HTML标准属性、自定义扩展属性

##### 1）获取和修改字符串的HTML标准属性

l 字符串类型的HTML标准属性：HTML标准规定的，值为字符串类型的HTML属性

比如：<元素 title=”xxx” style=”xxx” id=”xxx” class=”xxx” name=”xxx”…>

2种办法：

① 旧DOM标准中规定的4个函数：

| 获取一个元素的指定属性的属性值 | var 属性值=元素.getAttribute("属性名") |
| ------------------------------ | -------------------------------------- |
| 修改一个元素的指定属性的属性值 | 元素.setAttribute("属性名","属性值")   |
| 移除一个元素上指定的属性       | 元素.removeAttribute("属性名")         |
| 判断元素上是否包含某个属性     | var bool=元素.hasAttribute("属性名")   |

② 新DOM提供了简化版的HTML DOM属性

  HTML DOM将所有HTML标准属性，提前保存在了内存中的元素对象身上，只不过没有出现在页面上的属性值暂时默认为""而已，可以用"元素.属性名"方式来操作HTML标准属性

| 获取一个元素指定属性的属性值   | 元素.属性名                                   |
| ------------------------------ | --------------------------------------------- |
| 修改一个元素指定属性的属性值   | 元素.属性名="属性值"                          |
| 移除一个元素指定属性           | 元素.属性名=""                                |
| 判断一个元素上是否包含某个属性 | 元素.属性名!=="" 就说明包含，否则就说明不包含 |

特例： class属性

  HTML中：<元素 class="btn btn-danger">...</元素>  Js中：错误！元素.class="btn" 因为class已经是ECMAScript中的关键词，DOM中就不能再用class表示样式类  今后DOM中只要想操作class，都要被迫改名为className  元素.className="btn"  

示例：

| 伸缩二级菜单                                                 |
| ------------------------------------------------------------ |
| 详见：G:\web2020\Stage 03\02.DMO\day02\course\   03_menu.html |

##### 2）获取和修改bool类型的标准属性

l bool类型的HTML标准属性： HTML标准中有一种属性只要放在元素的开始标签中就起作用，无需提供属性值，这样的属性就称为Bool类型的HTML标准属性。也称为状态属性

比如：

  <input type="checkbox" checked>  <select>      <option>北京</option>      <option  selected>天津</option>      <option>河北</option>  </select>  <button disabled></button>  

如何获取和修改：

不能用旧DOM 4个函数修改。因为旧DOM 4个函数只支持字符串类型的属性。

只能用HTML DOM "元素.属性名"方式来获取或修改。且属性值必须是bool类型true或false

  css中提供了一种伪类选择器，专门匹配处于某种状态的元素  a）:checked伪类: 专门匹配已选中的checkbox  b）:disabled 伪类: 专门匹配已禁用的表单元素  …..  

示例：（常用）

| 全选和取消全选                                               |
| ------------------------------------------------------------ |
| 详见：G:\web2020\Stage  03\02.DMO\day02\course\ 04_selectAll.html |

##### 3）获取和修改自定义扩展属性

l 自定义扩展属性：HTML标准中没有规定的，程序员根据自身需要，自发添加到元素上的

属性

Ø 何时：（2种情况下使用）

\1. 代替其他选择器(id、类、元素)，作为查找触发事件的元素的条件

  其他选择器当做查找触发事件的元素的条件，存在的问题：  a）id选择器: 只能查找一个元素  b）类选择器: 类选择器本职工作是为元素添加css样式。而不是为js交互行为服务。所以，如果用类选择器作为查找触发事件的元素的条件，很可能因为样式的修改，而导致js也无法正常使用  c）元素选择器: 实现同一种效果，不同的开发人员可能有多种选择    比如实现按钮效果，可用: a、input、span、button、...  

​    今后好的做法：凡是可能触发事件的元素，都添加自定义扩展属性作为查找条件

  <a   class="btn"   mybutton>  <input type="button"  class="btn" mybutton>  <span class="btn"  mybutton>  如何查找三个按钮：属性选择器  var  btns=document.querySelectorAll("[mybutton]")  

\2. 在网页中临时缓存稍后要用的部分业务所需数据

  不缓存这些数据会有什么问题？  之后每次使用数据，都要重新请求服务器，加载速度慢，用户体验变差，又增加了服务器端的负担。  

​     正确做法：在首次加载时，就把后续可能使用的业务数据多请求一部分过来。临时缓存在网页元素的自定义扩展属性上。

​     优点：之后每次使用数据时，无需重复请求服务端，加载速度极快，用户体验好，且极大的减少了服务器端的负担。

  以放大镜效果为例         

Ø 如何使用自定义扩展属性 (标准做法)

\1. 为元素添加自定义属性

| 在html中写死             | <元素 data-自定义属性名="属性值">                            |
| ------------------------ | ------------------------------------------------------------ |
| 用js添加或修改自定义属性 | a）旧DOM 4个函数之一：    元素.setAttribute("data-自定义属性","属性值")  b）用HTML5提供的新做法    元素.dataset.自定义属性="属性值" |

说明: 用dataset方式添加，不用自己加data-前缀，当属性被添加到页面元素上时，dataset会自动补充data-前缀

 

\2. 获取自定义属性: 2种

| 用旧DOM 4个函数之一 | 元素.getAttribute("data-自定义属性") |
| ------------------- | ------------------------------------ |
| 用HTML5提供的新方法 | 元素.dataset.自定义属性              |

 

\3. 想用自定义扩展属性当条件查找元素时: 用属性选择器

| 查找带有"data-属性名"的元素                         | [data-属性名]        |
| --------------------------------------------------- | -------------------- |
| 查找带有"data-属性名"，且属性值为指定的属性值的元素 | [data-属性名=属性值] |

示例：（重要）

| 使用自定义扩展属性实现标签页效果                             |
| ------------------------------------------------------------ |
| 详见：G:\web2020\Stage  03\02.DMO\day02\course\ 05_tabs.html |

### （3）修改样式

① 修改元素的内联样式

| 在HTML中手动写死               | <元素  style="css属性:属性值">...</元素> |
| ------------------------------ | ---------------------------------------- |
| js中动态执行修改元素的内联样式 | 元素.style.css属性="属性值"              |

  注：

F 所有css属性值都必须是字符串，加""

F 如果是长度或大小相关属性，则属性值必须加单位: px em ..

F css属性名如果带-，则必须改为"去横线变驼峰"，如：

  <元素 style="font-size:12px">...</元素>  错误：元素.style.font-size="12px" 因为-会和程序中的减法混淆  正确：元素.style.fontSize="12px"  

② 获取元素的css样式 

Ø 用.style方式只能获得元素的内联样式，无法获得样式表中的样式！所以用.style获得样式，无法获得大部分样式。今后只要获取样式都要获得"计算后的样式"。

Ø 计算后的样式：最终应用到这个元素上的所有样式的总和

Ø 获得一个元素计算后的样式：分2步：

| //1.0先获得这个元素所有计算后的样式的总和(对象)  var style=getComputedStyle(元素对象)  //2.0从style中获得个别css属性值  style.css属性 | getComputedStyle返回的所有样式是只读的！不允许修改！  因为: 计算后的属性，不知道是哪儿来的！不知道有多少元素正在共用这个属性。如果擅自修改，很可能牵一发而动全身！ |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

③ 用class批量修改元素的样式

Ø 因为style.css属性="属性值" 一句话只能修改一个css属性。但是，网页中一个效果的变化，很可能要同时修改多个css属性。所以，用.style.css属性="属性值"做效果，可能代码会很繁琐！今后程序中，只要批量修改一个元素的多个css属性，都要用class代替.style。

Ø class批量修改元素的样式分2步：

  //1.0在css中先定义好不同情况下的多个class  //2.0在js中根据不同的情况为元素添加不同的class  元素.className="class名"  

示例： 

| 实现带样式的表单验证                                         |
| ------------------------------------------------------------ |
| 详见：G:\web2020\Stage 03\02.DMO\day02\course\ 06_valiWithCSS.html |

## 3、添加元素

### （1）添加新元素

添加新元素分3步

  //1.0创建一个空元素对象  var 元素对象=document.createElement("标签名")  //2.0为新元素设置必要的属性  …..  //此时a暂时只在内存中保存。还不知道应该加载到页面的哪个位置。所以，暂时在页面上看不见！  //3.0将新元素添加到DOM树上指定父元素下(3种方式)  a）在父元素下所有子元素末尾追加  父元素.appendChild(新元素)  b）插入到父元素下某个现有子元素之前    父元素.insertBefore(新元素, 现有子元素)  c）替换父元素下一个指定的现有子元素  父元素.replaceChild(新元素, 现有子元素)         //只有将新元素添加到DOM树中指定父元素下之后，浏览器才知道在哪个位置显示新元素，用户才能看到这个新元素。  

ex： 

| 创建一个a元素                                                |
| ------------------------------------------------------------ |
| <a></a>                           //1.0创建一个空元素对象  var a=document.createElement("a");   //2.0为新元素设置必要的属性                                    <a href="http://tmooc.cn">go      to tmooc</a> tmooc</a>                           a.href="http://tmooc.cn";  a.innerHTML="go to tmooc";  //3.0将新元素添加到DOM树上指定父元素下  document.body.appendChild(a);  var input=document.createElement("input");  console.log(input);  document.body.insertBefore(input,a);    //在a之前插入一个input  //document.body.replaceChild(input,a);   //用input替换a |

示例： 

| 根据服务器返回的数据动态创建表格                             |
| ------------------------------------------------------------ |
| 详见：G:\web2020\Stage  03\02.DMO\day03\course\ 01_createTable.html |

### （2）添加新元素的优化

优化原则：尽量减少操作DOM树的次数，每修改一次DOM树，浏览器都要重新排版，重新绘制网页。而重新排版和重新绘制网页是非常复杂的过程。如果频繁重排重绘，导致页面加载效率减低，甚至闪屏。

如何减少操作DOM树的次数：2种

① 如果同时添加父元素和子元素，应该先在内存中将所有子元素加到父元素内，最后再一次性将父元素添加到DOM树，这样只修改一次DOM树，只需要一次重排重绘即可。 

  优化以上动态创建表格的代码  

② 如果父元素已经在页面上了，需要同时添加多个平级的子元素，应该借助于"文档片段对象"来减少修改DOM树的次数

Ø 什么是文档片段对象：内存中临时保存多个DOM元素的虚拟父元素

Ø 何时使用文档片段对象：只要同时添加多个平级子元素时，都要用文档片段对象

Ø 如何使用：分3步

  //1.0先创建一个文档片段对象  var 文档片段对象=document.createDocumentFragment()  //2.0将多个平级子元素先暂时添加到文档片段对象中暂存  文档片段对象.appendChild(子元素)  //3.0将整个文档片段对象一次性添加到DOM树上指定父元素下     //文档片段对象将多个子元素运送到DOM树后，就自动释放了。不会占用页面的空间。也不会成为页面上真正的元素。  

示例： 

| 根据服务器返回的数据动态创建表格  (tbody已经在页面上了，就要借助文档片段减少修改DOM树次数) |
| ------------------------------------------------------------ |
| 详见：G:\web2020\Stage  03\02.DMO\day03\course\ 01_createTable.html |

## 4、HTML DOM常用对象（了解）

l HTML DOM：对旧DOM的属性和函数提供的一些简写方式。只对部分内容进行了简化。大部分旧DOM内容，还是没有简化。

### （1）img元素

只在创建元素时，有简化

| 简化写法 | var img=new Image();                  |
| -------- | ------------------------------------- |
| 旧DOM:   | var img=document.createElement("img") |

### （2）option元素

在创建元素时，有简化

| 简化写法 | var option=new Option("内容","值");  // <option value="值">内容</option> |
| -------- | ------------------------------------------------------------ |
| 旧DOM    | var opt=document.createElement("option");  //<option></option>  opt.value="值";  //<option value="值"></option>  opt.innerHTML="内容";  //<option value="值">内容</option> |

### （3）table元素

HTML DOM中对table元素采用逐级管理

| Table管着行分组对象                                          | 1）table可以添加行分组  a）var thead=table.createTHead();  //1.0 创建一个行分组var thead=document.createElement("thead")  //2.0将新创建的行分组，追加到table下 table.appendChild(thead)  b）var tbody=table.createTBody();  c）var tfoot=table.createTFoot(); |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 2）table可以删除行分组   a）table.deleteTHead();   b）table.deleteTFoot();   c）没有table.deleteTBody(); |                                                              |
| 3）table可以获取行分组   a）table.tHead  //因为table规定只能有一个thead   b）table.tFoot  //因为table规定只能有一个tfoot   c）table.tBodies[i]  //但是table规定，可以有多个tbody元素 |                                                              |
| 行分组对象管着行对象tr                                       | 1）行分组可添加行  var tr=行分组.insertRow(i);  //意为:  在行分组中创建一个新行，并插入到行分组下下标为i的位置  //相当于：1.0创建tr:  var tr=document.createElement("tr")         2.0将tr插入到行分组i位置: 行分组.insertBefore(新tr,  行分组.children[i]);  其中两个位置最常用：  末尾追加一个新行：var tr=行分组.insertRow() //默认追加到末尾  开头插入一个新行：var tr=行分组.insertRow(0)   注：如果行分组中i位置，已经有一个现有行，则在i位置插入新行，原i位置及其之后的行，被向后挤一位。不会替换 |
| 2）行分组可删除行  行分组.deleteRow(i);//不可行，因为将来table中可能有很多行，而程  序没有长眼睛，不知道要删除的行是第几行。  tbody.deleteRow(tr.rowIndex);// 每个行对象tr上都有一个tr.rowIndex属性，记录着这一行在整个表中的下标位置但是行在整个表中的下标位置，因为要从表头行开始算起，所以比行分组内的相对下标位置通常都大如果硬用这种方法删除，删除的不是tr这一行，而是tr下某一行  最好的删除行的办法:  用table作为.前的主语  table.deleteRow(tr.rowIndex);//前主语变成整个table了，所以deleteRow()需要的下标，也就变成行在整个table中的下标位置。刚好和tr.rowIndex所表示的意义相同！ |                                                              |
| 3）行分组可获取一行   行分组.rows[i];                        |                                                              |
| 行对象tr管着格对象td                                         | 1）行可以添加一格：     var td=tr.insertCell(i) //通常不写i，默认在行尾追加新格  2）行可以删除一格     tr.deleteCell(i)  3）行可以获取一格     tr.cells[i] |

示例： 

| 用HTML DOM简写table案例，并添加删除行功能       |
| ----------------------------------------------- |
| 详见：G:\web2020\Stage  03\02.DMO\day03\course\ |

### （4）form元素

| 获取form元素                 | var form=document.forms[i或id或name];  //因为document对象已经将网页中所有的<form>元素集中存储在了forms集合中  //如果网页中只有一个form元素：var form=document.forms[0] |
| ---------------------------- | ------------------------------------------------------------ |
| 获取form内的表单元素         | //form内的所有表单元素（input、textarea、select、button），都被集中保存在了form.elements集合中  a）var 表单元素=form.elements[i或id或name];  b）//如果表单元素有name属性  form.name名 |
| 统计表单内所有表单元素的个数 | form.length  //比如: 获得表单中倒数第二个提交按钮  var  btn=form.elements[form.length-2] |
| 让表单元素自动获得焦点       | 表单元素.focus();                                            |

示例： 

| 使用HTML DOM简写表单验证案例                    |
| ----------------------------------------------- |
| 详见：G:\web2020\Stage  03\02.DMO\day03\course\ |

## 三、BOM（了解）

​     

l BOM（Browser Object Mode浏览器对象模型）：一套专门操作浏览器窗口的对象和函数

的集合

Ø 何时：只要想操作浏览器窗口相关的功能，都用BOM。比如：打开和关闭窗口，窗口

滚动相关操作，... ...

Ø BOM由一系列对象各掌一摊组成的

| window对象    | 囊括一切                       |
| ------------- | ------------------------------ |
| history对象   | 控制前进后退                   |
| location对象  | 页面跳转                       |
| document对象  | 包括一切DOM相关操作            |
| screen对象    | 包含当前显示器的信息           |
| navigator对象 | 包含浏览器的配置信息           |
| event对象     | 包含所有和事件相关的信息和操作 |

Ø BOM最大的问题: 没有标准！浏览器兼容性极差！

## 1、window对象

window对象3个角色：

（1）window代替了ECMAScript中的global，充当全局作用域对象，保存全局变量和全局函数

（2）window包含了所有原生的对象和函数: ECMAScript+DOM+BOM

（3）window代表了当前正在打开的浏览器窗口

| 获得当前窗口大小 | a）窗口完整大小  window.outerWidth   window.outerHeight;  b）仅用于显示网页的文档显示区部分大小     window.innerWidth  window.innerHeight |
| ---------------- | ------------------------------------------------------------ |
| 关闭当前窗口     | window.close();                                              |

## 2、打开新链接

打开连接有四种情况：

| 在当前窗口打开新链接，可后退          | a）HTML中：<a href="新url" target="_self">  b）js：window.open( "新url",   "_self") |
| ------------------------------------- | ------------------------------------------------------------ |
| 在当前窗口打开新链接，禁止后退        | a）a. HTML中:  做不了  js：location.replace("新url") //新url会代替history中之前旧url，来阻止后退 |
| 在新窗口打开新链接， 允许同时打开多个 | a）HTML中：<a href="新url" target="_blank">  b）js：window.open("新url",    "_blank") |
| 在新窗口打开新链接， 只允许打开一个   | a）HTML中：<a href="新url" target="自定义窗口名">  b）js：window.open("新url",   "自定义窗口名") |

示例： 

| 实现四种打开新链接的需求                       |
| ---------------------------------------------- |
| 详见：G:\web2020\Stage 03\02.DMO\day03\course\ |

 

原理

a. 其实浏览器打开的每个窗口在内存中低层都有一个唯一的窗口名

b. 浏览器规定，相同名称的窗口只能打开一个，后打开的同名窗口，会自动将之前打开的同名窗口覆盖，只保留一个最新的同名窗口

​    c. a元素的target属性和window.open()的第二个参数，都是在为新窗口指定内存中低层的窗口名。

d. 新窗口中可用window.name查看自定义的新窗口的名字

强调: 今后不允许使用"name"作为全局变量名，会和BOM中的window.name冲突

e. 两个预定窗口名:

1). _self: 不指定窗口名，自动获得当前窗口自己的名字，作为新窗口的名称。——自杀

2). _blank: 不指定任何窗口名，但是浏览器低层决不会让窗口名空着，浏览器会自动随机分配窗口名——永不冲突，所以，可以打开多个新窗口

## 3、history对象

l history对象：专门保存当前窗口打开后，成功访问过的url的历史记录数组

​      （history中的内容，没有对我们开放，看不见的）

Ø 原理

​    a. 当浏览器窗口打开时，window中会自动创建一个history对象

​    b. 只要当前窗口成功访问过一个url，浏览器就会自动把这个url以push()方式压入history

中保存。

​    c. 结果: 先访问的url在下层压着，后访问的url在上层

Ø History中有个指针，默认指向最新压入的新url。可通过前进后退按钮控制指针上下移动。

如果当前指针位置下方有旧url，则可以后退，否则不能后退

如果当前指针位置上方有新url，则可以前进，否则不能前进

Ø 如何使用history对象

| 前进一步 | history.go(1)                                                |
| -------- | ------------------------------------------------------------ |
| 后退一步 | history.go(-1) //如果后退一步不管用，可以history.go(-2) 后退两步 |
| 刷新     | history.go(0)                                                |

## 4、location对象

l location对象：专门保存当前窗口中地址栏中url信息的对象，并提供页面跳转相关的功能

Ø 何时：2种情况

F 分段获得url中各个部分的值时

F 执行个别跳转操作时

Ø 如何：

| 分段获得url中各个部分的值 | a）location.href //获得的是完整的url地址  b）location.protocol  //获得的是协议部分，比如: http:  c）location.host  //获得的是主机名+端口号，如localhost:3000  d）location.hostname 仅获得主机名，比如: localhost  e）location.port 仅获得端口号, 比如:  3000  f）location.pathname 获得相对路径, 比如: /users/login.html  g）location.search  //获得?以及之后的查询字符串参数，  比如:  ?uname=dingding&upwd=123456  h）location.hash 获得的是#及其之后的锚点地址，比如: #collapse |
| ------------------------- | ------------------------------------------------------------ |
| 执行个别跳转操作          | a）location.href="新url" //也可以实现在当前窗口打开新链接，禁止后退  b）location.replace("新url") //独有的: 在当前窗口打开新链接，禁止后退  c）location.reload() //也可以刷新页面 |

## 5、navigator对象

l navigator对象：专门保存浏览器配置信息的对象

Ø 何时: 如果想获得浏览器软件相关的配置信息时

Ø 如何: 2个最常用的属性

| 获得当前浏览器的名称和版本号     | navigator.userAgent |
| -------------------------------- | ------------------- |
| 获得当前浏览器已经安装的插件列表 | navigator.plugins   |

补充知识点：浏览器三大对话框

  1. prompt: 输入框: 带一个可输入内容的文本框的弹出框  2. alert: 警告框: 只有一个"确定"按钮的提示框，用户没有选择的余地  3. confirm: 确认框: 包含两个按钮"确认"和"取消"的提示框，允许用户选择。         如果用户点确认按钮，则确认框返回true，说明用户同意继续         如果用户点取消按钮，则确认框返回false，说明用户不同意继续  三大对话框因为有致命的缺点:  1. 样子很丑，还改不了！因为对话框是用浏览器低层代码写死的。用普通的css无法修改。  2. 兼容性问题，不同浏览器中对话框样子各部相同！  所以今后几乎不再使用了。  今后所有对话框都是用div+css+定位做的。  

 



 

## 四、事件

l 事件：浏览器自动触发的或用户手动触发的页面中元素状态或内容的改变

Ø 事件属性：每个元素对象身上都有一系列"on事件名"格式的属性，称为事件属性

事件属性的作用：当某个元素上发生事件时，浏览器会自动查找这个元素

身上的事件属性上提前保存的函数，并自动执行该函数

Ø 事件绑定：提前将事件发生时希望自动执行的函数，提前保存在元素的事件属性上

Ø 事件处理函数：提前保存在事件属性上，事件发生时能够自动执行的函数，称为事件

处理函数

## 1、事件绑定

事件绑定的3种方式

（1）在HTML中

| <元素 on事件名="js语句"> | 问题：不符合内容与行为分离的原则，不便于维护 |
| ------------------------ | -------------------------------------------- |
|                          |                                              |

（2）在js中，用赋值方式绑定

| 元素.on事件名=function(){  ... } | 问题: 同一个元素的同一个事件，只能绑定一个处理函数 |
| -------------------------------- | -------------------------------------------------- |
|                                  |                                                    |

（3）在js中，用事件监听对象方式

| 添加事件监听对象 | 元素.addEventListener("事件名", 事件处理函数);  原理：  a）除了每个元素上有事件属性用于保存事件处理函数之外，在浏览器内存中还有一个巨大的事件队列，也可用于为元素保存事件处理函数。         b）每执行一次addEventListener()，就会自动创建一个事件监听对象，对象中保存三个属性{ 哪个元素, 哪个事件名, 处理函数}，并自动将事件监听对象添加到浏览器的事件队列中保存  c）当某个元素发生事件时，浏览器会先查找当前元素自己身上的事件属性上的处理函数，自动执行。然后浏览器还会继续去事件队列里查找，是否有当前元素的当前事件匹配的事件监听对象。只要找到匹配的事件监听对象，就可以自动执行，事件监听对象中保存的处理函数。找到几个就执行几个。 |
| ---------------- | ------------------------------------------------------------ |
| 移除事件监听对象 | 元素.removeEventListener("事件名", 原事件处理函数)  注意：  a）移除事件监听时，如果原事件处理函数位置只是写的和绑定时匿名处理函数定义一模一样，但是依然使用匿名函数，是无法移除事件处理函数的。    因为，匿名函数的function是new Function的意思，是一个全新的函数对象，即使写的一模一样，也不是原函数对象。  b）正确做法：如果一个事件处理函数有可能被移除，则绑定时就必须使用有名称的函数，移除时，才能使用函数名，找到原函数对象，才能移除。  c）但是事件队列中有限制: 元素对象，事件名，函数对象完全相同的事件监听监听对象，只能添加一个！不能重复添加！（暂时不讨论获得多个跟踪导弹的情况） |

示例： 

| 模拟发射子弹和获得跟踪导弹，以及移除跟踪导弹   |
| ---------------------------------------------- |
| 详见：G:\web2020\Stage 03\02.DMO\day03\course\ |

## 2、事件模型

l 事件模型：从事件触发开始，到所有处理函数执行完，所经历的过程。包括3个阶段：

（1）捕获(capture)阶段：从document节点开始，由外向内，逐级遍历当前触发事件的元素的各级父元素上所有绑定的事件处理函数——只记录有哪些函数，暂不触发！

（2）目标触发阶段：浏览器总是优先触发目标元素上绑定的事件处理函数。

​          （目标(target)元素：最初实际想点的那个元素）

（3）冒泡执行：当目标元素上的处理函数执行完之后，浏览器会从目标元素开始，由内向外，按照捕获阶段时记录的反向顺序依次触发各级父元素上绑定的事件处理函数。

 

## 3、事件对象

l 事件对象：事件发生时，浏览器自动创建的，保存事件信息的对象。

Ø 何时：2种

F 如果想获得事件的信息时，比如事件发生时鼠标的位置

F 如果想改变事件默认的行为时，比如不想冒泡！

Ø 如何：2步

  //1.0先获取事件对象：其实事件对象总是作为事件处理函数的第一个实参值自动传入  当事件发生时，自动创建event  元素.on事件名=function(e){  //当事件发生时，形参e，就自动获得了事件对象event  }  //2.0 用e，访问事件对象中的属性，调用事件对象提供的方法  …….  如  e.stopPropagation();   //取消冒泡/停止蔓延，e.stopPropagation()防的是父元素上处理函数的执行，而不是防当前元素自己的处理函数。所以，当前元素中e.stopPropagation()写前写后，无所谓，只要写了就行。  

示例： 

| 取消冒泡                                        |
| ----------------------------------------------- |
| 详见：G:\web2020\Stage  03\02.DMO\day03\course\ |

## 4、事件委托/利用冒泡

浏览器触发事件，是通过遍历事件监听队列的凡是查找符合条件的监听对象触发的。如果事件监听对象很多！遍历就会慢，导致事件响应变慢。所以要尽量减少事件监听的个数——通过事件委托/利用冒泡。

l 称为事件委托/代理：如果多个平级子元素都要绑定相同的事件时，应该只给父元素绑定一

次事件，所有子元素可通过冒泡机制共用父元素上的一个事件处理函

数！

Ø 问题1：如果事件绑定在父元素上，则事件发生时，this指向的父元素，不再指向实际

点击的子元素了。所以，事件委托中，this无法用于获得当前点击的子元素

解决：今后如果使用事件委托优化，事件处理函数中必须用e.target代替this获得实

际点击的子元素。

e.target ：专门保存最初点击的目标元素的特殊属性。一旦保存住最初点击的

目标元素，就不会随冒泡而改变！——一旦拥有，别无所求！

Ø 问题2：用户可能点在一些无关紧要的子元素或者直接点在父元素上，也会触发事件。

但是，此时我们不想触发事件。

​       解决：如果事件事件委托优化代码，都要先判断用户点的目标元素e.target是不是想

要的！只有e.target符合要求，才继续执行后续代码。否则如果e.target不是想

要的元素，则什么也不干！

如何判断目标元素是否是想要的？

一切可以将想要的元素和不想要的元素区分开的特征(nodeName className..)，都可以作为判断条件！

  总结: 事件委托3步  1. 事件只绑定在父元素上一份即可  2. e.target代替this  3. 判断e.target是否是想要的！  

示例： 

| 使用事件委托优化实现计算器效果                  |
| ----------------------------------------------- |
| 详见：G:\web2020\Stage  03\02.DMO\day03\course\ |

## 5、阻止默认行为

l 阻止默认行为：个别元素身上自带的默认的操作

  //如果元素自带的默认行为不想要！其实可以通过事件对象来阻止默认行为  e.preventDefault();  注：  e.preventDefault()只阻止元素默认的行为，不阻止自己写的事件处理函数  

示例： 

| 阻止a元素的默认行为 <a href="#top">click  me</a>             |
| ------------------------------------------------------------ |
| <body>   <a id="a1" href="#top">click me</a>   <script>    var a1=document.getElementById("a1");    a1.onclick=function(e){     e.preventDefault();     alert("疼！")    }   </script>  </body> |

## 6、鼠标坐标

l 鼠标坐标：当事件发生时，事件对象中会保存住鼠标所在位置的3组x，y坐标

| 当前鼠标位置相对于屏幕左上角的坐标               | e.screenX e.screenY  |
| ------------------------------------------------ | -------------------- |
| 当前鼠标位置相对于浏览器文档显示区左上角的坐标   | e.clientX, e.clientY |
| 当前鼠标位置相对于当前事件所在的元素左上角的坐标 | e.offsetX, e.offsetY |
|                                                  |                      |

## 7、窗口滚动事件

窗口滚动条每次滚动时，都会自动触发一个事件

  window.onscroll=function(){  //获得页面滚动过的距离      var  scrollTop=document.body.scrollTop||document.documentElement.scrollTop  }         

示例： 

| 当窗口滚动到指定距离时，自动显示元素           |
| ---------------------------------------------- |
| 详见：G:\web2020\Stage 03\02.DMO\day03\course\ |

 



 

## 五、jQuery

l jQuery：第三方开发的执行DOM操作的极简化的函数库（第三方: 必须下载，才能使用）

Ø 指定DOM操作：jQuery还是在执行DOM操作(增删改查+事件绑定)，学习jQuery其

实还是在学习DOM。

Ø 极简化：jQuery将DOM的每一步操作，都进行了极其的简化。

| 按id查找一个元素                                |                           |
| ----------------------------------------------- | ------------------------- |
| DOM中：var 元素=document.getElementById("id名") | Jq中：var 元素=$("#id名") |
| 获得一个的下一个兄弟元素                        |                           |
| DOM中：元素.nextElementSibling                  | Jq中：元素.next()         |

Ø 函数库：jQuery中一切都是函数！没有属性！

Ø 为什么使用：简单！已经解决了绝大部分浏览器兼容性问题。

Ø 何时：用的越来越少了，存在致命缺点

F jQuery只支持PC端网页，不支持移动端和小程序

F 只是对DOM的每一步进行了简化，没有彻底减少开发的步骤！

Ø 如何使用jQuery

1）下载（官网: jquery.com）

2）版本：1.x 唯一兼容旧浏览器(IE8)的版本。（上课用1.11.3版本）

​              未压缩版：可读性好，适合于学习和开发之用

​              压缩版：体积小，适合于生产环境快速下载使用

​           2.x 不再支持旧浏览器

3.x 不再支持旧浏览器，才开始支持ES6新特性，如for of和promise等

​       3）引入jquery.js： <script src ="js/jquery-1.11.3.js"></script>

示例： 

| 点击按钮，记录点击次数                                       |
| ------------------------------------------------------------ |
| 详见：G:\web2020\Stage 03\02.DMO\day04\course\  dom vs jquer |

## 1、jQuery的原理

### （1）jQuery的使用

① 要使用jquery，必须先引入jquery.js，再编写自定义的js脚本。引入jquery.js，其实是给js内存中添加了一种全新的类型（家庭）：2部分

1)   构造函数: 专门用于创建该类型的子对象

2)   原型对象: 专门保存所有子对象共用的方法

 

② 要使用jQuery家简化版函数代替DOM家旧版函数操作DOM元素的步骤：

1)   先创建jQuery家子对象，同时查找并保存要操作的DOM元素，到新创建的jQuery子对象中

| var $jq对象=$("选择器") | 为了区分jQuery家孩子和DOM家孩子，约定俗成: 所有jQuery家孩子的变量名，都必须以"$"开头 |
| ----------------------- | ------------------------------------------------------------ |
|                         |                                                              |

2)   才可以使用jq对象调用jQuery家提供的各种简化版函数

F 所有简化版函数都会被自动翻译为DOM原生的对等的函数

F 然后，对整个jq对象执行什么DOM操作，都等效于直接对jq对象内保存的DOM元素执行相同的DOM操作。（操作jq对象，等于操作里边的DOM元素）

③ $btn.click(function(){ ... })中的this

1)   $btn.click(function(){ ... })会被翻译为btn.onclick=function(){ ... }

2)   this依然指.前的当前按钮btn对象——DOM元素对象，无法使用jQuery家函数

3)   所以，必须: var $this=$(this) 等效于new jQuery(this) -> new jQuery(btn)

4)   结果: $this才是jquery家函数，才能继续调用jQuery家函数

 

 

### （2）jQuery对象的本质

Query对象的本质其实是一个类数组对象。因为交给$()的选择器，很可能在页面中找到多个符合要求的元素。只有类数组对象，才最适合保存多个DOM元素对象

 

### （3）jQuery简化版函数的特点

通用三大特点

1）几乎所有简化版函数都内部自带for循环

如果$()找到并保存了多个元素，则只对$()这一个jquery对象整体调用一次简化版函数，就等效于自动遍历jq对象中保存的每个DOM元素，并对每个DOM元素执行等效的原生操作。——在jq中，几乎看不到for循环

2）所有和修改元素相关的函数(修改内容、属性、样式)都一个函数两用！

F 如果调用修改函数时，没有提供新值，则改为执行获取现有值的的操作

F 只有调用修改函数时，给了新值，才执行修改操作

​    ——重载！

3）//遇到再说

示例： 

| 记录三个按钮，每个按钮的点击次数            |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day01\course |

强调: 如果决定用jquery来实现效果，则应该全程都用jquery。极力避免jquery和DOM混搭！

总结: jquery还是执行DOM的增删改查+事件绑定操作而已。与DOM相比，除了每一步操作都进行了简化之外，原理毫无差别。

## 2、查找元素

2大类查找方法

### （1）按选择器查找

jQuery都统一为var $jq对象=$("任意选择器")

jQuery支持所有CSS3选择器

jQuery还新增了个别独有的新选择器(仅jq内可用，css中不可用)

​    包括：基本过滤选择器，内容过滤选择器、可见性过滤选择器、表单元素过滤选择器

##### 1）基本过滤选择器

① 回顾css中的子元素过滤选择器

根据子元素在其父元素内的相对位置匹配子元素，CSS中包括4个：

| :first-child  | 选择作为其所在父元素内的第一个直接子元素的元素               |
| ------------- | ------------------------------------------------------------ |
| :last-child   | 选择作为其所在父元素内的最后一个直接子元素的元素             |
| :nth-child(i) | 选择作为其所在父元素内的第i个直接子元素的元素（css中i从1开始！！） |
| :only-child   | 选择作为其所在父元素内的唯一一个子元素的元素                 |

示例： 

| 使用子元素过滤选择器选择元素                |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

② 基本过滤选择器： 先将所有符合条件的元素取出来，放在一个集合中，从头到尾，统一编号。且编号从0开始。基本过滤选择器与元素在其父元素中的相对位置无关！包括

| :first 或 :last            | 选择所有符合条件的元素中第一个元素或最后一个元素     |
| -------------------------- | ---------------------------------------------------- |
| :gt(i) 或 :lt(i) 或 :eq(i) | 选择所有符合条件的元素中>i位置或<i位置或=i位置的元素 |
| :even 或 :odd              | 选择所有符合条件的元素中，偶数或奇数下标位置的元素   |

注：

因为程序员眼里编号从0开始，正常人眼中编号从1开始。所以，程序员眼中的奇数偶数位置刚好和正常人眼中的奇数偶数位置是错位的！

   

示例1： 

| 使用基本过滤选择器选择元素                  |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

示例2： 

| 实现按钮组效果                                               |
| ------------------------------------------------------------ |
| G:\Web2020\Stage  03\03_jQuery\day02\course   今后，如果一个效果，既可以用css做，又可以用js做，首选用css！因为css比js效率高！ |

##### 2）内容过滤选择器

根据元素的内容不同来选择元素

| :contains(文本) | 选择元素内容中包含指定"文本"的元素     |
| --------------- | -------------------------------------- |
| :has(选择器)    | 选择包含符合选择器要求的子元素的父元素 |
| :parent:        | 选择内容非空的元素                     |
| :empty          | 选择内容为空的元素                     |

示例： 

| 使用内容过滤选择器选择元素                  |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

##### 3）可见性过滤选择器

根据元素是显示，还是隐藏来选择元素。包括：

| :visible | 选择可见的元素 |
| -------- | -------------- |
| :hidden  | 选择隐藏的元素 |

注：

: :hidden，只能匹配用display:none或type="hidden"隐藏的元素。无法匹配visibility:hidden和opacity:0隐藏的元素.

示例： 

| 检验:hidden可查找哪些元素，不能查找哪些元素 |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

##### 4）表单元素过滤选择器

CSS中的普通的元素选择器input，只能选择input元素

jquery中，包括

| :input      | jQuery独有的能选择表单中所有的表单元素  (input  textarea  button  select) |
| ----------- | ------------------------------------------------------------ |
| :type类型名 | Jq针对input元素的每种type属性值分别提供了一个专门的选择器  比如： |
| :text       | 专门选择input type="text"的文本框                            |
| :password   | 专门选择input type="password"的密码框                        |
| :radio      | 专门选择 input type="radio"的单选按钮                        |
| :checkbox   | 专门选择input type="checkbox"的复选框                        |
| ……          | ……                                                           |

:示例： 

| 点同意，启用表单元素，不同意，则禁用表单元素 |
| -------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course  |

### （2）按节点间关系查找

2大类关系，共8个函数

① 父子关系：3个函数(parent(), children(), find() )

| $元素.parent ()          | 获得当前元素的父元素（相当于.parentNode）                    |
| ------------------------ | ------------------------------------------------------------ |
| $元素.children("选择器") | 获得当前元素下所有符合选择器要求的直接子元素  （children只能在直接子元素中查找，无法在所有后代中查找）  比如：  当前元素下第一个直接子元素: $元素.children(":first-child")  当前元素下最后一个直接子元素: $元素.children(":last-child") |
| $元素.find("选择器")     | 获得当前元素下所有后代元素中符合选择器要求的元素  （find()是在所有后代中查找符合要求的） |

​                                            

② 兄弟关系：5个函数(prev(),prevAll(),next(),nextAll(),siblings())

| $元素.prev ()            | 获得当前元素的前一个兄弟元素  （相当于.previousElementSibling） |
| ------------------------ | ------------------------------------------------------------ |
| $元素.prevAll("选择器")  | 获得当前元素之前的所有符合选择器要求的兄弟元素  （jq新增的函数）  比如：点中间一颗星星，应该是之前所有星星都变黄 |
| $元素.next()             | 获得当前元素的后一个兄弟元素  （相当于.nextElementSibling）  |
| $元素.nextAll("选择器")  | 获得当前元素之后的所有符合选择器要求的兄弟元素  （jq新增的函数）  比如：点中间一颗星星，应该是之后所有星星都清空 |
| $元素.siblings("选择器") | 获得除当前元素之外所有符合选择器要求的其余兄弟元素  （jq新增的函数）  比如:点击任何一个表情，都要清空除自己之外的所有其他表情，无论前后！ |

示例： 

| 使用节点间关系查找指定的元素                |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

示例： 

| 标签页效果：使用属性选择器实现标签页头的切换 |
| -------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course  |

## 3、修改元素

### （1）修改内容

内容：3种

| $元素.html("新HTML内容") | 获取或修改元素开始标签到结束标签之间的原始HTML内容（一个函数两用） |
| ------------------------ | ------------------------------------------------------------ |
| $元素.text("新文本内容") | 获取或修改元素开始标签到结束标签之间的纯文本内容  （一个函数两用） |
| $表单元素.val ("新值")   | 获取或修改表单元素的值  （一个函数两用）                     |

示例： 

| 通过修改元素内容实现实现表单验证提示        |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

### （2）修改属性

属性：3种

① 字符串类型的HTML标准属性

| $元素.attr("属性名", "新属性值") | 替代dom中的  .getAttribute("属性名")和.setAttribute("属性名","新属性值") |
| -------------------------------- | ------------------------------------------------------------ |
| $元素.prop("属性名", "新属性值") | 因为jQuery是一个函数库，不能用".属性名"，所以.prop()函数代替的是DOM中“.属性名 |

示例： 

| 点击图片，切换下一张                        |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

② Bool类型的HTML标准属性

F DOM中: 不能用getAttribute()和setAttribute()获取或修改，只能用".属性名"获取或修改，

 且值必须是bool类型

F jq中: 也不能用.attr()获取或修改，只能用.prop()获取或修改——jQuery即使DOM

示例： 

| 回顾示例：启用禁用表单元素的例子            |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

③ 自定义扩展属性

F DOM中(不考虑HTML5)：只能用getAttribute()和setAttribute()获取或修改。不能用".

属性名"方式获取或修改

F jq中：也只能用.attr()来获取或修改，不能用.prop()获取或修改

示例： 

| 点小图片，切换大图片                        |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

 

总结: .attr() vs .prop()差别

|                              | 字符串类型  标准属性 | Bool类型  标准属性 | 自定义扩展属性  （值为字符串） |
| ---------------------------- | -------------------- | ------------------ | ------------------------------ |
| .attr() //get/setAttribute() | √                    |                    | √                              |
| .prop()  //.属性名           | √                    | √                  |                                |

### （3）修改样式

① 获取或修改一个元素的一个css属性值

| $元素.css("css属性名", "新属性值")                           | css()整合了DOM中的.style和getComputedStyle()两个操作  DOM中：  a)     .style.css属性名 只能获取或修改内联样式  b)     如果要完整样式，被迫改为用getComputedStyle()  Jq中：  1)     如果.css()时没有给新属性值，则自动在低层调用getComputedStyle()，执行获取css属性值的操作  2)     如果.css()时，给了新属性值，则自动切换为在低层调用.style.css属性，执行修改css属性值的操作  jq中，无论获取还是修改css属性值，都用.css()一个函数 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 总结  jQuery常用的三个修改相关的函数:  $元素.attr()，$元素.prop()，$元素.css()  都可以一个函数同时修改多个属性，但是要用对象语法！  $元素.attr/prop/css({   属性名1: "值1",   属性名2:"值2",     ... : ...  }) |                                                              |

② 通过修改class批量修改一个元素的多个css属性

  问题1：使用.css()修改元素的样式时，一句话只能修改一个元素的一个css属性，即使用{}简写，也必须把每个css属性都写出来。当需要批量修改一个元素的多个css属性时，代码会很繁琐

  问题2：DOM中虽然可以用className属性来修改元素的class，批量修改元素的多个css

属性。但是，如果一个元素同时被多个class修饰，那么，如果只修改其中一个class，就及其不方便。

比如：<button id="btn" class="btn active  btn-success">

​         如果需要移除class中的active，就被迫需要用字符串函数处理: 删除关键词

​    btn.className.replace("active","") —— 别扭

jq中: 为了方便对class做各种灵活的操作，提供了4个函数：

| $元素.addClass("class名")          | 添加一个class                                                |
| ---------------------------------- | ------------------------------------------------------------ |
| $元素.removeClass("class名")       | 移除一个class                                                |
| var bool=$元素.hasClass("class名") | 判断元素是否包含一个class                                    |
| $元素.toggleClass("class名")       | 一个元素在有或没有某个class之间来回切换  原理：  .toggleClass()内部自带了if else，自动判断本次是该添加class，还是该移除class，所以不需要自己再写if else  相当于：       if($元素.hasClass("class名"))         $元素.removeClass("class名")      else         $元素.addClass("class名") |

  注：

F 使用以上函数操作一个元素的一个class时，不需要关心也不会影响元素上的其他class

F 以上函数的参数中，其实可以放多个class，只不过多个class名之间用空格分割

示例： 

| 实现双态按钮                                |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

## 4、添加/删除/替换/克隆

### （1）添加元素

添加元素分2步

  //1.0  将html代码片段创建为DOM对象  （仅创建出的新DOM元素，暂时还不在DOM树上，用户看不到）  var $新元素=$(`html代码片段`)   //2.0将$新元素添加到DOM树上指定位置: 10种方式（用户才能看得见）   a）在父元素下所有子元素末尾追加一个新元素  $父元素.append($新元素)  //return 父元素 后续可对父元素继续链式操作            .appendChild(新元素)                       $新元素.appendTo(父元素) //return 新元素 后续可对新元素继续链式操作  b）在父元素下所有子元素开头插入一个新元素:   $父元素.prepend($新元素)  return 父元素 后续可对父元素继续链式操作  $新元素.prependTo(父元素)  return 新元素 后续可对新元素继续链式操作  c.）插入到父元素下一个指定的现有子元素之前:        $现有元素.before($新元素)    return 现有元素 后续可对现有元素继续链式操作     $新元素.insertBefore(现有元素)  return 新元素 后续可对新元素继续链式操作  d）插入到父元素下一个指定的现有子元素之后:        $现有元素.after($新元素)     return  现有元素 后续可对现有元素继续链式操作       $新元素.insertAfter(现有元素)  return 新元素 后续可对新元素继续链式操作  e）替换父元素下一个指定的现有子元素:   $现有元素.replaceWith($新元素)  return 现有元素 后续可对现有元素继续链式操作  $新元素.replaceAll(现有元素)   return 新元素 后续可对新元素继续链式操作  

示例： 

| 点按钮添加元素                              |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

### （2）删除元素

  $任意元素.remove()  

### （3）克隆元素

  var $一模一样的新元素=$元素.clone()  

示例： 

| 选飞机                                      |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

## 5、事件绑定

### （1）标准事件绑定方式

| $元素.on("事件名", 事件处理函数)   //仅仅是DOM中addEventListener的简写 |
| ------------------------------------------------------------ |
| $元素.off("事件名", 原事件处理函数)  //仅仅是DOM中removeEventListener的简写 |

对比：

F 相同点：如果一个事件监听有可能需要被移除，则绑定时必须用有名称的函数来绑定。

移除时，才能用函数名获得原函数对象

F 不同点：jq中同名函数，照样可以绑定多个事件监听，移除时，还可用一个函数名移除

所有同名的事件监听

示例：

| 使用on和off绑定事件和移除事件               |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

### （2）简写事件绑定方式

jquery对21种事件提供了简写格式

  $元素.事件名(事件处理函数)  //单纯就是on的简写，没有差别。也可以用off移除  

常用可简写事件名列表

| blur 失去焦点   change 下拉列表选中项改变  click 单击   dblclick 双击   focus 获得焦点   keydown 键盘按键按下   keyup 键盘按键抬起  mousedown 鼠标按键按下 | mouseenter 鼠标进入(jq)  mouseleave 鼠标移出(jq)  mousemove 鼠标移动  mouseout 鼠标移出(dom)  mouseover 鼠标进入(dom)  mouseup 鼠标按键抬起  resize 窗口大小改变  scroll 网页滚动 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例：

| 使用click()，简写on()                       |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

 

### （3）事件委托

如果多个子元素都要绑定相同的事件处理函数时，就可用事件委托优化。

3步：——重要，今后框架依然可用

  //1.0 事件只绑定在父元素上一份即可  …  //2.0 在事件处理函数中用e.target代替this  …  //3.0 先判断e.target是不是想要的元素，才能继续执行后续代码  …  

jQuery中的简写：——了解，仅jquery可用，今后框架不通用 

| $父元素.on("事件名", "选择器",  function(){  this重新指向了最初触发事件的某个子元素  }) | 相同点: 事件只绑定在父元素上一份即可  不同点:   a) 必须用on()，不能用简写click()..  b) 给on()添加第二个参数: 选择器，用来自动判断当前触发事件的元素是不是符合选择器要求——好处，不用自己再写if判断了  c) this重新指向了最初触发事件的那个子元素，而不再指父元素了——好处，不要用e.target代替this了！又可以用this了！ |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例：

| 使用事件委托优化选飞机示例                  |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day02\course |

### （4）页面加载后自动执行

小程序->在线->jQuery->day03->1. 页面加载完成后自动执行...

问题1：多数页面在页面加载完成后，就要自动执行一些操作，如：ajax请求首屏数据，比如为元素绑定事件处理函数。这些代码写在哪儿？

F 错误的解决方法：放在<body>之前的<script>中

因为网页顺序执行！没有body中的HTML元素，ajax请求回的数据就不知道放哪儿，事件也不知道绑定给谁！

F 不好的解决方法：放在body结尾的<script>中

因为不符合内容与行为分离的原则，不便于维护！

F 好的解决方法：将所有js代码都放在HTML文件之外的独立的js文件中单独保存，

运行时，通过<script src="js/xxx.js">引入HTML中自动执行——符合内容与行为分离的原则，便于维护。

问题2：别人引入你的js时，可不一定都放在结尾！我们希望无论js文件在HTML开头引入，还是在b ody结尾引入，都能正常执行

F 解决：将所有要在页面加载后自动执行的代码，都放在window.onload事件的处理函数

中。（window.onload会等待所有HTML+JS+CSS+图片都下载完，才自定执行）

F 结果：将来无论被人将你的js代码放在HTML开头还是放在body结尾都只是一个事件

绑定代码而已，不会立刻执行。只有等到所有页面内容加载完成后，才执行！

问题3：因为图片下载非常慢，有些操作，用户等不及所有图片都下载完，才用。用户希望，只要看到按钮就可以点击！不关心CSS和图片！window.onload必须等待css和图片都下载完才能执行，所以，有点晚！

F 解决：其实在window.onload之前还有一次加载完成事件

a. DOMContentLoaded : 仅DOM内容加载完成就可以提前触发事件，执行一些操作

b. DOMContentLoaded只等HTML+JS，无需等待CSS和图片， DOMContentLoaded

事件会比window.onload事件提前很多就可开始执行！

c. 今后几乎所有和css和图片无关的页面初始化操作：比如ajax和事件绑定，都应该

放在DOMContentLoaded事件中提前触发，让用户提前用上功能！

问题4：因为DOMContentLoaded有兼容性问题，所以通常都用jquery提供的方法来绑定DOMContentLoaded事件

解决：完整写法: $(document).ready(function(){ ... 页面初始化相关操作 ... })

   简化：$().ready(function(){ ... 页面初始化相关操作 ... })

​      $(function(){... 页面初始化相关操作 ... })

  总结：今后为了保证绝大多数页面初始化操作都能让用户提前用上，所有页面初始化代码都应该放在一个$(function(){ ... })中

其实：今后几乎所有jquery的代码，都是放在$(function(){ ... })中的

 

  a. 仅HTML+JS加载完就提前执行：——早  $(function(){ ... 页面初始化代码，比如ajax请求，事件绑定 ... })  b. 所有网页内容(HTML+JS+CSS+图片)执行外才执行——晚  window.onload=function(){ ... }     

示例：

| 实现页面加载完成后自定执行页面初始化操作  14_ready1.js |
| ------------------------------------------------------ |
| G:\Web2020\Stage  03\03_jQuery\day02\course            |

 

## 6、事件

### （1）鼠标事件

① DOM中：

| mouseover | 当鼠标进入元素范围内时自动触发一次 |
| --------- | ---------------------------------- |
| mouseout  | 当鼠标离开元素范围时自动触发一次   |

F 问题：即使反复进出子元素，也会反复冒泡触发父元素上的鼠标进入和移出事件

（容易造成误解）

② jQuery中：

用mouseenter和mouseleave代替了mouseover和mouseout

F 优点：即使反复进出子元素，也不会反复冒泡触发父元素上的鼠标进入和移出事件

（和现实相符，不会造成误解）

示例：

| 用mouseenter和mouseleave代替mouseover和mouseout |
| ----------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day04\course     |

F 问题：因为多数情况下鼠标进入和鼠标移出事件都是成对儿绑定的(鼠标进入变样，鼠标

移出后恢复)。但是mouseenter和mouseleave太长！不愿意写！

F 简写：如果同时绑定mouseenter和mouseleave，只需要绑定一个jq专属的事件函数

hover()即可

| $元素.hover( //=mouseenter+mouseleave      function(){  ... }, //给mouseenter      function(){  ... } //给mouseleave  ) | 因为虽然只绑定一个函数hover，但是hover等效于同时绑定两个事件(mouseenter+mouseleave)，所以hover中通常要写两个事件处理函数。第一个给mouseenter，第二个给mouseleave |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

F 更简写：如果你有本事把hover中的两个函数，改造成两个相同的函数

| $元素.hover(//=mouseenter+mouseleave  function(){  ... } //既给mouseenter，又给mouseleave  ) | hover中如果只给一个函数，不是只绑定mouseenter的意思。依然是既绑定mouseenter又绑定mouseleave。且唯一的一个函数既给mouseenter，又给mouseleave |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例：

| 使用hover简写实现鼠标进入和移出效果         |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day04\course |

### （2）模拟触发

即使没有点击按钮，也能触发按钮上的单击事件

如：百度上搜索时，当在文本框中输入完关键词，不需要点查找按钮，只需要按回车，就可执行和点击查找按钮完全相同的操作！

如何：

| 标准写法 | $事件所在元素.trigger("事件名")  //触发事件所在的那个元素上的指定名称的事件的处理函数 |
| -------- | ------------------------------------------------------------ |
| 简写     | $事件所在元素.事件名() //如果要触发的事件刚好是21种常用事件之一，则无需trigger，可直接使用事件名触发  注：()里不要写function！ |

示例：

| 模仿百度按回车搜索，点按钮也能搜索          |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day04\course |

## 7、动画

### （1）简单动画

固定写死的3种动画效果——了解

| 显示隐藏 | $元素.show()  $元素.hide()  $元素.toggle()  说明：  a）在不加任何参数的情况下: 仅仅是display:block和display:none的简写。  等效于.css("display","block")和.css("display":"none");  ——所有在jquery如果希望无过渡效果的显示隐藏一个元素，都可用show()/hide()/toggle()不带任何参数来实现。  b）其实，想让以上三个函数带过渡动画效果，只需要在()中添加一个动画持  续时间毫秒数。 |
| -------- | ------------------------------------------------------------ |
| 上滑下滑 | $元素.slideUp()  $元素.slideDown()  $元素.slideToggle()  说明：不需要加参数，也默认自带过渡效果 |
| 淡入淡出 | $元素.fadeIn()  $元素.fadeOut()  $元素.fadeToggle()  说明：不需要加参数，也默认自带过渡效果 |

简单动画函数的致命缺陷：2个

  1. 丑，不便于维护！——所有变化过程，都是用js在jquery函数库源代码中的写死的！  2. 效率低——底层都是用js程序+js定时器实现的，效率远不如css动画高！  所以，今后做这类简单动画，首选css  transition做！——自己写的css便于维护，且css比js程序效率高的多！  

示例：

| 简单测试3种简单动画效果                     |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day04\course |

### （2）万能动画

可以对任意css属性应用过渡效果

——作用类似于css的transition，但是无论是效率，还是功能，都远不如css的transition

如何？

| $元素.animate({         Css属性:目标值,              ... : ...      },  动画持续时间ms)  //{}里只支持单个数值的css属性，不支持非数值的属性（比如颜色，CSS3 transform...），远不如css transition | 原理:  a）animate会自动获得元素的当前状态  b） animate根据{}中给的目标状态和当前状态之间的差距，自动计算过渡的变化过程  c） 然后底层启动js定时器模拟过渡变化的效果，执行变化的过程。 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

F 优点：比简单动画9个函数更灵活

F 缺点：效率低——底层是用js定时器模拟的；

支持的css属性，还不如css transition多！

F 结论：如果动画变化的过程，是固定的，不会有人工干预，首选css transition

   如果动画变化的过程由人为操作，只能用animate()!

### （3）排队和并发

并发：多个css属性，同时变化。

如何：放在一个animate({})内的多个css属性，默认并发变化

排队：多个css属性，按顺序，先后依次变化

如何：对同一个元素，先后连续调用多个animate()函数，则先后调用的多个animate()函数中的css属性是排队变化的

### （4）停止动画

停止动画：$元素.stop()

F 问题：当多个animate()排队执行时，.stop()只能停止当前正在执行的一个动画animate()，排队的后续animate()依然继续执行！

F 解决：$元素.stop(true) 停止当前animate()动画，同时清除之后所有animate()动画

F jquery独有选择器: :animated 专门匹配正在执行animate()动画的元素

F 动画结束后自动执行：

问题：animate()低层是js定时器，所以animate()是异步的函数。如果想在动画播放结束后，才执行一项任务，单纯将代码放在animate()之后，是无法实现的！

解决：其实所有动画函数都有最后一个实参——一个回调函数。放在动画函数最后一个回调函数实参中的代码，注定只能在动画播放完成后，才自动调用执行.

示例：

| 简单测试3种简单动画效果点击每颗星星，执行不同的动画效果 |
| ------------------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day04\course             |

## 8、类数组对象操作

 jQuery仿着数组家两个函数，为jQuery对象也定义了两个功能几乎完全一样的函数

### （1）index()函数

仿着数组家的indexOf()函数，为jQuery对象定义了一个index()函数

F 回顾：数组家indexOf()函数是查找一个元素在数组中的下标位置！

​        var i=arr.indexOf(元素值)

F Jq中：

  var i=$查询结果.index(要找的元素) //查找一个元素在整个jquery查询结果集合中的下标位置  

示例：

| 5星评价                                     |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day04\course |

 

### （2）each()函数

仿着数组家的forEach()函数，为jQuery对象定义了一个each()函数

F 回顾：数组家forEach()用于遍历数组中每元素 

  arr.forEach(function(elem,i){  //elem会自动获得当前正在遍历的数组元素值  //i会自动获得当前正在遍历的下标位置  })  

F Jq中：

  $查询结果.each(function(i,  elem){  //i会自动获得当前正在遍历的下标位置  //elem 会自动获得当前正在遍历的查询结果中的一个DOM元素对象  })  

示例：

| 使用each遍历jquery查询结果中每DOM元素       |
| ------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day04\course |

## 9、封装自定义插件

### （1）为jQuery家添加自定义函数

其实就是定义一个函数，添加到jQuery的原型对象中

  jQuery.prototype.方法名=function(){      ...  ...  }  结果：将来只要是jQuery的查询结果对象，都可以调用原型对象中添加的自定义方法       $("选择器").方法名()  强调：jQuery原型对象方法中，也只能通过this来操作将来调用这个自定义方法的.前的jQuery对象。又因为将来调用自定义方法时，.前已经是$()jquery对象了，所以this->$(...)，不需要再$(this)了！  

 

示例：

| 为jQuery添加自定义函数sum()，可以对jquery查询结果中所有DOM元素的内容求和 |
| ------------------------------------------------------------ |
| G:\Web2020\Stage  03\03_jQuery\day04\course                  |

 

### （2）封装自定义插件 

插件/组件：指拥有专属的HTML+CSS+JS的可重用的独立的页面功能区域

Ø 为什么：重用！提高开发效率，优点: 简单

Ø 何时：如果我们的页面中有一块功能区域在项目中多个位置反复使用，则都应该先封

装为插件，再反复使用插件。而不是整段代码复制粘贴！

Ø 参考：jquery官方插件库: jQuery UI, 

Ø 如何使用：

  //1.0下载jQuery的js和css以及图片: jqueryui.com  //2.0 css和图片文件夹，放在项目的css文件夹中，jquery-ui.js放在项目的js文件夹里  //3.0在HTML页面中: 依次引入jqueryui.css， jquery.js 和jqueryui.js     <link  rel="stylesheet" href="css/jquery-ui.css">     <script  src="js/jquery-1.11.3.js"> 先     <script  src="js/jquery-ui.js"> 后  //4.0按插件要求编写插件的HTML结构和内容 —— 暂时没有任何插件效果    说明：使用jqueryui，HTML中不需要加任何class  //5.0在自定义的script中：$("插件父元素").插件函数()  

Ø 原理：jQueryUI插件函数，会根据自身的需要，自动为元素侵入class和自定义属性

Ø 致命缺点：仅有PC端，没有移动端！；可维护性差！所有class和事件绑定都是背着

程序员自动侵入的。程序员想改时，不知道改哪里！

Ø 仿着jQueryUI做法，封装一个自己的jquery插件：3步

  前提: 已经在页面中用传统的HTML+CSS+jQuery方式实现了插件的效果。封装插件其实只是一个提取代码的过程。而不是从0开始开发！  //1.0先提取css代码保存到独立的css文件中  //2.0在独立的js文件中，向jquery的原型对象中添加一个自定义的插件函数  jQuery.fn.插件函数=function(){      //2.1 给将来的插件元素们自动悄悄的添加所需的class——侵入             //2.2 将页面中已经实现的事件绑定代码，剪切到原型对象中插件方法结尾。  }  //3.0在页面中引用插件的css和js，并编写自定义脚本调用插件函数——过程和使用jqueryui的步骤完全一样！  将来如果希望重复使用这个插件，只要拷贝独立的.css和独立的.js文件到下一个项目即可！只需要一句话$(父元素).自定义插件函数()，就可立即应用插件  

示例：

| 将已经实现的手风琴效果封装为jQuery风格的插件 |
| -------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day04\course  |

## 10、ajax

### （1）回顾原生ajax

 

### （2）jQuery中的ajax

jQuery将最常用的发送ajax请求的4步或5步，都封装为一句话！

  $.ajax({      url:" ", //服务器端口地址      type:" ", //请求的类型（get或post）      data:{  //要发送到服务器的请求参数  参数1: 值，       参数2: 值，       …… : ……      },      dataType:"json", //让ajax自动调用JSON.parse()      success:function(result){  //回调函数: 成功收到响应结果后自动执行         //result：服务器端返回的结果被转为js中的对象或数组         //强调: 凡是想在ajax请求完成后，才执行的代码，必须放在success回调函数内!      }  })  

示例：

| 使用$.ajax()发送请求                                     |
| -------------------------------------------------------- |
| G:\Web2020\Stage  03\03_jQuery\day05\course 01_ajax.html |

 



 

## 11、跨域

l 跨域：一个网站中的网页，需要用到另一个网站的资源(文件,接口等)

Ø 比如：

  <link rel="stylesheet"  href="其它网站的.css">  <script src="其它网站的.js">  <img src="其他网站的图片">  $.ajax({  url:"其他网站的接口",  ... ...  })  

Ø 跨域的情况包括：

1)   域名不同

如：http://www.a.com下的网页想用http://www.b.com下的资源

2)   子域名不同

如：http://oa.tedu.cn下的网页想用http://hr.tedu.cn下的资源

3)   域名相同端口号不同，

如：http://localhost:5500下的网页想用http://localhost:3000下的资源

4)   协议不同

如：http://12306.cn下的网页想用https://12306.cn下的资源

5)   即使同一台及其同一个网站内，用域名与IP地址互访也算跨域

如：http://localhost:3000下的网页想用http://127.0.0.1:3000下的资源

 

Ø 问题：浏览器有一个“同源策略”——只对ajax起作用

同源策略：要求一个网站下的网页中编写的ajax代码只能请求自己网站提供的接口

不能请求其他网站提供的接口。

比如：loaclhost:3000 自己的index.html 页面请求localhost:3000自己内部的接口，可以正常访问

 



补充知识点：

| 快速创建服务器端node express项目脚手架代码                   |
| ------------------------------------------------------------ |
| 1. 安装工具 npm i express-generator –g ——可用于反复自动创建脚手架代码    2. 可直接使用的已经包含核心功能的服务器端nodejs express项目脚手架代码    2.1 选择你想创建项目的文件夹    2.2 express 项目名    2.3 安装node_moduels       cd 项目名  //进入项目目录       运行 npm i   3. 运行脚手架示例代码    3.1 Vscode打开刚创建的项目文件夹:    3.2 右键选择package.json，选在终端中打开    3.3   等弹出窗口中出现xxxx/xzserver>  \| 输入npm start按回车        看到: node ./bin/www，就算成功    3.4 打开浏览器，手动输入http://localhost:3000  回车       看到：Welcome  说明服务器中的网页也运行成功!          xxx |

补充知识点：

| 前后端分离：企业中普遍采用的项目开发方式  |
| ----------------------------------------- |
| 1)     前端和后端是两个完全独立的团队  2) |

 



 

## 六、Vue

学习vue常见单词：

| handler   处理 | methods  方法  | view  界面、视图           |
| -------------- | -------------- | -------------------------- |
| model   模型   | control   控制 | controller 控制器          |
| template  模板 | compile   编译 | Interpolation  插值 / 填空 |
| filter 过滤器  | colon   冒号   | shorthand   简写           |
| directive 指令 | component 组件 | computed 计算属性          |

## 1、Vue概述

l Vue：第三方开发的基于MVVM设计模式的渐进式的纯前端js框架

Ø 第三方开发：官网 cn.vuejs.org

Ø 基于MVVM设计模式：后面详细介绍

Ø 渐进式：可以逐步在项目中引入vue的功能。不必整个项目通篇使用vue。

Ø 纯前端js：不需要需任何后端技术，vue就可以在客户端浏览器中独立使用和运行

Ø 框架：已经包含核心功能的半成品代码（简单——避免大量重复的代码）

何时使用：适用于以数据操作为主的项目(WEB、APP)

——以数据增删改查操作为主的前端项目，都可以用框架开发

## 2、vue的使用

### （1）下载Vue

2种方式

1）只下载一个独立的vue.js文件，引入网页中使用——只适合初学者。

  原理：在全局创建一个种新的类型Vue： 构造函数和原型对象。

  最高版本：2.6 （分为开发版和生产版）

Ø 开发版

- F具有完备的注释、代码格式和见名知义的变量名F 带有极其友好的错误提示
- F 可读性好，用于开发和学习用
- F 体积大，下载慢，不便于生产环境（项目开发测试完，上线之后）使用

Ø 生产版：

F 删除一切注释和代码格式，极简化了变量名

F 删除了错误提示，不便于调试！

F 体积小，下载快，用于生产环境中

F 可读性差，不适合于开发和学习之用

2）下载Vue-CLI项目的脚手架代码——企业中使用

最高版本: 4.x



 

### （2）使用步骤

3步

  //1.0定义界面：3个要求  //1.1 整个界面必须包裹在唯一的一个父元素内，习惯上唯一父元素命名为id="app"  //1.2 找到整个界面中可能发生变化的位置，用{{变量名}}标记出来  //1.3找到触发事件的元素，在元素开始标签中绑定事件处理函数: @事件名="函数名  <div id="app">    {{变量名}}       <元素 @click="函数名称 ">     </div>  //2.0定义data对象和methods对象分别保存界面所需的所有变量和所有事件处理函数  var data={ 页面所需的变量: 初始值 }      var methods={         事件处理函数名(){             //要想操作data中的变量值，必须this.变量名才行！         }      }  //此时，data中的变量和methods中的方法不会自己长腿跑到页面上指定位置去  //3.0创建一个new Vue()对象，将要操作的界面和data和methods包裹在一起。  new Vue({      el:"#app", //只负责id为app的小区，及其子内容      data:data, //小区住户们所需的变量存在哪儿       methods:methods //住户们所需的事件处理函数存在哪儿     })  //new Vue()会自动将data中的变量和methods中的方法送到界面中指定的位置上  

示例：

| 我的第一个vue程序:                            |
| --------------------------------------------- |
| 代码：G:\Web2020\Stage 03\04_Vue\day01\course |

## 3、MVVM 

### （1）旧前端代码划分

3部分：

1）  HTML：只负责保存页面的静态内容

2）  CSS： 只负责保存页面所需的静态css样式

3）  JS： 负责所有页面上的增删改查操作！

缺点：HTML和css因为缺少程序必须的要素(变量、分支、循环)，就好像生活不能自理的小婴儿！所有增删改查操作，都要js程序来负责，导致大量重复的代码！

### （2）重新划分

l MVVM设计模式：对前端代码重新划分，还是3部分，包括：

1）  界面（View）：指网页中的元素和样式，一般指HTML+CSS。

其中HTML是增强版的HTML，支持变量，js表达式，分支和循环等程序要素。无需编写js，就可以在html上执行部分程序的操作。所以，可简化js程序的编写,避免大量重复编码

2）  模型对象（Mode）：专门保存页面所需的变量和事件处理函数的对象

3）  视图模型对象（ViewModel）：专门负责自动将变量和事件处理函数送到界面中指定

​            位置，————将界面中的元素和模型对象中的数据“绑定”在了一起。

绑定就是可以让页面元素内容和js程序中的数据保持一致。

Vue框架正是基于MVVM设计模式实现的！

### （3）Vue绑定原理

其实就是new Vue的原理

1）先创建一个vue类型的子对象

a)   引入data对象

​       i     将data{}对象引入new Vue()中并打散data{}对象，使data{}对象中每个属性都变为单独的属性，并直接隶属于new Vue()对象下

​      ii     new Vue()给data中每个属性添加访问器属性。今后，操作data中的属性，其实自动都是通过操作访问器属性实现的

​      iii     new Vue()还自动在每个变量的set()函数内植入了一个通知函数。只要外界试图修改data中属性的值，都会自动调用属性的set()函数，并自动发出通知。告知vue对象，哪个变量发生了变化

b)   引入并打散methods对象，使methods中所有函数默认直接隶属于new Vue()对象，methods中的函数进入new Vue()后和data中变量的访问器属性（保镖）是平级的，所以，methods中的方法想访问data中的变量，必须加this.变量名

2）构建虚拟DOM树：创建只保存可能变化的节点的简化版DOM树

a)   new Vue()会查找到el属性指定的界面上的父元素，扫描找到的父元素及其子元素。

碰到"@事件名=函数名"，就自动翻译为on事件名=函数名

碰到所有"{{变量名}}"，先将可能变化的元素对象加入到虚拟DOM树中，并且首次替换元素内容中{{变量名}}为变量的初始值

b)   当data中的变量被修改时，自动调用变量的set()函数，set()中内置的通知函数向vue框架发出通知，说xx变量发生了改变，框架会自动扫描虚拟DOM树，查找受本次变量修改影响的所有DOM元素，自动利用已经提前封装好的DOM增删改查操作，只更新页面上受影响的元素。其他不受该变量影响的元素，保持不变！

绑定原理图解：

 

  总结  1. VUE绑定原理: 访问器属性+虚拟DOM树 —— 8000      （学有余力）访问器属性+观察者模式+虚拟DOM —— 10000+  2. 虚拟DOM树的优点: 4点:    (1).  内容少！仅保存可能变化的元素。不变的元素一个都不包含   (2).  遍历快！   (3).  避免大量重复代码！——自动执行DOM增删改查操作   (4).  效率高！每次变量更改时，只修改个别受影响的元素，其他元素保持不变！  

## 4、绑定

### （1）绑定语法

l 绑定语法：Vue中在HTML内标记哪里可能发生变化的特殊语法。

只要HTML中一个元素的内容可能随变量自动变化，就要用绑定语法

| <元素>xxx{{变量名}}xxx</元素> | 1） {{}}中: 和ES6的模板字符串${}要求是一样的！  a）可以放：变量，算数计算，三目，有返回值的函数调用，创建对象，访问数组元素——所有有返回值的合法的js表达式  b）不能放：分支、循环等程序结果，以及其他没有返回值的js表达式！  2） 使用绑定语法的结果：  a）在创建虚拟DOM树时，该元素就会被自动加入到虚拟DOM树中  b）一旦new Vue()中{{}}中同名的变量发生变化，则new Vue()对象会自动将该变量的新值跟新到HTML中{{变量名}}位置替换 |
| ----------------------------- | ------------------------------------------------------------ |
|                               |                                                              |

### （2）指令directive

l 指令：Vue.js提供的，为HTML元素添加新功能的特殊属性——13个

包括：

| {{变量名}}    | 元素的内容可能随变量自动变化：{{变量名}}   ——插值语法        |
| ------------- | ------------------------------------------------------------ |
| v-bind        | 元素的属性值可能随变量自动变化   标准：<元素 v-bind:属性名="js表达式">  简写：<元素 :属性名="js表达式"> |
| v-show        | 控制一个元素显示隐藏  <元素 v-show="返回bool类型的js表达式"> |
| v-if   v-else | 控制两个元素二选一显示  <元素1  v-if="返回bool值的表达式">  <元素2  v-else> |
| v-else-if     | 控制多个元素多选一显示  <元素1  v-if="返回bool值的表达式">  <元素2  v-else-if="返回bool值的表达式">    ……  <元素n  v-else> |
| v-on          | 绑定事件  标准：<元素 v-on:事件名="处理函数名(实参值)">  简写：<元素 @事件名=" 处理函数名(实参值)"> |
| v-for         | 根据数组反复生成多个相同结构的元素  <要反复生成的元素  v-for=”(value,i) of 数组/对象”>  <要反复生成的元素 v-for="(值,下标) of 数组或对象" :key="下标">  <要反复生成的元素  v-for="i of 一个整数"  :key="i"> |
| v-html        | 要绑定的内容是HTML片段时  <元素 v-html="变量或js表达式">  </元素> |
| v-cloak       | 避免用户短暂看到{{}}，2步  1.0 CSS中必须添加:  [v-cloak] { display: none; }  2.0 <要隐藏的元素 v-cloak> |
| v-text        | 避免用户短暂看到{{}}，也可以用在元素的内容可能随变量自动变化  <元素 v-text="变量或js表达式"></元素> |
| v-once        | 今后只要一个绑定的值，在首次加载之后不再发生变化  <元素 v-once>{{变量或js表达式}}></元素> |
| v-pre         | 防止元素内容中的{{}}被new Vue()编译，保持{{}}原样显示  <元素 v-pre> ... {{xxx}}...</元素> |
| v-model       | 双向绑定  既能将new Vue()中模型对象中变量值的修改更新到页面上显示。又能将页面中元素内容发生的变化，自动更新回new Vue()中的模型对象中保存 |

##### 1）v-bind

如果元素的属性值可能随变量自动变化，则不能用{{}}标记！，要用v-bind。

如何：

| 标准：  <元素 v-bind:属性名="js表达式">  简写：  <元素 :属性名="js表达式"> | 原理：new Vue()在扫描页面时，只要发现v-bind，就会自动计算=""中的js表达式，并将计算结果自动设置为当前属性的属性值  强调：如果属性名前加了:，则=后""中不需要再写{{}}，""就充当了{{}}的作用！原来{{}}中能写什么，""中就能写什么！ |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例：

| 根据空气质量，动态显示不同的表情   代码：G:\Web2020\Stage 03\04_Vue\day02\course |
| ------------------------------------------------------------ |
|                                                              |

##### 2）v-show

控制一个元素的显示隐藏，用v-show

如何：

| <元素 v-show="返回bool类型的js表达式"> | 原理：new vue()扫描到v-show时，就会先自动计算=  后的js表达式的值，得到一个bool值  F 如果执行结果为true则，当前元素什么都不干，默认显示！  F 如果执行结果为false则，当前元素自动添加display:none，隐藏 |
| -------------------------------------- | ------------------------------------------------------------ |
|                                        |                                                              |

示例：

  vue实现弹出对话框          代码：G:\Web2020\Stage 03\04_Vue\day02\course  

##### 3）v-if和v-else

两个元素二选一显示，用v-if 和 v-else

如何：

| <元素1  v-if="返回bool值的表达式">  <元素2  v-else> | 原理：new Vue()扫描到v-if时，先自动计算=后表达式的值  F 如果v-if后表达式的值为true，则保留v-if所在的元素1，删除v-else所在元素2  F 如果v-if后表达式的值为false，则删除v-if所在的元素1，保留v-else所在元素2  强调：v-if和v-else两个元素必须紧挨着，中间不能插入其他元素     v-else后不要加任何=，和程序中if else的else后不加表达式道理一样 |
| --------------------------------------------------- | ------------------------------------------------------------ |
|                                                     |                                                              |

高频笔试题：v-show vs v-if 差别

  v-show通过display:none方式控制显示隐藏，因为不修改DOM树，所以效率略高  v-if通过删除元素方式控制显示隐藏，所以要修改DOM树，效率略低  

示例：

  实现登录和注销状态切换        代码：G:\Web2020\Stage 03\04_Vue\day02\course  

##### 4）v-else-if

多个元素多选一显示，用v-else-if。如何：

| <元素1  v-if="返回bool值的表达式">  <元素2  v-else-if="返回bool值的表达式">    ……  <元素n  v-else> | 原理：new Vue()扫描页面时，如果遇到v-if就先执行=后的表达式，获得bool值结果  F 如果v-if表达式的值返回true，则保留v-if，删除其余v-else-if和v-else的元素  F 如果v-if表达式的值返回false，则先后继续执行后续v-else-if的表达式。只要碰到一个v-else-if表达式的值为true，则仅保留着个v-else-if的元素，删除其余v-if v-else-if和v-else  强调：v-if、v-else-if和v-else多个元素必须紧挨着，中间不能插入其他元素     v-else后不要加任何=，和程序中if else的else后不加表达式道理一样。 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例：

  根据pm25数值，显示不同表情      代码：G:\Web2020\Stage 03\04_Vue\day02\course  

##### 5）v-for

根据数组中的内容反复生成多个相同结构的元素

如何：

| <要反复生成的元素  v-for=”(value,i) of 数组/对象”>     凡是用v-for时，必须同时绑定一个:key属性  <要反复生成的元素 v-for="(值,下标) of 数组或对象" :key="下标"> | 原理：  a)     new Vue()扫描到v-for，会自动遍历of后的数组或对象  b)     每遍历到数组中一个元素或对象中一个成员，都会将当前HTML元素自动创建一个新的副本  c)     在要反复生成的元素身上或其子元素中，可以将v-for的两个变量value和i用于动态绑定内容。其中: value变量会自动获得当前正在变量的元素值或属性值。i会自动获得当前数组元素的下标或对象成员的属性名。  强调：  a)     要反复生成的元素，只需要写一个当模板即可  b)     v-for一定要写在要反复生成的元素上，而不是要反复生成的元素的父元素上  c)     v-for of ，既可以遍历数组，又可以遍历对象  （统一了for in 和for of） |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| V-for还会数数  <要反复生成的元素  v-for="i of 一个整数"  :key="i"> | 原理：  a)     V-for从1开始循环，每次递增1，到of后给的整数值结束  相当于for(var i=1;i<=一个整数;i++){ ... }  b)     每循环一次就将当前元素创建一个新的副本  c)     变量i会依次接住每次+1后的新值。变量i可用于元素内容中的绑定语法。 |

高频面试题：

为什么使用v-for必须同时绑定一个 :key属性？

答：1） 因为v-for每次反复生成的元素之间除了内容之外，单看元素是无差别的。即使将来只更改了数组中一个元素值，因为v-for无法区分反复生成的多个元素，就无法只精准更新一个元素。V-for只能采用笨办法，将v-for负责的所有元素重新生成一遍。——效率极低。

​    2） 绑定一个:key属性，让v-for反复生成的每个元素都有一个唯一的标识。如果数组中某一个元素发生改变，v-for可凭借这唯一的标识找到一个页面元素，只更新一个页面元素即可。其余页面元素保持不变——效率高！

示例1：

| 使用v-for遍历数组和对象                                      |
| ------------------------------------------------------------ |
| 代码：G:\Web2020\Stage 03\04_Vue\day02\course  v-for 遍历数组图解：         v-for 遍历对象图解： |

示例2：

| 根据页数，生成分页按钮                        |
| --------------------------------------------- |
| 代码：G:\Web2020\Stage 03\04_Vue\day02\course |

##### 6）v-on

事件绑定

如何：

| 标准：  <元素 v-on:事件名="处理函数名(实参值)">     简写：  <元素 @事件名=" 处理函数名(实参值)"> | 注：  a)     如果处理函数不需要实参值，则()可省略: <元素 @事件名="处理函数名"  b)     页面所需的所有事件处理函数都应该集中定义在methods对象中 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例2：

| 点哪个div，喊哪个div疼                        |
| --------------------------------------------- |
| 代码：G:\Web2020\Stage 03\04_Vue\day02\course |

附加知识点：Vue中如何获得事件对象（Vue中如何获得鼠标点击位置）？

① 如果只获取事件对象，不需要传入其他实参值时： 同DOM

  <元素 @事件名="处理函数">  methods:{           //自动创建event对象     处理函数(e){         //e得到的事件对象和DOM中的事件对象完全一样！      }  }  

示例2：

| vue中获得鼠标点击位置                         |
| --------------------------------------------- |
| 代码：G:\Web2020\Stage 03\04_Vue\day02\course |

② 既想用事件对象，又要传入自定义实参值（面试题）

错误做法：

| 错误做法1：  <元素 @事件名="处理函数(实参值)">  methods:{      处理函数(形参1, e){      //虽然实参可以传进来，但是e就无法获得了！      }  } | 错误做法2：  <元素 @事件名="处理函数(实参值)">  methods:{      //实参放在第一个位置，形参却定义在第二个位置！位置就不对！      处理函数(e, 形参1){      }  } |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

正确做法：（面试题）

手动使用vue提供的$event关键词代替e，手动传参。

| //当事件发生时, vue会自动封装"DOM事件对象e"       <元素 @事件名="处理函数($event, 实参值)">  methods:{      处理函数(e, 形参1){    //e得到的就是DOM中的事件对象，用法也和DOM中一样      }  } | 强调：  a）$event:是vue自动封装的保存DOM事件对象的一个特殊关键词，可用于传参！  b）处理函数中$event与实参值的位置没有固定顺序，但是必须和methods中处理函数定义中的形参列表顺序保持一致！ |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例2：

| 点击按钮，既获得div名字，又获得鼠标点击位置   |
| --------------------------------------------- |
| 代码：G:\Web2020\Stage 03\04_Vue\day02\course |

 

##### 7）v-html

如果要绑定的变量值是一段HTML代码，则使用{{}}绑定，会保持HTML代码的原样，而不经过编译，直接显示在页面上。今后，只要要绑定的变量值是一段HTML代码，则必须用v-html指令代替{{}}来绑定。

如何：

| <元素  v-html="变量或js表达式">  </元素> | v-html会先将变量中的HTML片段交给浏览器解  析成可以给人看的东西，然后才替换进元素的内容  中 |
| ---------------------------------------- | ------------------------------------------------------------ |
|                                          |                                                              |

示例：

| 绑定HTML内容                                  |
| --------------------------------------------- |
| 代码：G:\Web2020\Stage 03\04_Vue\day02\course |

##### 8）v-cloak

当网速慢时，如果js代码还未下载执行，则用户有可能短暂看到页面上的{{}}语法。

想防止用户短暂看到{{}}时，v-cloak

如何：2步

| //1.0先在网页的style中定义一个属性选择器  [v-cloak]{ display:none }   //意为所有带有v-cloak属性属性的元素，暂时隐藏  //2.0在有{{}}内容的元素上加上v-cloak属性，不用加=  <要隐藏的元素 v-cloak> | 原理：在new Vue()下载执行前，先将所有带{{}}的元素暂时隐藏。等到new Vue()下载执行完，再自动将所有{{}}的元素显示出来。  结果：结果：所有带有v-cloak的元素，都暂时隐藏。直到new Vue()下载并执行完，自动找到所有v-cloak的元素，删除v-cloak属性。这些元素才显示出来！ |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例：

| 使用v-cloak防止用户短暂看到{{}}               |
| --------------------------------------------- |
| 代码：G:\Web2020\Stage 03\04_Vue\day02\course |

##### 9）v-text

防止用户短暂看到{{}}，还可以用v-text。

既然不想看到{{}}，就可以用一种特殊的指令代替{{}}，功能还一样！因为指令都是写在元素的属性中。即使没有加载完，用户也不可能看到元素的属性！

如何：

| <元素  v-text="变量或js表达式"> </元素> | 原理：当v-text的内容计算好之后，会自动将执行后的结果代替元素的内容 |
| --------------------------------------- | ------------------------------------------------------------ |
|                                         |                                                              |

注：

如果元素的内容就是由固定的内容和变化的变量拼接起来的，则被迫使用模板字符串！

<元素 v-text="`模板字符串`"></元素>

如果v-text后跟的是一个模板字符串，则可以省略""，只保留模板字符串的反引号``即可！

<元素 v-text=`模板字符串`></元素>

示例：

  使用v-cloak防止用户短暂看到{{}}  

##### 10）v-once

有些绑定只在首次加载时，修改一次。之后其他地方的修改，都不会影响这里的显示结果。如果一个元素之后不需要再更新，但是却占着虚拟DOM树中的一个位置，会影响虚拟DOM树的遍历速度！

如果只在首次加载时显示，之后其他地方修改，这里都不会受影响的绑定，可用v-once绑定。

如何：

| <元素 v-once>{{变量或js表达式}}></元素> | 原理：只在首次渲染页面时，替换元素的绑定语法内容。但是不会将当前元素加入虚拟DOM树。结果: 只在首次加载一次，之后都不会再改变。 |
| --------------------------------------- | ------------------------------------------------------------ |
|                                         |                                                              |

示例：

| 使用v-once绑定页面加载时间: |
| --------------------------- |
|                             |

##### 11）v-pre

极端的问题：如果元素的内容正文中刚好也包含{{}}，但是不想被vue编译，而是原样显示！

如何：

  <元素 v-pre>  ... {{xxx}}...</元素>  

示例：

| 防止内容中的{{}}被vue编译 |
| ------------------------- |
|                           |

## 5、双向绑定

使用之前的12种指令，的确可以将new Vue()中的变量值更新到页面显示。但是都无法将页面中用户输入的新内容，自动反向更新会new Vue()中保存。——（单向绑定）

今后只要希望自动获得用户在界面上输入或选择的新值，都只能用双向绑定！

l 单向绑定：只能将new Vue()中模型对象中变量值的修改更新到页面上显示。如果页面中元

素内容发生变化，无法自动将更改更新回new Vue()中的模型对象中保存

（之前的12种指令，都只是单项绑定而已）

l 双向绑定：既能将new Vue()中模型对象中变量值的修改更新到页面上显示。又能将页面中

元素内容发生的变化，自动更新回new Vue()中的模型对象中保存

如何：

| <表单元素 v-model:可能变化的属性="变量"> | 原理：v-model包含两部分原理  a)     从Model->View的绑定与之前讲解的绑定元素一样: 访问器属性+虚拟DOM树  b)     但是从View->Model的绑定是新的原理：new Vue()扫描到包含v-model的表单元素时，就自动为表单元素绑定onchange=function(){}事件处理函数。意为当表单元素的值发生改变时，就自动触发。然后，在onchange事件处理函数内，包含自动获取当前元素值并更新回Vue中指定变量中保存的语句。     强调：双向绑定几乎只用在表单元素上 |
| ---------------------------------------- | ------------------------------------------------------------ |
|                                          |                                                              |

### （1）绑定文本框和文本域

文本框内容一更新，立刻将新值自动更新回程序中的变量里。

如何：

| 文本框：  <input type="text"  v-model:value="变量">     文本域  <textarea v-model:value="变量">内容</textarea> | 原理：  a)     v-model:value会被自动翻译为oninput="function(){...}"事件绑定代码，并在事件处理函数中封装修改data中变量的代码  b)     只要文本框内容被修改，就触发DOM的oninput事件，自动执行修改data中变量的代码 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例：

| 根据文本框中输入的关键词搜索相关内容          |
| --------------------------------------------- |
| 代码：G:\Web2020\Stage 03\04_Vue\day03\course |

### （2）绑定radio元素（单选按钮）

备选项的value都是固定不变的, 所以肯定绑定的不是value属性，选中与不选中radio改变的其实是它的checked属性。所以如果双向绑定时应该用v-model:checked="变量"。

如何：

| <input type="radio"  value="写死的值" v-model:checked="变量"> |
| ------------------------------------------------------------ |
| 原理：  a)     从Model->View绑定时，v-model先自动用变量的值和写死的value值做比较。如果变量值==value值，则当前radio选中。否则如果变量值!=value值，则当前radio不选中。  b)     从View->Model绑定时，当用户切换选中状态时，自动触发onchange事件，onchange事件中只将选中的radio的值自动更新回v-model绑定的变量中。 |

示例：

| 切换选择性别                                  |
| --------------------------------------------- |
| 代码：G:\Web2020\Stage 03\04_Vue\day03\course |

### （3）绑定select元素（下拉选择框）

不是直接修改select元素的文本,而是通过选择option来改变select的value

如何：

| <select v-model:value="变量"> | 原理：  a)     从Model->View绑定时，v-model将变量值自动和每个option的value比较。哪个option的value值与变量值相等，就自动选中这个option  b)     从View->Model绑定时，当用户选中一个option时，option的value先交给select，成为整个select的value，然后v-model再将select的新value，自动更新回data中的src变量中保存。 |
| ----------------------------- | ------------------------------------------------------------ |
|                               |                                                              |

示例：

| 选择城市，查看城市图片                                       |
| ------------------------------------------------------------ |
| 代码：G:\Web2020\Stage 03\04_Vue\day03\course  Model->View         View->Model |

### （4）绑定checkbox元素（复选框）

用户选中或不选中checkbox时，更改的是checked属性。因此，不需要和value做比较,直接用checked属性绑定到一个bool值变量即可

如何：

| <input type="checkbox"  v-model:checked="变量">              |
| ------------------------------------------------------------ |
| 原理：  a)     从Model->View绑定，变量值为true，就选中；变量值为false，就不选中  b)     从View->Model绑定，用户选中checkbox，就将true传到vue中变量里保存。如果用户未选中checkbox，就将false传到vue中变量里保存。  强调：不需要写value，且checked值应该是一个bool值！true就选中，false就不选中 |

示例：点同意，启用表单元素

说明：select和checkbox都可以多选，但是多选非常麻烦，基础好的同学可以看小程序中扩展视频学习。——有难度，量力而为！

### （5）双向绑定简写

其实以上例子中v-model后的:value和:checked全都可以省略！

今后双向绑定只写<表单元素 v-model="变量">

因为v-model会自定区分该绑定哪个元素！不用人为区分！

## 6、绑定样式

### （1）绑定内联样式（style属性）

只修改个别css属性值时，首选修改内联样式: 

如：做游戏时，控制主角的方向；控制一个元素的显示隐藏: display:none等

如何：

① 不好的方法: 因为style属性值也是一个巨大的字符串，所以完全可以当做一个普通的字符串属性来绑定

| // 1.0  HTML中:       <元素 :style="变量">  // 2.0 new Vue()中:   data:{  变量:  "css属性1: 值1; css属性2:值2;..."  } | 问题：  因为多个css属性混在一个字符串中，无法对一个css属性值随意加减。不便于修改style中某一个css属性。 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

② 好的做法: 将整个style属性，看作一个对象来绑定

| // 1.0 HTML中   <元素  :style="变量">        自动翻译为："css属性:值; css属性:值;..."  // 2.0 new Vue()中  new Vue({  data:{       变量:{        Css属性:值,          Css属性:值,         ...  : ...       }      }  }) | 优点：  非常便于只修改其中某一个css属性！  vm.变量.css属性值="xxx"  //new Vue()之外修改时  或  this.变量.css属性值="xxx"  //new Vue()内部修改时 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例：

| 绑定style控制飞机飞行  代码：G:\Web2020\Stage 03\04_Vue\day03\course |
| ------------------------------------------------------------ |
|                                                              |

### （2）绑定class

批量修改多个css属性时，首选修改class属性

如：带样式的表单验证，提示信息在验证通过样式和验证失败样式之间来回切换，因为每种样式都包含多个css属性，所以用class批量修改是最划算的。

如何：

① 不好的做法:将class属性也当做普通的字符串来绑定。

| //1.0 HTML中       <元素 :class="变量">  //2.0 在new Vue() 中  new Vue({      data:{          变量: "class1  class2 class3 ..."      }  }) | 缺点：  不便于只操作众多class中的一个 |
| ------------------------------------------------------------ | ------------------------------------- |
|                                                              |                                       |

② 好的做法：将class属性看作一个对象来绑定

  // 1.0 HTML中       <元素 :class="变量"> "class1 ..."  // 2.0 new Vue()中  new Vue({      data:{       变量:{//自动翻译为(只有值为true的class，才会翻译进最终的class字符串)       class1: true,       class2: false,       ... : ...       }      }  })  

如果一个元素上既有固定不变的class，又有个别变化的class

  // 1.0 HTML中  <元素 class="固定不变的class" :class="变量">  // 2.0 new Vue()中  new Vue({      data:{       变量: {          可能变化的class: true或false,          ... : ...        }      }  })     //结果:class中值为true的class先编译为一个class字符串，然后再和不带:的class中固定的class字符串拼接在一起，形成最终的一个class，共同修饰这个元素。  

示例：

| 带样式的手机号格式验证                        |
| --------------------------------------------- |
| 代码：G:\Web2020\Stage 03\04_Vue\day03\course |

## 7、自定义指令

如果vue中13种指令不够你用的，你就可以给vue家添加自定义指令。

何时使用：如果希望在首次加载时，对元素自动执行某些操作时，就可以用自定义指令：

（如：让某个元素在页面加载时就自动获得焦点！）

如何使用：2步

| //1.0向vue家添加一个新的指令，并起一个指令名  Vue.directive("指令名",{ //强调: 定义指令时，指令名不要加v-前缀！      //将来当带有这个指令的DOM元素被渲染到页面上之后自动执行inserted回调函数      inserted(dom元素){         //形参dom元素会自动获得当前拥有该指令的DOM元素对象         //对当前拥有该指令的DOM元素执行原生的DOM操作      }  })  //2.0在HTML界面中某个元素上使用自定义指令  <元素 v-自定义指令名> //使用指令时，必须加v-前缀 |
| ------------------------------------------------------------ |
| 原理：  a)     new Vue()扫描界面时，发现v-前缀的指令，都回去Vue家找，有没有对应的指令对象。  b)     如果找到有对应名称的指令对象，就自动调用指令对象中的inserted()函数  c)     Inserted()函数中包含了对当前元素执行的初始化DOM操作！ |

示例：

| 让元素在页面加载时就自动获得焦点 |
| -------------------------------- |
|                                  |

 

## 8、计算属性

l 计算属性：自己不保存属性值，需要根据其他属性值经过复杂的计算得到自己的属性值。

Ø 为什么：因为通常需要结果复杂计算得出的结果，都不会保存在数据库中，自然后端也

 不会给我们提供现成的值直接使用。只能靠我们在前端，利用其它属性的值计算获得。

比如：购物车的总价: 计算过程复杂，又频繁发生变化的值，通常数据库里都不存。而是完全依靠客户端动态计算获得！

Ø 何时：只要界面上想要的值，后端没有直接提供，但是可以根据其他值计算获得，就用

计算属性。

如何：2步

  //1.0定义一个计算属性  new Vue({          el:"#app",      data:{         可直接使用的属性      },      methods:{         事件处理函数      },      computed:{         计算属性名(){ //计算属性虽然用法和属性一样，但是本质却是一个函数！             //根据data中其他属性值，经过复杂的计算获得一个最终的属性值             return  计算结果         }      }  })  //2.0在HTML中使用计算属性  比如: <元素>{{计算属性名}}</元素>  //强调： 计算属性虽然本质是函数，但是使用时不要加()，和data中的普通属性完全一样  //结果： 运行时new Vue()会自动计算计算属性的结果，代替{{计算属性名}}的位置  

computed和methods比较：

  (1). 用法:       a.  methods中的函数在HTML中使用时必须加()调用      b.  computed中的计算属性在HTML中使用时不用加()  (2). 效率: 当反复使用这个函数或计算属性时      a.  methods中的函数，每加一次()，就重复执行一次！——没必要      b.  computed中的计算属性结果，只在首次使用时计算一次，然后就被vue缓存起来。从第二次使用开始无需重复计算，就可直接使用缓存中的中。——效率更高！  

总结: 何时使用函数？何时使用计算属性？

  (1). 如果更侧重于使用函数的执行结果数值时，首选计算属性  (2). 如果不关心执行结果，反而更侧重于执行一项操作（比如: 发送ajax请求），首选methods中的函数。  

示例：

| 计算购物车总价 |
| -------------- |
|                |

 

 

 

 

 

## 9、过滤器

l 过滤器：专门对变量的原始值进行加工后再显示出来的一种特殊函数

Ø 为什么：有些时候，变量的原始值，不能直接给人看！人看不懂！所以需要先将原始值加工成人能看懂的内容，再显示出来

​      如：性别: 1和0，要翻译为男和女

​        时间:毫秒数，要翻译为年/月/日 时:分:秒 人才能看懂

Ø 何时：今后要显示的变量原始值不能直接给人看，需要加工时，就用过滤器。

如何：2步

​                                                                            // 1.0定义过滤器  Vue.filter("过滤器名",function( oldVal ){      return  过滤后的新值  })  // 2.0在页面上使用过滤器，如：      在绑定语法的{{}}中使用  <元素>{{变量 | 过滤器名}}</元素>          连接  // 结果：  (1).  new Vue()扫描到绑定语法中的|，就会去Vue家找有没有指定名称的过滤器函数  (2). 如果找到指定名称的过滤器函数，则自动调用过滤器函数:       a. 将|左边的变量的原始值自动传给过滤器函数的oldVal形参      b. 将过滤器执行的结果返回给new Vue()  (3).  new Vue()会用过滤器返回的加工后的结果，代替当前{{}}语法位置，显示给用户看。  

过滤器可以传参

  (1). 定义过滤器:         预留                Vue.filter("过滤器名",function( oldVal , 自定义形参){         return  根据不同的自定义形参，过滤出不同的新值      })  (2). 在页面上使用过滤器:       比如: 在绑定语法的{{}}中使用:       <元素>{{变量 | 过滤器名(自定义实参值)}}</元素>               连接     

多个过滤器可以连用

  <元素>{{变量 | 过滤器1 | 过滤器2 | ...}}</元素>  //强调: 过滤器连用时，每个过滤器既可能接住变量的原始值，又可能接住的是上一个过滤器加工后的半成品  

示例：

| 使用过滤器过滤性别 |
| ------------------ |
|                    |

 

​    

## 10、axios

每种框架或函数库中都提供了专门的发送ajax请求的函数。用哪个框架，就要使用对应的ajax函数，如： jquery: $.ajax() vue: axios.get() react: xxx angularJS: xxx 微信小程序:xxx

l axios：是基于Promise技术的，专门发送ajax请求的函数库——几乎专用于vue，但是其

他框架也可使用。

如何：

  //1.0 引入axios.js，获得一个axios对象  <script src="js/axios.min.js"></script>  <!--axios无需vue可独立运行！-->     //2.0因为大部分服务器端接口的域名和端口号部分都是一致的，只有服务端接口地址的相对路径部分不一致。所以axios允许先统一配置所有请求的基础路径  axios.defaults.baseURL="服务器端接口的统一基础路径"     //2.0 发送请求 get  / post  //① 发送get请求：  axios.get("/接口相对路径",{      params:{ 请求参数1: 值1, 请求参数2: 值2, ... }       })         自动翻译      //延迟!!!      .then(result=>{ //function(result){         //成功收到响应结果后，自动执行.then中的箭头函数         //result并不直接是返回结果，result.data  才是返回结果！         //且返回结果已经被自动转为js数组或对象了      })          结果：服务器接口地址?请求参数1=值1&请求参数2=值2&...     //② 发送post请求：  axios.post("/接口相对路径","请求参数1=值1&请求参数2=值2&...")      //延迟!!!      .then(result=>{         //result.data才是服务器端响应结果      })  

示例： 

| 使用axios发送三种请求                                        |
| ------------------------------------------------------------ |
| axios.defaults.baseURL="http://xzserver.applinzi.com";  axios.get("/index")     .then(result=>{console.log(result.data);});  axios.get("/details",{params:{ lid:5 }})     .then(result=>{console.log(result.data);})  axios.post("/users/signin","uname=dingding&upwd=123456")     .then(result=>{console.log(result.data);}) |

## 11、生命周期

dom中和jquery中，都有页面加载完成事件可以在页面加载完成后自动执行一些页面初始化操作（发送ajax请求以及事件绑定）。

但是dom中的window.onload和jquery中的$(function(){ ... })，都不属于vue。因为有个规定：

所有vue的js代码，都要写在new Vue()对象内部。new Vue()对象之外不应该有任何代码！

在Vue中也想在页面加载后自动执行一些初始化操作时，都要用生命周期来做。

l 生命周期：指一个Vue对象从创建到渲染出来让人看到所经历的整个过程。

Ø 可能经历4个阶段：（非常重要 要被背下来）

| 创建(create) ——必经阶段 | a)     创建new Vue对象，引入data对象，并请保镖  b)     暂时没有虚拟DOM树 |
| ----------------------- | ------------------------------------------------------------ |
| 挂载(mount) ——必经阶段  | a)     生成虚拟DOM树  b)     首次渲染页面内容                |
| 更新(update)            | 只有data中的变量被更改时，才触发更新阶段                     |
| 销毁(destroy)           | 只有调用$destroy()函数，销毁当前组件时，才触发销毁阶段       |

Ø 如果希望在某个生命周期阶段自动执行一件事情，就必须使用生命周期钩子函数

l 生命周期钩子函数：在vue对象创建到每个阶段时，自动调用的一种回调函数

Vue对象加载过程中，共经历8个生命周期钩子函数：

（每个生命周期阶段前后各有一个钩子函数）

  beforeCreate(){ ... }   a)    创建阶段(create)  created(){ ... }      beforeMount(){ ... }  b)    挂载阶段(mount)      mounted(){ ... }      beforeUpdate(){ ... }  c)    更新阶段(update)      updated(){ ... }      beforeDestroy(){ ... }  d)    销毁阶段(destroy)      destroyed(){ ... }  

Ø 发送ajax请求的代码应该放在？

答：mounted()中。

因为，此时既有了data对象，可保存axios请求回来的数据，又有了虚拟DOM树，也可以执行一些DOM相关的操作。

​      (1). 肯定不能放在update阶段！因为update阶段不是必经阶段，不一定总是执行。必须修改data中的变量才触发。如果不修改data中的变量是不会触发的。所以放在update中的代码，在页面首次加载时，无法自动执行！

​      2).可以放created()中但不保险，此时还没有虚拟DOM树，dom操作可能受影响

示例： 

| 测试生命周期钩子函数的自动执行，以及发送axios请求 |
| ------------------------------------------------- |
|                                                   |

## 12、组件

### （1）组件概述

l 组件：拥有专属的HTML+CSS+JS+数据的可重用的页面独立功能区域

Ø 何时：只要页面中出现可能反复使用的功能区域，都要封装为组件，再反复使用组件

如何：2步

  //1.0定义组件  Vue.componet("组件名",{ //强调:组件名不要用驼峰命名，多个英文单词要用-分割      //和new Vue()中几乎完全一样！每个组件其实就是new Vue()一个功能完全相同的小的分身而已。new Vue()负责监控整个页面，而组件负责监控自己负责的小范围区域而已。      //没有el了，取而代之的是一个template: `HTML代码片段`,      //组件的template中只能有一个唯一的父元素包裹  template: `HTML代码片段`, //因为这里是为将来反复使用这个组件定义的统一样式模板。将来使用这个组件时，反复创建的副本，和这里的HTML片段完全一样！      //data不再是一个对象，而变成一个可反复调用的函数      data(){ //将来每使用一次这个组件，就自动调用一次data()函数        return { //每次调用data()函数，都返回一个新创建的模型对象给当前这个组件的一个副本专属。——保证组件虽然可反复使用，但是数据是彼此隔离，互不影响的！  组件模板中所需的变量       }       },      //以下内容和new Vue()就完全一样了      methods:{  ... },      computed:{  ... },       //生命周期钩子函数      ...  ...  })  //2.0如何使用自定义的组件: 组件其实就是一个可反复使用的自定义HTML元素而已。组件名其实就是元素的标签名  <组件名></组件名>  

Ø 原理：

a)   new Vue()扫描页面时，碰到不认识的元素标签，就会去Vue家找有没有同名的自定义组件

b)  如果找到同名的自定义组件，则先用组件对象的template HTML片段代替页面上组件元素的位置

c)   自动调用一次data()函数，为本次组件的副本创建一个全新的专属的模型对象副本。——保证这个组件副本中操作模型变量，不影响其他组件副本中的数据

d)  最后为这次组件副本创建一个小快递员对象，保持组件范围内模型对象与界面之间的同步

示例： 

| 定义一个计数器组件，并在页面中反复使用                       |
| ------------------------------------------------------------ |
| 代码：G:\Web2020\Courseware\03_myNote\code\14_VUE component.html |

### （2）组件化开发

l 组件化开发：今后一个html页面其实都是由多个组件拼接起来的。今后拿到一个页面，第一件事应该是划分组件区域。然后由多人分头编写一个页面的不同区域。最后再将每个人编写的组件拼接到一起形成一个HTML页面给人看！

Ø 为什么：

1)   便于大项目的分工协作。并行开发。效率高！

2)   松耦合！组件与组件之间相对独立，互不影响。一个出错，不影响大家！

Ø 何时：今后几乎所有项目都采用组件化开发！

如何：3步

  // 1.0 拿到页面图片，划分组件结构，2个依据  a)     按功能 b） 按是否重用         // 2.0 划分了几个组件，就要创建几个独立的js文件，在独立的js文件中定义组件对象         // 3.0 将所有组件引入到.html页面中，由new Vue()经过反复扫描和替换过程，将所有组件内容最终拼接到一起给用户显示。  

### （3）子组件

Vue.component()创建的组件，称为全局组件。可在页面中任何位置随意使用。但是有些组件明显不能超出父组件的范围使用。一旦超出要么出错，要么没意义！如果限制一个子组件只能在其父组件范围内使用，就应该定义子组件，而不应该使用全局组件

l 子组件：限制一个组件只能在其父组件范围内使用。

如何：2步

  // 1.0 定义子组件对象  a)     子组件对象的内容应该和定义全局组件内容的要求完全一致！  b)     但是不能用Vue.component()创建，应该仅仅保存在一个普通的js变量里  c)     变量名应该是子组件名称的驼峰命名方式！  var 子组件名称={  template:  data(){    return { ….. }  }  }  // 2.0 必须在父组件对象中的components属性中，将子组件对象包含进来。  父组件对象: {      template:`...`,      data(){         return  { ... }      },      ...  ...,      components:{ 驼峰命名的组件变量名, ... ... }  }  结果: 凡是出现在这个父组件components中的子组件对象，就只能在当前父组件内使用。出了当前父组件使用，会报错！  强调：  a）子组件定义时的变量名是驼峰命名，在父组件模板中使用子组件标签时，应该用 - 。  因为components会自动将驼峰命名的组件变量名，翻译为-分割的名字。  b）将多个子组件引入到页面时，子组件必须在父组件之前引入！  

示例： 

| 不考虑数据情况下，将待办事项列表拆分为父子组件 |
| ---------------------------------------------- |
|                                                |

### （4）组件间数据传递

vue组件化开发中，子组件无权直接使用父组件的变量！要采用专门的方法，让父组件将自己的一个变量传递给子组件才行

如何：(父给子) 2步

​       // 1.0 父亲放数据: 父组件在template中   <子组件 :自定义属性="父要给子的变量">  //理解：父亲把自己的一个变量值放进孩子身上一个指定名称的兜里  // 2.0 孩子收数据: 子组件对象中:   子组件对象: {           props:[ "自定义属性" ], //孩子从父亲放东西的同名兜里取出父亲给的数据继续使用      template:`...子组件的模板中使用自定义属性名等效于使用父组件的变量值...`  }  强调:   a）通常为了保证一个东西在程序中只有一个统一的名称，便于维护，避免歧义，都会将父组件变量名和自定义属性起相同的名字。但不是必须。  b）props中的属性名 vs data中的变量  相同点: 都既可用于HTML中的绑定和指令，又可用于js中通过this.xxx访问  不同点: data中变量的值是组件内定义的; props中的属性值是外部给的！  

示例： 

| 实现待办事项列表的任务列表和添加和删除功能 |
| ------------------------------------------ |
|                                            |

## 13、SPA（Single Page Application）

l SPA （Single Page Application单页面应用）：整个应用程序只有一个完整的.html文件。其他所谓的"页面"，其实仅仅是组件而已

Ø 普通多页面应用 vs  单页面应用

|                         | 普通多页面应用                                               | 单页面应用                                                   |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 请求次数                | 每切换一次页面，都要重新请求服务器，重新下载页面——请求次数多，慢 | 在首次加载时就将唯一完整的HTML页面和其他"页面"组件片段，都下载到客户端。今后切换"页面"时，其实.html文件不动，只更新局部的组件内容即可。且不用向服务器重新发送请求。——请求次数少，快 |
| 页面加载效率            | 每切换一次页面，都要将旧的DOM树删除。下载新的页面后，重新建立完整DOM树——慢 | 因为每次切换页面，只更新局部内容，所以，不需要删除整棵DOM树，只更新局部的组件内容即可——快 |
| 多页面共享资源(boot,jq) | 每次切换页面都要把整个页面重新扫描一遍。扫描到link和script，会重新发送请求。——增大请求次数，浪费网络浏览量 | 完整的html文件只在首次加载一次，所以link和script，也只在首次下载一次。之后切换页面，link和script部分是不变的。所以，无需重复请求——减少请求次数，节约网络流量 |
| 页面切换动画            | 因为每次切换页面都是删除旧页面，下载新页面，导致前后两个页面不可能同时存在于客户端。——几乎无法完成页面切换动画。 | 因为单页面应用，所有所谓的页面都已经在客户端同时存在了。所以，完全可以实现页面切换动画 |

   

Ø 但是，传统大页面应用的缺点: 首屏加载极慢——因为首次加载时，就要把所有页面的组件都下载下来，东西多——慢

Ø 但是，大页面首屏加载慢的问题已经被解决了：——懒加载

Ø 今后几乎所有的框架都采用单页面应用的方式开发。

如何：

  // 1.0 先创建一个唯一完整的HTML文件，要求：  a)     具有标准的vue网页结构: 引入vue.js，<div  id="app">, new Vue({el:"#app"})  b)     必须引入vue-router.js  c)     在<div id="app">内必须用<router-view></router-view>为将来要加载的页面组件，占位  // 2.0 应用程序中要求有几个"页面"，就要创建几个子组件.js文件      var  对象名={         //内容同子组件完全一样！只不过当做页面用而已      }  强调：页面组件.js创建完之后，也要先引入唯一完成的HTML中     // 3.0 创建一个VueRouter对象，在对象中定义一个路由字典列表      var  router=new VueRouter({         routers:[ 相对路径    路径对应的页面组件对象            ↓        ↓             {   path:"/",  component: index },             { path:"/details", component: details},             ... ...         ]      })  强调: 创建完router对象后，一定要引入唯一完整的html页面中，还要将router对象加入new Vue()中。否则new Vue()不认识<router-view>标签！      new  Vue({         el:"#app",         ...,           router      })  

页面跳转：

  (1). HTML中写死的:       a.  不好的做法: <a href="#/相对路径">      b.  好的做法: 用<router-link>代替a         <router-link  to="/相对路径">xxx</router-link>   (2). Js中用程序跳转: 固定套路      this.$router.push("/相对路径")  

页面间传参：

  (1). 修改路由字典:                                                                                                                                                                                                                                      {  path:"/相对路径/:变量名", component: 页面组件对象, props:true }         Props:true  可将将来通过地址栏传的参数值，自动传给props中的同名变量。  (2). 上一个页面跳转时: 相对路径之后，只拼参数值即可         /相对路径/参数值   (3). 结果: 在接受参数值的页面中:      props:[ "变量名" ]      组件内部，可将变量名用于绑定语法。  强调： 一旦一个路径设置了/:变量名，则进入这个路径必须带参数值。否则，无法进入这个路径。导到404页面。  

示例： 

| 创建单页面应用 |
| -------------- |
|                |

## 14、脚手架

问题：当项目中组件非常多时，都会用专门的文件夹来分类组织不同的组件文件。便于查找和维护。但是，人和人创建文件夹的习惯和命名差异很大！结果，一个人建立的项目结构和另一个人建立的项目结构，很可能完全不一样！给开发人员接手和维护新项目带来了巨大的障碍。

解决：今后前端的所有框架以及后端的nodejs express项目，都已经有了标准化的脚手架项目结构。今后公司中开发，都是基于脚手架的标准项目结构进行开发的。

个项目的结构和另一个项目的结构几乎完全相同。开发人员接手和维护新项目时，几乎是无缝衔接！

l 脚手架：已经拥有半成品核心功能和标准化文件夹结构的项目源代码。

Ø 为什么：标准化和避免重复编码

Ø 何时：今后所有框架都是先创建脚手架，再在脚手架标准项目结构基础上添加个性化

功能定制。

### （1）创建和运行脚手架项目

1）创建脚手架项目: 2步

a)   先安装可反复创建脚手架项目的工具

  npm i -g @vue/cli //只安装一次就可反复使用  vue –V    //查看版本号，看到版本号，说明安装成功  

b)   再反复使用工具，反复创建不同项目的脚手架源代码：每做一个新项目都要重新创建一套标准的脚手架项目源代码

  vue create 项目名 回车  ? Please pick a preset: (Use arrow keys) //选择预设，用箭头键  default (babel, eslint) //默认  > Manually select features //手动选择功能  ? Check the features needed for your  project: (Press <space> to select,<a>  to toggle all, <i> to invert selection)  (*) Babel  将ES6,ES7代码翻译为所有浏览器都认识的传统的ES5以及以下代码  ( ) TypeScript  ( ) Progressive Web App (PWA) Support  (*) Router   VueRouter，是实现单页面应用的核心组件  ( ) Vuex  第三阶段暂时不选。但是今后所有项目都要选  ( ) CSS Pre-processors 如果项目中使用了sass或less，要对css进行预编译选  () Linter / Formatter 学习阶段取消选择！linter是代码质量检查工具。  ( ) Unit Testing   (  ) E2E Testing  ? Use history mode for router? (Requires proper server setup for  index fallback in production) (Y/n) N 回车  默认VueRouter采用"#/相对路径"，作为路由地址。但是有人讨厌#，想去掉，就可以开启history模式。一旦开启history，VueRouter采用"/相对路径"作为路由地址。  不要开启history模式，因为需要服务器端首页重定向功能的支持——专业的服务器端技术。  ? Where do you prefer placing config for Babel, ESLint, etc.? (Use  arrow keys)  In dedicated config files 放在多个不同的配置文件中  > package.json 集中放在一个package.json文件中  Save this as a preset for future projects? (y/N) N 回车  因为每个项目的配置可能各不相同，所以保存一套预设，意义不大！  看到successfully说明在硬盘上创建脚手架项目源代码成功！  🎉 Successfully  created project xzvue.  👉 Get started with the following commands:      $ cd xzvue      $ npm run serve  

2）首次运行脚手架项目: 用vscode运行

a)   用vscode打开新生成的项目文件夹xzvue

b)   右键选择package.json文件，选"在终端中打开"， 输入: npm run serve

​         i     自动启动了一个类似于live server和apache的临时服务器，用来保存项目的所有文件，供人们通过浏览器输入地址访问项目中的网页

​         ii     将项目源代码编译为所有浏览器都认识的HTML+CSS+JS代码。

c)   到: DONE Compiled successfully in 2982ms 编译成功

d)   按住Ctrl，点下方链接: Local: http://localhost:8080/，就打开浏览器查看默认的页面了

e)   在打开的浏览器中看到脚手架项目自带的首页

f)    脚手架已经包含了单页面应用的核心功能

​         i     包含两个页面: Home和About

​         ii     公共页头组件

​        iii     在页头点Home和About，可在两个页面间切换，说明已经创建VueRouter路由！

### （2）改造脚手架项目

1)   如果自己开发，不用git，可删除.git文件夹

 

2)   脚手架默认不带axios，所以需要安装axios

  a)     右键点击package.json，选择"在终端中打开"  b)     看到文字: xxx\xzvue> 输入 npm i -save axios  c)     看到 + axios@0.19.2 说明安装成功。  在node_modules文件夹，可看到axios文件夹  

3)   试着修改脚手架默认首页的内容

  a)     打开src/views/Home.vue  b)     <template>内是脚手架首页的HTML内容        i       删除<HelloWorld  msg="Welcome to Your Vue.js App"/>        ii       换成自己的内容: <h1>我的第一个脚手架项目</h1>       iii       删除<template>下方<script>元素及其内容。       iv       删除src/components/HelloWorld.vue组件文件  c)     如果刚才没有关闭npm run  serve，则每修改一次脚手架中源代码，只要Ctrl+S保存修改后，都会自动重新编译，不用反复运行npm run serve。就可以在浏览器中查看到新的修改后的效果。除非不小心把npm run serve关了。才需要重新运行npm run  serve。  

### （3）脚手架项目文件夹结构

1)   回顾：SPA应用程序的结构：4部分

  ① 唯一完整的HTML页面     a） 引入的文件，包括：           i       引入公共的bootstrap.css、jquery.js和bootstrap.js           ii       引入Vue单页面应用必须的js文件: vue.js 和 vue-router.js          iii       引入所有页面组件、全局组件          iv       引入路由器对象.js  b） 唯一父元素   <div id="app">          <router-view>停车位</router-view>        </div>  c） new Vue({          el:"#app",          router        })  ② 定义页面组件，习惯上所有页面组件.js放在一个专门的文件夹中, 习惯上名为views  ③ 定义VueRouter对象，并定义路由字典，通常放在router.js中  var router=new VueRouter({  routes:[        {path:"/", component:组件名},        {path:"/details/:lid",  component:组件名, props:true},        {path:"*", component:组件名}       ]  })  ④  多个页面共用的页头等组件通常定义为全局组件，习惯上全局组件或个别子组件.js放在一个专门的文件夹中，习惯上名为components  

2)   脚手架文件夹结构: 大致和SPA应用结构几乎完全一样。只不过个别地方划分更细致而已

  ①  唯一完整的HTML页面：被拆为三部分    a）public/index.html          i       /css 公共的资源文件bootstrap.css应该放在public/css文件夹，并引入到   index.html中          ii       /js 公共的js文件jquery.js和bootstrap.js应该放在public/js文件夹，并引    入到index.html中         iii       /img 项目中用到的所有图片，应该放在public/imgs文件夹中     注：不要在唯一完整的HTML页面中引入vue和vue-router.js了。因为脚手架采用模块化开发       页面组件和router对象.js不要在唯一完整的HTML页面中引入了。因为脚手架采用模块化开发，页面组件和router对象有专门的路径来保存       new Vue()也不要放在唯一完整的HTML页面中了       到此，今后index.html页面再不需要做任何更改！    b）src/App.vue文件中保存了<router-view>     <div  id="app">          <router-view></router-view>  </div>    运行时会用App.vue中的HTML内容代替index.html中的空<div id="app"></div>    c）src/main.js 文件中保存了new  Vue()     import Vue from  'vue' //以模块化方式引入vue.js       import App from './App.vue' //引入App.vue文件中的内容      import router from './router' //以模块化方式引入了new VueRouter()对象和路由  字典  Vue.config.productionTip = false  new Vue({ //创建监控整个页面的大的Vue对象（快递员）         router,         render: h => h(App) //加载App中的HTML内容       }).$mount('#app') //挂载到index.html中代替<div  id="app">位置  npm run serve 先执行main.js，引入App.vue中的内容，并用App.vue中的内容代替了index.html中空的<div id="app"></div>  ② 页面组件：     a）脚手架规定所有页面组件都应该放在src/views文件夹下     b）每个页面组件应该定义为一个xxx.vue文件，不是.js文件          i       vue中可同时包含一个组件的HTML+JS+CSS          ii       js中只能包含js和简单的HTML，无法包含组件的css内容  c）每个.vue文件都可以包含三部分内容:          i        <template>  <!--专门保存当前页面的HTML内容-->             <唯一父元素>                当前页面的HTML内容             </唯一父元素>          </template>          ii       <style scoped>             只写当前页面用到的css样式          </style>           因为将来所有.vue文件中的<style>都会被编译到一个.css文件中。极有可能造成不同.vue中的选择器和样式发生冲突！  所以<style>要写为: <style scoped> scoped会自动保证不同组件的样式只局限于当前组件，不影响其他组件。                                  iii       <script>            当前页面组件的组件对象js内容         </script>  ③ 创建路由器对象和路由字典: src/router/index.js  import Vue from 'vue' //引入vue.js  import VueRouter from 'vue-router' //引入vue-router.js文件       import Home from  '../views/Home.vue' //引入views文件夹下的首页.vue文件内容     Vue.use(VueRouter) //引入vue-router.js文件中的VueRouter对象     const routes = [  { //首屏加载的页面  path: '/',   name: 'Home',  component: Home   },  {//其它页面只有在用到时才懒加载      path: '/about',      component:() =>  import(/ *webpackChunkName: "about" */ '../views/About.vue')  }  ]     const router = new VueRouter({            routes //routes:routers  })     export default router //模块化开发: 抛出router对象，供其它文件引用                     //如果没有这句话，其它文件，引用不了router对象。  ④ 全局组件:   a）集中创建在src/components文件夹下  b）每个全局组件一个.vue文件  c）在定义组件时，全局组件和页面组件的内容没有任何差别，也都是包含三部分          i       <template>组件的HTML内容</template>          ii       <style scoped>组件的css内容</style>         iii       <script>组件对象的js内容</script>  d）必须在main.js中，引入components下的全局组件.vue文件，然后再用Vue.component()函数，将引入的组件内容变成全局组件:        import MyHeader from  "./components/MyHeader"       Vue.component("my-header",  MyHeader);  d）结果在src/views文件夹下的页面.vue中可用       <my-header></my-header>引入全局组件页头        

## 15、模块化开发

l 模块化开发：将每个页面和每个组件都看作是一个模块对象。

Ø 没有模块化开发时，网页中一个对象要使用其他组件对象，必须先将所有组件对象都引入.html中集中起来。再一个页面内，挑选哪个对象使用哪个组件。——不直观，不便于理解，不便于维护

 

Ø 模块化开发好处：哪个模块想使用另一个模块中的内容，可直接引用！不需要全都引入到html文件中，再使用。——直观，便于理解，便于维护

 

如何：2步

  // 1.0组件对象需要创建js对象，并将js对象抛出到外部，供别人选择引用       export default {//new Object()      对象的js成员  }                                                                                                                                                                                                                                         //2.0其他组件可使用以下方式，引入另一个组件抛出的组件对象  import 自定义变量名 from "另一个组件文件的相对路径"     //结果：在import所在的组件中，可通过自定义变量来使用引入的另一个组件的内容     特例：如果一个组件文件中没有js代码，则不需要export default，文件本身默认就是一个模块对象，就可以被别人import导入！     

## 16、懒加载

问题：默认情况下教授级会将所有以import方式引入的组件的HTML+CSS+JS等编译到一个app.js文件中——这个文件会很大，并且首屏下载慢。

​    

解决：懒加载（2种方法）

1）在编译时，将不同的组件编译到不同的js文件中，首屏加载时，先请求首屏组件的js，然后在低层悄悄异步下载其余组件的js——后续组件不影响首屏加载速度

如何：2步，都是在src/router/index.js中修改

  // 1.0 除首页组件之外，不要用import方式过早引入其余页面组件  // 2.0 除首页之外，其余路由字典中的对象，一律采用懒加载  {       path: '/details/:lid',       //只有当用户访问到/details/:lid路径时，才临时执行箭头函数，才临时执行import(...)       ///**/注释不能删除，它为将来分块打包时，当前组件所在的js文件起文件名。       //比如:  webpackChunkName: "details"       //结果:  Details.vue会被编译为一个details.js文件       component: () => import(/* webpackChunkName: "details" */  '../views/Details.vue'),          props:true  }  结果：  首屏index.vue和details.vue分别打包为两个js文件  首屏先下载app.js，然后再低层异步下载details.js，不影响首屏加载速度  问题：  不管用户是否会访问详情页，都始终悄悄下载details.js文件——偷跑流量            

2）在编译时，将不同的组件编译到不同的js文件中，首屏加载时，先请求首屏组件的js，但是如果用户暂时不访问其他组件时，就不提前下载其他组件的js文件

如何：前两步和第一种方法相同！但是需要多一步：在脚手架项目的根目录创建一个文件vue.config.js，在其中添加如下代码: 

  module.exports={     chainWebpack:config=>{       config.plugins.delete("prefetch")  //取消预加载   }  }  结果：      首屏加载时只加载app.js，只包含首页组件内容      只有用户访问/details/5时，才临时下载details.js文件      如果用户不访问/details/5时，是不会提前下载details.js文件的。——省流量  问题：其他组件加载可能稍慢  

## 17、脚手架中axios的使用: 

问题：笨办法，可以在每个组件中都引入axios，繁琐！

解决：其实只在main.js中引入一次axios，然后将axios放入Vue的原型对象中。所有组件对象都可以使用this.axios方式来使用统一的axios对象。 

因为所有组件都是Vue类型的子对象，都继承自Vue的原型对象。所以，在vue的原型对象中添加一个axios，则所有子对象不用重复创建，就可直接使用。

 

如何

  // 1.0  main.js中:      import axios from "axios"      axios.defaults.baseURL="http://xzserver.applinzi.com"      Vue.prototype.axiso=axios;  // 2.0   其余任何组件内:       this.axios.get("/相对路径").then(result=>{ ... result.data... })  

 



 

附：

常见问题：

1)   Error compiling template

答：HTML模板中语法写错了

2)   Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead. For example, instead of <div id="{{ val }}">, use <div :id="val">.

答：插值语法 中的 属性   已经 被   移除   用v-bind 或 冒号 简写 

代替   比如     代替div id="{{ val }}"> ← 用<div :id="val">

3)   vm.pm25，为什么不是 vm.data.pm25

答：data中的变量，一旦进入new Vue()，就立刻被改名换姓保护起来。new Vue()会自动为每个变量添加一对儿访问器属性。获取变量值和修改变量值，只能通过访问器属性操作

所有自动添加的访问器属性，都直接隶属于new Vue()对象。

所以, vm.pm25，我们以为访问的是data中的pm25变量。但是实际上访问的是vm自动创建的访问器属性pm25

4)   Property or method "uname" is not defined on the instance but referenced during render. Make sure that this property is reactive, either in the data option

属性或方法 xxx是未定义的在(new Vue)实例中，却在加载过程中引入了，请确认    这个属性 是 响应式的 而且 在data参数中 

答：html中绑定的属性或函数，在new Vue()中未定义。

5)   Download the Vue Devtools extension for a better development experience

https://github.com/vuejs/vue-devtools

vue.js:8553 You are running Vue in development mode.

Make sure to turn on production mode when deploying for production.

See more tips at https://vuejs.org/guide/deployment.html

答: 这个不是错误。是因为我们正在使用开发版，提示我们如果发布上线时，记得切换成生产版。这个提示不用在意。

6)   @click="doit(-1)"，如果执行时是doit(-1)，this应该指向window，就算是按钮调用的doit(-1)，其中this也应该指按钮。为什么doit()里的this->new Vue

​    答: 只要是new Vue中的this，一定都指向new Vue对象本身。由new Vue()底层维护的

7)   开启chrome的自动翻译功能，导致vue不能用

​    答: 只要使用vue就不能开启Chrome的自动翻译功能，有冲突



# 第四阶段

## 一、VueUI

## 1、组件库基础

l 组件(component)：是企业为提升开发效率而开发的对于相关的结构（ <template> ）、 样式( <style> )、        行为( <script> )的封装，并且提供了简单的调用方式，可以让开发者快捷的实现业务功能。

l 组件库：指由组件形成的完成的功能体系。

Ø 组件库的优势：

F 提升开发效率

F 简化调试步骤

F 便于团队协作

F 提升项目的可维护性

Ø 组件库分类

F 移动端组件库：

  Mint UI（饿了吗） -- http://mint-ui.github.io/#!/zh-cn

  Vant UI（有赞）  -- https://youzan.github.io/vant/#/zh-CN/

  Cube UI（滴滴）  -- https://didi.github.io/cube-ui/#/zh-CN

F 桌面端组件库：

  Element UI(饿了吗)  -- https://element.eleme.cn/#/zh-CN

  AT-UI (凹凸实验室)  -- https://at-ui.github.io/at-ui/#/zh

  View UI(视图更新)  --  https://www.iviewui.com/ 

## 2、Mint UI基础

### （1）安装Mint UI

第一步：启动操作系统的命令行，并且切换到脚手架所在目录

第二步：输入以下命令

  npm install --save mint-ui  

注：脚手架安装的模块信息存储在package.json文件中

### （2）引入Mint UI

在`main.js`中完成以下操作

  //导入Mint UI  import MintUI from "mint-ui";     //导入Mint UI样式表文件  import "mint-ui/lib/style.min.css";     //通过Vue.use()方法使用Mint UI插件  Vue.use(MintUI);  

## 3、使用Mint UI

Mint UI组件库由3部分构成：css组件、表单组件、js组件

### （1）css组件

##### 1）reset.css

每个浏览器对于HTML 元素都有默认的样式，但是这些默认样式在不同浏览器中是不相同的。为了保证所有的浏览器的默认样式是一致的，建议使用reset.css对于HTML元素的样式进行重置。操作步骤如下：

A.下载reset.css

B.将其存储到public/styles目录内(提示：存储样式表文件的目录建议命名为style/styles/css)

C.在public/index.html添加以下代码

  <link rel="stylesheet" href="/styles/reset.css">  

##### 2）header组件

Header组件用于实现顶部导航，其语法结构是： 

| <mt-header   title="标题信息"   fixed>     </mt-header> | title：属性用于设置标题信息，string类型  fixed：属性用于控制是否固定在页面的顶部，boolean类型 |
| ------------------------------------------------------- | ------------------------------------------------------------ |
|                                                         |                                                              |

<mt-header>组件最终形成的HTML代码如下：

| <header>       <div></div>       <h1>标题</h1>       <div></div>   </header> | a）其中标题信息(title)放置在<h1>元素内；  b）两个<div>元素是两个插槽（slot），可以通过子元素的slot="left"或slot="right"属性控制元素 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例：

  G:\Web2020\Courseware\03_myNote\code\15_VueUI\Mint UI \Header.vue  

##### 3）button组件

<button>组件用于实现按钮，其语法结构是：

| <mt-button      type="按钮类型"      size="按钮尺寸"      icon="图标类型"      disabled>  </mt-button> | type：属性用于控制按钮的类型，其值包括：  default(默认)、primary(主要)、danger(危险)  size：属性用于控制按钮的尺寸，其值包括：  small(小的)、normal(标准)、large(大的)  icon：属性用于控制按钮图标类型，  其值包括：back(返回)、more(更多)  disabled 属性用于控制按钮是否禁用，boolean类型 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

可通过为图像添加slot="icon" 属性，将图像作为按钮的图标，如：

  <mt-button type="primary">     <img src="../assets/images/reload.png" slot="icon">  </mt-button>  

注：提示：按钮图标的尺寸一般为16x16、20x20、24x24、32x32

##### 4）顶部选项卡

| <mt-navbar fixed v-model="变量名称">  <mt-tab-item id="当前选项卡的ID">  </mt-tab-item>  ...  </mt-navbar> | fixed 属性用于控制顶部选项卡是否固定在页面顶部，boolean类型  v-model指令绑定的变量类型为字符类型，其应该为当前被激活的选项卡的ID  <mt-tab-item>中可以嵌套图像，并且为图像设置slot="icon"属性，此时图像将作为选项卡的图标 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例：

| G:\Web2020\Courseware\03_myNote\code\15_VueUI\Mint UI \navbar.vue |
| ------------------------------------------------------------ |
| <template>   <div>    <mt-navbar v-model="active">     <mt-tab-item id="1">      <img src="../../assets/images/html.png" slot="icon">      HTML     </mt-tab-item>     <mt-tab-item id="2">      CSS      <img src="../../assets/images/css.png" slot="icon">     </mt-tab-item>     <mt-tab-item id="3">      JavaScript      <img src="../../assets/images/javascript.png" slot="icon">     </mt-tab-item>    </mt-navbar>   </div>  </template>  <script>  export default {   data(){    return {     active:"1"    }   }  }  </script> |

##### 5）面板组件

| <mt-tab-container   v-model="变量名称"   swipeable>  <mt-tab-container-item id="当前面板的ID">  ...  </mt-tab-container-item>  ...     </mt-tab-container> | v-model指令绑定的变量类型为字符类型，其应该为当前被激活的面板的ID  swipeable用于控制面板是否具备滑动效果，boolean类型 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例：

| G:\Web2020\Courseware\03_myNote\code\15_VueUI\Mint UI \ tabcontainer |
| ------------------------------------------------------------ |
| <template>   <div>    <!-- 顶部选项卡开始 -->    <mt-navbar v-model="active">     同上    </mt-navbar>      <!-- 导部选项卡结束 -->    <mt-tab-container v-model="active">      <mt-tab-container-item id="1">       AAA      </mt-tab-container-item>      <mt-tab-container-item id="2">       BBB      </mt-tab-container-item>      <mt-tab-container-item id="3">       CCC      </mt-tab-container-item>    </mt-tab-container>   </div>  </template>     <script>  export default {   data(){    return {     active:'1'    }   }  }  </script> |

##### 5）底部选项卡

| <mt-tabbar v-model="变量名称" fixed>    <mt-tab-item id="当前选项卡的ID">      ...    </mt-tab-item>    ...  </mt-tabbar> | v-model指令绑定的变量类型为字符类型，其应该为当前被激活的底部选项卡的ID  fixed属性用于控制是否在页面底部固定选项卡，boolean类型 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

例：

| G:\Web2020\Courseware\03_myNote\code\15_VueUI\Mint UI \ tabcontainer |
| ------------------------------------------------------------ |
| <template>   <div>    <div class="main">      <p v-for="(v,k) of 100" :key="v">{{k}}</p>    </div>      <mt-tabbar v-model="selectedTab" fixed>     <mt-tab-item id="home">       <img src="../../assets/images/home.png" slot="icon">首页     </mt-tab-item>     <mt-tab-item id="cart">       <img src="../../assets/images/cart.png" slot="icon">购物车     </mt-tab-item>     <mt-tab-item id="my">       <img src="../../assets/images/my.png" slot="icon">我的     </mt-tab-item>      </mt-tabbar>   </div>  </template>  <script>  export default {     data(){    return {     selectedTab:'home'    }}}</script> |

作业：

​                               

##### 6）cell组件

Cell组件用于实现单元格，语法结构是

| <mt-cell    title="标题"    label="备注信息"   value="内容"    isLink   to="目标路由">  </mt-cell> | a） 在单元格中嵌套图像并且设置slot="icon"属性的话，可以将图像作为单元格图标  b）value中的内容，也可以直接写在<mt-cell>标签内 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

例：

  G:\Web2020\Courseware\03_myNote\code\15_VueUI\Mint UI \ Cell.vue  

##### 7）cell-swipe组件

cell swipe组件用于实现可滑动的单元格，其语法结构是：

| <mt-cell-swipe                    title="标题"       label="备注信息"      value="内容"      isLink      to="目标路由"      icon="单元格图标(more\|back)"      :left="左侧按钮组"      :right="右侧按钮组">   </mt-cell-swipe> | 按钮组的数据类型是array,语法结构是：  :right="[  {  content:"按钮显示文本",  style:{CSS属性名称:值,CSS属性名称:值,...},  handler:()=>{    //按钮的行为  }  }   ]" |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

例：

  G:\Web2020\Courseware\03_myNote\code\15_VueUI\Mint UI \ Cell-swipe.vue  

##### 8）badge组件

badge组件用于实现徽章，其语法结构是：

| <mt-badge       type="徽章类型"       size="尺寸"       color="颜色">      ...  </mt-badge> | 徽章类型有:primary、success、warning、error  徽章尺寸有:small、normal、large |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

例：



  G:\Web2020\Courseware\03_myNote\code\15_VueUI\Mint  UI \Badage.vue  

### （2）表单组件

##### 1）Field组件

Field组件用于实现表单控件，其语法结构是：

| <mt-field    type="输入框的类型"    label="标签"    placeholder="占位符"   state="状态"   :attr="原生属性"   readonly   disabled   disableClear   v-model="变量名称">     </mt-field> | type属性用于控制输入框的类型，其值包括：  a)     text，单行文本框  b)     password，密码框  c)     textarea，多行文本框  d)     number,数字  e)     tel,电话  f)     url,URL地址  state属性用于控制输入框的状态，其值包括：  a)     success,表示成功  b)     warning，表示警告  c)     error，表示错误  :attr属性控制表单按件的原生属性，object类型，如：  <mt-field  type="text"  :attr="{maxlength:'10',autocomplete:'off'}">  </mt-field>  disabled属性控制表单控件是否禁用，boolean类型  readonly属性控制表单控件是否为只读，boolean类型  disableClear属性控制是否禁用表单clear按钮，booleanl类  为表单控件添加获得焦点或失去焦点的事件是：  @focus.native.capture 或@blur.native.capture |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

：

  G:\Web2020\Courseware\03_myNote\code\15_VueUI\Mint UI \Field.vue  

作业：

 

##### 2）复选框组件

复选框的语法结构是：

| <mt-checklist    title="标题"         align="对齐方式(left\|right)"   :options="选项列表"   v-model="变量">     </mt-checklist> | 强调：  :options属性必须存在, 属性为array类型，既可以直接存储字符串，也可以存储对象。如：  F 如果为字符串的话，则选定值即显示文本  F 如果为对象的话，则选定值为每个对象的value  v-model属性必须存在，且数据类型必须为array类型 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

options属性：

| :options="['学习','看电视','睡觉']"    :options="[      {       label:'学习',       value:'1'       },      {       label:'看书',       value:'2'      },      {       label:'运动',       value:'3'      }     ] | :options="['男','女','保密']"    :options="[       {        label:'男',        value:'0'       },       {        label:'女',        value:'1'       },       {        label:'保密',        value:'2'       }      ] |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

##### 3）单选框组件

单选框的语法结构是：

| <mt-radio    title="标题"   align="对齐方式(left\|right)"   :options="选项列表"  v-model="变量名称">     </mt-radio> | 强调：  :options属性必须存在属性为array类型，既可以直接存储字符串，也可以存储对象,如：  v-model属性必须存在，且数据类型必须为String类型 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

##### 4）开关组件

| <mt-switch    v-model="变量名称"    disabled>  </mt-switch> | 强调：  v-model指令绑定的变量类型为boolean类型 |
| ----------------------------------------------------------- | ---------------------------------------------- |
|                                                             |                                                |

### （3）JS组件

##### 1）toast组件

toast组件用于实现短消息提示框，语法结构是：

| //简洁语法  this.$toast("提示内容") | //标准语法  this.$toast({    message:"提示内容",    position:"位置(top\|middle\|bottom)",    duration:持续时间(单位为毫秒,默认为3000)，    iconClass:"字体图标类名称"  }) |
| ----------------------------------- | ------------------------------------------------------------ |
|                                     |                                                              |

：

  G:\Web2020\Courseware\03_myNote\code\15_VueUI\Mint UI \Toast.vue  

##### 2）Messagebox组件

Messagebox组件用于实现弹出式提示框，语法结构是：

| //简捷语法  this.$messagebox("标题","提示信息") | //标准语法  this.$messagebox.alert("提示信息","标题",选项)  this.$messagebox.confirm("提示信息","标题",选项)  this.$messagebox.prompt( "提示信息","标题",选项) |
| ----------------------------------------------- | ------------------------------------------------------------ |
|                                                 |                                                              |

选项的数据类型为Object,语法结构为：

  {   confirmButtonText:"确定按钮的文本",   cancelButtonText:"取消按钮的文本",   closeOnClickModal://是否单击遮罩层关闭对话框,   closeOnPressEscape:是否按ESC键关闭对话框,   lockScroll:是否锁定滚动条,   inputPlaceholder:"输入框的占位符"  }  

示例：

| G:\Web2020\Courseware\03_myNote\code\15_VueUI\Mint UI \Messagebox.vue |
| ------------------------------------------------------------ |
|                                                              |

 

##### 3）图像懒加载

<img v-lazy="图像的URL地址">

当通过v-lazy指令设置懒加载后，没有加载到的图像会自动添加lazy="loading"的属性，如

<img lazy="loading" ...>

如果需要设置其样式的话，可通过CSS实现，示例代码如：

  .articleImg img[lazy=loading]{

   width:100px;

   height: 100px;

  }

##### 4）无限滚动指令

<HTML元素 

​    infinite-scroll-distance="阈值"

​    v-infinite-scroll="方法名称"

​    infinite-scroll-disabled="变量名称"

​    infinite-scroll-immediate-check="true">

</HTML元素>

infinite-scroll-distance属性指距容器底部还有多少像素时触发无限加载的方法

v-infinite-scroll属性指在距离容器底部达到指定像素时需要执行的加载方法

infinite-scroll-disabled属性是保证执行完上一次的方法之前，若再次进行滚动范围时不再执行滚动方法，数据类型为boolean类型

infinite-scroll-immediate-check="true"属性，若为真，则指令被绑定到元素上后会立即检查是否需要执行加载方法，布尔属性

 

## 4、Moment

l Moment：是Javascript日期时间类库

Ø 安装

  npm install –save  moment  

Ø 通过Unix时间戳创建Moment对象

时间戳(timestamp),是指从公元1970年1月1日00::00:00到现在所经历的秒数。

  moment.unix(时间戳)  

Ø 在main.js中导入moment类库,代码如下：

  //Moment  import moment from 'moment';  Vue.prototype.moment = moment;  

l body-parser：body-parser中间件用于获取表单以POST方式提交的相关数据

Ø 安装

  npm install --save body-parser  

Ø 使用：

  //加载body-parser模块  const bodyParser =  require('body-parser');  //使用body-parser模块  server.use(bodyParser.urlencoded({      extended:false  }));         

l MD5：在MySQL数据库中存在MD5的函数，可以通过它实现字符串的加密操作，如

SELECT MD5('123');

Ø 安装：Node – md5模块

  npm install --save md5  

Ø 使用

  const md5 = require('md5');  //输出md5('1234567')的哈希值  console.log(md5('1234567'));  

 

## 5、Vuex

l Vuex：Vuex是一个专门为Vue应用程序而开发的状态管理模式，其可以实现在多个组件中共享状态。状态(state)理解为数据。如：用户登录信息、购物车。

Ø 安装

  npm install --save  vuex  

状态管理器建议存储在src/store目录内

Vuex与全局变量存在以下区别：

**1****）Vuex****中的数据是响应式的**

**2****）Vuex****中的数据不能直接进行修改，必须通过显示提交mutation**

Ø 核心概念

每一个Vuex应用的核心就是store,store是一个容器，包含了应用中共享的数据。其包含了：

1）state

state定义了应用中共享的数据，其数据类型可以为string、number、array、boolean、object等。

在组件文件中访问state中的数据，语法结构是：

  this.$store.state.变量名称  或  $store.state.变量名称  

2）mutations

mutations中需要定义一些方法/函数，通过mutations中的方法/函数来改变state中的数据，这是Vuex唯一的推荐方法.

每个mutations将接收state作为第一个参数，另外mutations只能进行同步操作（**不能发送异步请求**）

组件中调用mutations内的方法/函数

  this.$store.commit("函数/方法名称"[,额外参数])  

额外参数，也称载荷(payload)，是指除state外的参数,如果载荷由多个数据组成，则可以以数组/对象的形式将其组织起来。

 



 

## 6、xuqa项目

① xzqa数据表结构

数据库名称：xzqa

xzqa_category,存储文章的类型

| 字段名称      | 数据类型 | 描述                     |
| ------------- | -------- | ------------------------ |
| id            | SMALLINT | 文章类型的ID,主键且自增  |
| category_name | VARCHAR  | 文章类型的名称，唯一约束 |

xzqa_author,存储文章的作者

| 字段名称       | 数据类型  | 描述                            |
| -------------- | --------- | ------------------------------- |
| id             | MEDIUMINT | 作者ID,主键且自增               |
| username       | VARCHAR   | 用户名，唯一约束                |
| password       | VARCHAR   | 密码，MD5加密                   |
| nickname       | VARCHAR   | 用户的昵称                      |
| avatar         | VARCHAR   | 用户的头像，默认为值unnamed.jpg |
| article_number | MEDIUMINT | 用户发表的文章数量，默认为值0   |

xzqa_article,存储文章

| 字段名称    | 数据类型   | 描述                                |
| ----------- | ---------- | ----------------------------------- |
| id          | INT        | 文章ID，主键且自增                  |
| subject     | VARCHAR    | 文章标题                            |
| description | VARCHAR    | 文章简介                            |
| image       | VARCHAR    | 文章缩略图像,**可以为空**           |
| content     | MEDIUMTEXT | 文章正文(文章详细信息)              |
| category_id | SMALLINT   | 文章分类ID,外键，参照文章分类表的ID |
| author_id   | INT        | 作者ID,外键，参照作者表的ID         |
| created_at  | INT        | 文章的发表时间                      |

 

② WEB服务器

WEB应用的工作流程

 

创建WEB服务器

1）  创建空白目录，并且在Windows命令行中切换到该目录

2）  输入以下命令

  npm install --save express mysql cors  

3）  在WEB服务器目录下创建app.js，并且输入以下代码

  //引入Express模块  const express = require('express');  //创建server服务器  const server = express();  server.listen(3000);  

4）  启用并访问server服务器

启用：在命令行或VSCode终端中输入node app.js

访问：在浏览器中输入 http://127.0.0.1:3000

③ 客户端向服务器端发送请求

客户端向服务器发送HTTP请求

安装Axios

  npm install --save axios  

 

WEB服务器的修改流程：

第一步，ctrl+c，停止WEB服务器

第二步：根据需要修改服务器的相关配置

第三步：启动WEB服务器

④ 顶部选项卡及面板的实现

通过xzqa_category(文章类型表)中的记录来决定顶部选项卡及面板的数量和内容，其涉及到的问题有：

1)   什么事件下要发送AJAX请求到服务器，以获取相关的数据? -- mounted

Vue的生命周期及涉及的钩子函数，钩子函数有：

beforeCreate

created

beforeMount

mounted

beforeUpdate

updated

beforeDestroy

destroyed

2)   发送请求的服务器地址是什么?

规定获取文章类型的服务器API规范如下：

路由地址为 /category，

请求方式为get

3)   WEB服务器如何获取到指定数据表中的数据?

现在需要通过MySQL模块的来完成MySQL数据的增删改查操作

可以通过MySQL连接池提高查询效率。所以现在需要在WEB上加载MySQL模块并且进行相关的配置。

  //加载MySQL模块  const mysql = require('mysql');  //创建MySQL连接池  const pool = mysql.createPool({   host:'127.0.0.1', //MySQL数据库服务器的地址   port:3306, //MySQL数据库服务器端口号   user:'root',  //用户名   password:'',  //密码   database:'xzqa'//数据库名称  });  

​    

同时还需要在WEB服务器上创建名称为"/category"的路由，并且获取xzqa_category数据表的全部记录，同时将查询的结果返回到客户端

  //获取文章分类信息的API  server.get('/category',(req,res)=>{  //查询xzqa_category(文章类型)表中所有的记录   var sql = 'SELECT id,category_name FROM xzqa_category';   // MySQL连接执行查询操作   pool.query(sql,(err,results)=>{    //如果发生异常,则直接抛出异常    if(err) throw err;    //将相关的查询信息返回到客户端    res.send({message:'查询成功',code:200,category:results});   });  });  

 

4)   当客户端接收到服务器返回的数据后，如何动态实现顶部选项卡及面板？

当客户端接收到服务器返回的结果后，必须存储到自身的变量 -- 此时在data中声明category变量，用于存储服务器返回的数据 ，才可以在页面组件中使用。

代码如下：

  mounted(){   this.axios.get('/category').then((res)=>{    //将WEB服务器返回的文章分类信息存储到Vue的变量中    this.category = res.data.category;   });  }  

既然现在this.category已经是数组类型的数据了，那么就可以在<template>中通过循环结构来决定顶部选项卡的数量及内容了！-- 通过v-for指令实现，

代码如下：

  <mt-navbar v-model="active">    <mt-tab-item      v-for="(item,index) in category"     :key="index"     :id="item.id">    {{item.category_name}}    </mt-tab-item>  </mt-navbar>   

此时通过category变量不仅要控制顶部选项卡的数量及内容，**还要控制面板的数量**,所以还需要对于<mt-tab-container-item>进行循环操作,

代码如下：

  <mt-tab-container v-model="active">    <mt-tab-container-item      v-for="(item,index) in category"     :key="index"     :id="item.id">      ...    </mt-tab-container-item>  </mt-tab-container>  

 

⑤ 文章列表的实现

涉及到两种情况:

第一种：初始情况下要获取默认被选定选项卡的文章信息

"初始情况"已经表明事件 -- 涉及Vue的生命周期及钩子函数 -- mounted

1)   获取相关选项卡文章API的规定如下：

请求方式：get

路由地址：/getArticles

请求参数：cid,整数类型，代表文章分类ID

**2)**   **URL****地址栏传递的形式为：URL****地址?****参数名称=****值&****参数名称=****值**

此时客户端的代码如下：

  mounted(){    //获取默认选项卡包含的文章信息  this.axios.get('/getArticles?cid=' + this.active)  }  

目前代表已经向WEB服务器发送请求了，所以WEB服务器需要存在对应的路由信息，代码如下：

  //获取指定分类文章信息的API  server.get('/getArticles',(req,res)=>{  //获取地址栏请求参数 -- cid(文章分类ID)  var cid = req.query.cid;  //以获取到的cid参数为条件查询该分类下的文章信息  var sql = 'SELECT id,subject,description,image FROM xzqa_article WHERE category_id=?';  //执行SQL查询  pool.query(sql,[cid],(err,results)=>{    if(err) throw err;    res.send({message:'查询成功',code:200,articles:results});   });  });  

当成功运行后，服务器已经可以将查询结果返回给客户端，所以客户端需要接收数据，并且显示在页面组件中。

声明变量 -- articles用于存储WEB服务器返回的信息，代码如下：

  this.axios.get('/getArticles?cid=' + this.active).then((res)=>{     //将WEB服务器返回的文章信息存储到articles数组中     this.articles = res.data.articles;   })  在页面组件中循环 articles 变量，以输出该分类下的所有文章信息，代码如下：  <div class="articleItem"      v-for="(article,index) in articles"      :key="index">     ...  </div>  

第二种：在切换顶部选项卡时，要获取当前选项卡的文章信息

事件：就是在切换顶部选项卡时进行请求的发送，而可以通过watch监听到active变量的变化即可，代码如下：

  active(){   this.axios.get('/getArticles?cid=' + this.active).then((res)=>{   this.articles = res.data.articles;   })  }  

⑥ 首页记录分页及无限滚动的实现

1)   MySQL分页技术回顾

MySQL的分页实际上只是每次返回所需要结果的一部分。如果要从MySQL中获 取部分记录，就需要通过**SELECT****语句的LIMIT****子句**实现。

SELECT ... LIMIT [offset,] row_count

offset称为偏移值，是指从第几条记录开始返回，从0开始编号(与ID无任何关系)。

如果省略该参数，则从第0开始返回,如 

SELECT ... LIMIT 5 等价于 SELECT .... LIMIT 0,5

row_count指返回多少条记录,一般情况下，分页时设置为每页所需要的记录数。

offset参数涉及公式：**(****当前页码****-1)  \*** **每页显示的记录数**

| 页码 | 每页显示的记录数                | offset参数值            |
| ---- | ------------------------------- | ----------------------- |
| 1    | 10条                            | 0 (0 1 2 3 4 5 6 7 8 9) |
| 2    | 10 (10 11 12 ...19)             |                         |
| 3    | 20 (20 ... 29)                  |                         |
|      |                                 |                         |
|      |                                 |                         |
| n    | (当前页码-1) * 每页显示的记录数 |                         |

2)   首页记录分页及无限滚动的实现

1.初始情况下只需要加载20条记录

因为数据是来源于WEB服务器的，所以现在需要修改WEB服务器的程序代码才行。

2.每向下滚动距容器底部还有10个像素时再加载20条记录

3)   计算MySQL分页的总页数

MySQL中聚合函数（只存在一个返回结果）包括：

SUM,求和

COUNT，计数

AVG，计算平均值

MAX，最大值

MIN，最小值

总页数的计算公式是：

Math.ceil(总记录数 / 每页显示的记录数)

 

 



 

## 二、HTML新特征

## 1、视频和音频

### （1）视频和音频格式

浏览器支持的视频格式：.mp4、.webm、.ogg

| 浏览器  | MP4  | WEBM | OGG  |
| ------- | ---- | ---- | ---- |
| IE9+    | YES  | NO   | NO   |
| Chrome  | YES  | YES  | YES  |
| Firefox | NO   | YES  | YES  |
| Safari  | YES  | NO   | NO   |
| Opera   | NO   | YES  | YES  |

浏览器支持的音频格式：.mp3、.wav、.ogg

| 浏览器  | MP3  | WAV  | OGG  |
| ------- | ---- | ---- | ---- |
| IE9+    | YES  | NO   | NO   |
| Chrome  | YES  | YES  | YES  |
| Firefox | NO   | YES  | YES  |
| Safari  | YES  | YES  | NO   |
| Opera   | NO   | YES  | YES  |

### （2）标签和属性

视频的标签和属性

| 简捷方式  <video   width="宽度"   height="高度"   src="视频文件URL">  //视频格式不支持的提示文本  </video>  标准方式  <video width="宽度" height="高度">   <source src="视频文件URL"/>   <source src="视频文件URL"/>   ...  </video> | controls,控制是否显示媒体控件，布尔属性  autoplay,控制是否自动播放媒体,布尔属性  (该属性应与muted属性组合使用)  muted,控制播放媒体时是否静音,布尔属性  loop,控制媒体是否循环播放,布尔属性  poster,海报帧的URL地址  (海报帧图像的尺寸应该与视频尺寸相同)  preload="none/auto/metadata"  控制视频的预加载方式  none不缓存视频，以节省流量  auto播放前尽可能的加载视频的内容  (默认,适用PC端)  metadata只加载视频的时长、宽度、高度等元数据(适用移动端) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

音频的标签和属性

| 简捷方式  <audio src="音频文件URL">  //音频格式不支持的提示文本  </audio>  标准方式  <audio>   <source src="音频文件URL"/>   <source src="音频文件URL"/>   ...  </audio> | controls,控制是否显示媒体控件，布尔属性  autoplay,控制是否自动播放媒体,布尔属性  (该属性应与muted属性组合使用)  muted,控制播放媒体时是否静音,布尔属性  loop,控制媒体是否循环播放,布尔属性  preload="none/auto/metadata"  控制视频的预加载方式  none不缓存视频，以节省流量  auto播放前尽可能的加载视频的内容  (默认,适用PC端)  metadata只加载视频的时长、宽度、高度等元数据(适用移动端) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

 

## 2、HTMLMediaElement

### （1）HTMLDOM编程

l 大部分HTML元素的属性即HTMLDOM对象的属性

l HTML元素的class属性在DOM编程中采用className属性取代(因为class是ECMA的保留关键字)

l HTML元素的合成词属性（如cellpadding、bgcolor）在DOM编程中采用驼峰标记法表示(cellPadding、bgColor)

l HTML元素的style属性在DOM编程中将返回CSS2Properties/CSSStyleDeclaration对象，其语法结构是：

HTMLElement.style.CSS属性名称 = value

variable = HTMLElement.style.CSS属性名称

A.   单个单词的CSS样式直接书写

B.   带有短横线的CSS样式，首先去短横线去除掉后再采用驼峰标记法实现

pEle.style.color = 'red'

​         pEle.style.border = '2px solid #f00';

​         pEle.style.padding = '10px';

​         //带有短横线的样式,在DOM中首先去掉短横线,

​         //然后再采用驼峰标记法实现   

​         pEle.style.textAlign = 'center';

​         pEle.style.fontSize = '24px';

l 少数的HTML元素在DOM编程中有自己独有的属性/方法,如HTMLSelectElement有value属性

l HTML元素的布尔属性在DOM编程时采用boolean类型表示

### （2）基础

HTMLMediaElement对象提供访问HTML媒体(音频和视频)的属性和方法，其包含HTMLVideoElement和HTMLAudioElement两个子对象。

 

 

注：之所以所有的HTML元素都存在id,class、style等属性，因为所有的HTML元素都继承自HTMLElement接口，而HTMLElement接口又继承自Element接口，在Element接口中存在id、className、style等属性，所以现在所有的HTML元素都可以使用这些属性

### （3）属性

| autoplay     | autoplay属性用于控制是否自动播放媒体，语法结构是：  HTMLMediaElement.autoplay  = boolean value  variable =  HTMLMediaElement.autoplay |
| ------------ | ------------------------------------------------------------ |
| controls     | controls属性用于控制是否显示媒体控件，语法结构是：  HTMLMediaElement.controls  = boolean value  variable =  HTMLMediaElement.controls |
| muted        | muted属性用于控制是否媒体播放时是否静音，语法结构是：  HTMLMediaElement.muted  = boolean value  variable =  HTMLMediaElement.muted |
| loop         | loop属性用于控制媒体是否循环播放，语法结构是：  HTMLMediaElement.loop  = boolean value  variable = HTMLMediaElement.loop |
| volume       | volumn属性用控制媒体的音量，其值为0.0~1.0,共语法结构是：  HTMLMediaElement.volumn  = long value  variable =  HTMLMediaElement.volume |
| paused       | paused属性用于获取媒体是否正在暂停，语法结构是：  variable =  HTMLMediaElement.paused |
| playbackRate | playbackRate属性用于控制媒体的播放速度，1.0表示正常的速度，其语法结构是：  HTMLMediaElement.playbackRate  = long value  variable = HTMLMediaElement.playbackRate |
| duration     | duration 属性用于获取媒体的总时长，单位为秒，其语法结构是：  variable =  HTMLMediaElement.duration |
| currentTime  | currentTime属性用于获取媒体当前的播放时间，单位为秒，其语法结构是：  variable =  HTMLMediaElement.currentTime |

### （4）方法

| play()  | play()用于实体媒体的播放，其语法结构是：  HTMLMediaElement.play() |
| ------- | ------------------------------------------------------------ |
| pause() | pause()用于实现媒体的暂停，其语法结构是：  HTMLMediaElement.pause() |

### （5）事件

| canplaythrough | canplaythrough事件在媒体的状态改为"CAN_PLAY_THROUGH"时自动触发，其语法结构是：  HTMLMediaElement.addEventListener("canplaythrough",function(){         ...         ...  }) |
| -------------- | ------------------------------------------------------------ |
| timeupdate     | timeupdate事件在媒体元素currentTime属性发生变化时自动触发，其语法结构是：  HTMLMediaElement.addEventListener("timeupdate",function(){         ...         ...  }) |
| play           | play事件在媒体播放时自动触发，其语法结构是：  HTMLMediaElement.addEventListener("play",function(){         ...          ...  }) |
| pause          | pause事件在媒体暂停时自动触发，其语法结构是：  HTMLMediaElement.addEventListener("pause",function(){         ...         ...  }) |

## 3、Canvas

### （1）Canvas基础

l Canvas：是一个可以用JavaScript来绘制图形的HTML元素。

Ø Canvas元素的基本语法结构是：

| <canvas width="" height="">  </canvas> | Canvas元素默认宽度为300像素，高度为150像素，  canvas元素的宽高不建议使用CSS样式进行修改 |
| -------------------------------------- | ------------------------------------------------------------ |
|                                        |                                                              |

Ø Canavs的使用场景

数据可视化，如百度的ECharts

游戏画面

Banner广告

Ø HTMLCanvasElement对象

HTMLCanvasElement对象可以用于实现操纵Canvas元素的属性和方法

HTMLCanvasElement接口的继承关系如下：

 

Ø 属性

| width  | width属性用于获取/设置canvas元素的宽度，其语法结构是：  HTMLCanvasElement.width  = integer value  variable = HTMLCanvasElement.width |
| ------ | ------------------------------------------------------------ |
| height | height属性用于获取/设置canvas元素的高度，其语法结构是：  HTMLCanvasElement.height  = integer value  variable = HTMLCanvasElement.height |

Ø 方法

| getContext() | getContext()方法返回Cavans的上下文，如果没有上下文则返回null，其语法结构是：  HTMLCanvasElement.getContext('上下文类型')  上下文类型有：  1)        2d，将建立一个CanvasRenderingContext2D二维渲染对象  2)   webgl，将建立一个WebGLRenderingContext三维渲染对象     canvas理解为画布，那上下文对象可以理解为调料桶 |
| ------------ | ------------------------------------------------------------ |
|              |                                                              |

示例：

  <canvas id="canvas"></canvas>  <script>  //获取HTMLCanvasElement对象，操纵Canvas元素的属性和方法  var canvasEle = document.getElementById("canvas");  window.alert(canvasEle);  //[object HTMLCanvasElement]  window.alert(canvasEle.getContext('2d'));  //[object CanvasRenderingContext2D]  //设置HTMLCanvasElement的宽度和高度     canvasEle.width = 800;     canvasEle.height = 600;     //获取上下文对象     var ctx = canvasEle.getContext("2d");  </script>  

### （2）CanvasRenderingContext2D对象

l CanvasRenderingContext2D对象提供了在画布上绘制图形的方法和属性。

（画布的原点(0,0)是位于画布的左上角。）

Ø strokeRect()方法：用于绘制矩形框，其语法结构是

  CanvasRenderingContext2D.strokeRect(x,y,width,height)  x：距离原点x轴距离  y：距离原点y轴距离  width：矩形的宽  height：矩形的高  

Ø strokeStyle属性用于设置描边颜色，默认为#000，其语法结构是：

  canvas.strokeStyle = string color  颜色的表示方法有：  英文名称，如red,green,blue等  十六位进制，如#f00,#fa6900  RGB模式，如rgb(0,0,0)  RGBA模式，如rgba(0,0,0,.5)  

Ø clearRect()方法：用于清除指定区域所绘制的内容，其语法结构是：

  canvas.clearRect(x,y,width,height)  

​    示例：

   <canvas id="canvas" width="800" height="600"></canvas>   <script>    var canvasEle = document.getElementById("canvas");    var ctx = canvasEle.getContext("2d");    ctx.strokeRect(100,100,200,300);    ctx.clearRect(80,80,150,150);   </script>  </body>         

ex：

| 使用strokeRect()和clearRect()方法，实现矩形框在画布上的动画效果 |
| ------------------------------------------------------------ |
| G:\Web2020\Courseware\03_myNote\code\16_htmlCore\canvas   strokeRect()_animation.html  注：优化动画效果可使用requestAnimationFrame()方法  优化代码：requestAnimationFrame.html |

Ø fillRect()方法用于绘制填充的矩形，其语法结构是：

  CanvasRenderingContext2D.fillRect(x,y,width,height)  

Ø fillStyle属性用于设置填充颜色，其语法结构是：

  canvas.fillStyle = string color  注：设置填充颜色要在绘制之前，否则无效  

示例：

  <canvas id="canvas" width="800" height="600"></canvas>  <script>   var ctx = document.getElementById('canvas').getContext('2d');   //设置填充颜色   ctx.fillStyle = 'red';   //绘制填充矩形   ctx.fillRect(100,100,150,150);   </script>  

Ø fillText()方法：fillText()方法用于绘制填充文本，其语法结构是：

  canvas.fillText(text,x,y)  

Ø font属性：用于设置文本样式，其语法结构是：

  canvas.font = "字号 字体"  注：字号默认为10像素，字体为sans-serif  

Ø textAlign属性用于设置文本的水平对齐方式，其语法结构是：

  canvas.textAlign = "left|center|right"  

ex：

| 绘制柱形图                                                   |
| ------------------------------------------------------------ |
| G:\Web2020\Courseware\03_myNote\code\16_htmlCore\canvas    columnChart.html  //数组中每个对象的value属性值即柱形图的高度  //每个柱子的Y轴坐标为：画布的高度 - 每个对象的value值 |

Ø measureText()方法将返回TextMetrics对象，其语法结构是：

  TextMetrics canvas.measureText(文本内容)  注：TextMetrics将返回文本的相关信息，如尺寸  

Ø TextMetrics对象

  TextMetrics对象包含文本的相关信息，如尺寸  width属性，用于获取文本的宽度，语法结构是：  variable = TextMetrics.width  链式写法的原理：  对象的属性或方法的返回值或者函数的返回值是对象！！！  

ex：

| 用canvas实现弹幕的功能                                       |
| ------------------------------------------------------------ |
| G:\Web2020\Courseware\03_myNote\code\16_htmlCore\canvas \barrage.html |

### （3）window对象

JS由ECMAScript(简称ES)、DOM和BOM组成。

Ø window.requestAnimationFrame()方法是用于浏览器中定时循环操作的一个接口

主要用途是按帧(Frame)对于网页进行重绘,类似于window.setTimeout()方法。

其优势在于：

A、充分利用显示器的刷新频率(目前显示器的刷新频率为60Hz/75Hz，代表每秒重绘60次/75次)，不会出现抖动、卡顿的现象

B、如果网页标签页没有处于当前标签情况下，自动停止刷新，以节省CPU资源

其语法结构为：

  variable = window.requestAnimationFrame(函数名称)  注：函数中仅需要完成绘制的工作。variable变量用于存储该方法生成的timeID，该timeId可被用于到cancelAnimationFrame()方法中，以停止动画  

Ø window.cancelAnimationFrame()方法清除由requestAnimationFrame()方法所生成的timeId,语法结构是：

  window.cancelAnimationFrame(timeId)  

ex：

| 将弹幕与视频进行组合，并且可以实现关闭弹幕的功能             |
| ------------------------------------------------------------ |
| G:\Web2020\Courseware\03_myNote\code\16_htmlCore\canvas  video&canvas.html |

 



 

## 4、WebSocket

l WebSocket是一种网络通信协议，该协议最大的特点是：服务器可以主动向客户端推送消息，当然客户端也可以主动向服务器发送消息，是真正的平等双向对话。

WebSocket协议是2008年诞生的，2011年成为国际标准，目前所有主流浏览器都支持WebSocket.

之所以使用WebSocket的原因是： HTTP协议只能由客户端向服务器发送消息。

 

Ø WebSocket的优点：

F 数据格式比较轻量，通讯高效

F 没有同源限制，客户端可以与任何服务器通信

F 协议标识符为ws(如果加密则为wss)

l socket.io是一个为浏览器与服务器之间提供实时、双向、基于事件的通信软件库

socket.io内部对于websocket进行封装，抹平了一些技术细节及平台的兼容性。

Ø socket.io包括：

F Node.js服务器

F JavaScript客户端库

### （1）安装socket.io

① 服务器端

  npm install --save  socket.io  

② JavaScript客户端库

https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js

 

### （2）使用Socket.io

① 服务器端 – app.js

  //创建HTTP服务器  const app = require("http").createServer();  //将HTTP服务器注入到WebSocket服务器  const server = require("socket.io")(app);  //指定HTTP的监听端口  app.listen(5000);  

② 客户端 – 网页文件

  //1.0引入socket.io的客户端脚本文件  <script src="scripts/socket.io.js"></script>  //2.0创建socket客户端        var client = io("ws://websocket服务器地址")  注：只要引入了socket.io的客户端脚本文件，会自动暴露一个名称为io的函数  

 

③ 客户端的方法

| emit()方法 | emit()方法用于实现客户端向服务器广播事件，其语法结构是：  client.emit("事件名称",[数据])  如：client.emit("send message",{message:messageVal})  //send message是自定义事件名称，代表客户端向WebSocket服务器发送了消息 |
| ---------- | ------------------------------------------------------------ |
| on()方法   | on()方法用于实现根据指定的事件来注册一个函数(监听到服务器的事件，然后执行相关的操作)，其语法结构是：  client.on("事件名称",([data[,...]])=>{      ...  })  如：  client.on('boast message',(data)=>{    ……  }); |

④ 服务器的方法

  server.on("connect/connection")事件  该事件在客户端连接到服务器时触发，其语法结构是：  server.on("connect/connection",(client)=>{         //client代表是当前连接到服务器的客户端  });     on()方法用于实现根据指定的事件来注册一个函数(监听客户端的事件，然后执行相关的操作)，其语法结构是：  client.on("事件名称",([data[,...]])=>{    ...  })     emit()方法  emit()方法用于实现服务器向客户端广播事件，其语法结构是：  server.emit("事件名称"[,数据])     如：  //当前客户端连接到服务器时触发  server.on("connect",(client)=>{    //监听客户端的事件,并且完成相关的业务    client.on("send message",(data)=>{     //服务器向所有客户端广播事件     server.emit('boast message',{message:data.message})    });  });  

 

 

## 5、Web Storage

使用HTML5可以在本地存储用户的浏览数据。早些时候,本地存储使用的是 cookie。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能.

数据以 键/值 对存在, web网页的数据只允许该网页访问使用。

l Web storage提供了一种比cookie更加直观、更加便捷的数据存储方式，其结构为名/值对。

Ø web storage提供两种存储机制：

F sessionstorage:为指定的每一个源维护一个独立的区域，该存储区域的数据只在页面会话期间可用(只要浏览者关闭浏览器数据立即消失)

F localstorage: 为指定的每一个源维护一个独立的区域，该存储区域的数据一直有效，除非浏览者手动清除。

Ø setItem()方法：用于实现将键名添加到存储中，如果键名已经存在，则更新键值。

语法结构是：

  storage.setItem(key,value)  

Ø getItem()方法：用于返回指定键名的值

语法结构是：

  variable = storage.getItem(key)  注：如果指定的key不存在，则返回null  

Ø removeItem()方法：用于删除指定的键名，如果键名不存在，则不进行任何执行，

语法结构是：

  storage.removeItem(key)  

Ø clear()方法：用于删除所有的键名

其语法结构是：

  storage.clear()  

Ø length属性：用于返回storage中存储的数据项的数量

其语法结构是：

  variable = storage.length  

 



 

## 6、Vuex

### （1）回顾

l Vuex是一个专为Vue应用程序而开发的状态管理模式，它采用集中式的存储来管理应用中的组件状态。

每一个Vuex应用的核心就是store，store是一个容器，它包含了应用中、在各个组件共享的状态。

Ø state：定义了应用中状态的数据结构，可以为任意数据类型，如

| state: {  username:'Tom',  age:22,  sex:true, //true表示男,false表示女  salary:7896.33   } | 在组件中访问state数据:  {{this.$store.state.变量名称}}  {{$store.state.变量名称}} |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

Ø Getters：Vuex允许在store中定义getters(可以将其认为是store的计算属性)，它的返回值可依赖于store中的state(结果会被缓存起来)，只有当state发生变化时，才会重新计算。

定义getters，语法结构如下：

| getters:{      propertyName(state){         ...      }  } | state将作为getters中的唯一一个参数，该参数在调用时无需传递，Vuex将自动把state注入到该方法内。 |
| --------------------------------------------------------- | ------------------------------------------------------------ |
|                                                           |                                                              |

Ø Mutations：是状态改变的操作方法，也是Vuex修改state的唯一方法。其语法结构是：

| mutations:{      方法名称(state[,payload]){             ...      }  } | state将作为方法的第一个参数出现,  该参数在调用时无需传递，Vuex将自动把state注入到该方法内  payload，称为载荷，是指除state之外的参数；如果payload多个参数的话，建议使用对象  组件中调用Mutations：  this.$store.commit("方法名称"[,payload])  Mutations只能进行同步操作 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

Ø Actions：类似于Mutations，但是存在以下区别：

A.   Actions可以包含任何异步操作，而Mutations只能进行同步操作

B.   Actions提交的是mutation，而不是直接修改state

其语法结构是：

| actions:{      方法名称(context){             ...}} | 组件中调用Actions方法  this.$store.dispatch("方法名称") |
| --------------------------------------------------- | ------------------------------------------------------- |
|                                                     |                                                         |

### （2）Vuex中的辅助函数

Ø **mapState()**：用于为组件创建计算属性，以返回Vuex Store中的状态，其语法结构是：

| mapState(array\|object) | 例代码如下：  import {mapState} from 'vuex';  export default {   computed: {    ...mapState([     'username',     'age',     'sex',     'salary',     'products'    ])   },  } |
| ----------------------- | ------------------------------------------------------------ |
|                         |                                                              |

Ø **mapGetters()**：用于为组件创建计算属性以返回vuex getters中的返回值，语法结构

| mapGetters(array\|object) | 示例代码如下：  computed: {    ...mapGetters({      length:'counts'    })   } |
| ------------------------- | ------------------------------------------------------------ |
|                           |                                                              |

Ø **mapMutations()**：用于创建组件方法以提交mutation，其语法结构是：

| mapMutations(array\|object) | 示例代码如下：  import {mapMutations} from 'vuex';  export default {   methods: {    ...mapMutations([     'sAdd'    ]),    handler(){     //构建"商品"对象     var obj = {      productName:this.productName,      salePrice:this.salePrice     };     //调用Vuex的Mutations     //this.$store.commit('sAdd',obj);     this.sAdd(obj);     this.$router.push('/access1');    }   }  } |
| --------------------------- | ------------------------------------------------------------ |
|                             |                                                              |

Ø **mapActions()**：用于创建组件方法以分发Action，其语法结构是：

| mapActions(array\|object) | 示例代码如下：  <script>  import {mapState,mapActions} from 'vuex';  export default {   computed: {    ...mapState([     'data'    ])   },   methods: {    ...mapActions([     'getData'    ]),    handler(){      //this.$store.dispatch('getData');      this.getData();    }   }  }  </script> |
| ------------------------- | ------------------------------------------------------------ |
|                           |                                                              |

 

Ø 请简述VUEX的工作流程

**1.**   **Actions****发送异步请求到服务器，并且接收服务器返回的数据**

**2.**   **Actions****接收到数据后commit****到Mutations,****然后Mutations****操纵state****的数据**

**3.**   **state****数据发生变化后通知相关的组件,****组件数据发生变化。**

 

## 7、导航/路由守卫

l 导航：表示路由正在发生改变

Ø 全局前置守卫

| router.beforeEach((to,from,next)=>{   ...   next();  }); | to: Route: 即将要进入的目标路由对象  from: Route: 当前导航正要离开的路由  全局前置守卫中必须设置next() |
| -------------------------------------------------------- | ------------------------------------------------------------ |
|                                                          |                                                              |

目前在项目中有一些路由信息只能在用户登录后才可访问，而还有一些路由信息无论是用户登录与否都可以访问，所以目前就不能直接使用VUEX/WebStorage进行统一的条件判断了！所以只能在需要用户登录才能访问的路由上添加meta元信息，这样就可以区分哪些路由需要用户登录了！代码如下：

  {    path:'/register',    component:Register   },   {    path:'/me',    component:Me,    //在路由的头部添加元信息    meta:{     //requiresAuth是自定义的头部参数名称,     //标识访问该路由时是否进行用户登录的检测     requiresAuth:true    }   }  

接下来就可以通过全局前置守卫进行检测，代码如下：

   

**router****代表路由实例（也称路由表或路由器）**

**route****代表路由对象（URL****地址）**

## 8、拖放

l 拖放：是HTML5的新特性,即抓取一个对象从一个位置到另一个位置。

在HTML5中任何元素都可以拖放。

为了解决浏览器的兼容性问题，建议在拖放在文本类型的元素添加draggable="true"

### （1）DragEvent接口

l DragEvent接口：是表示拖、放事件的接口，该接口继承自MouseEvent接口，在DragEvent接口中包含的事件有：(源对象事件)

Ø dragstart，该事件在源对象开始被拖动时触发，其语法结构是：

  HTMLElement.ondragstart = function(){      ...  }  

Ø drag，该事件在源对象拖动过程中触发，其语法结构是：

  HTMLElement.ondrag = function(){      ...  }  

Ø dragend，该事件在源对象被拖动结束后触发（也可能在目标区域内，也可能在目标区域外），其语法结构是:

  HTMLElement.ondragend = function(){      ...  }  

目标对象事件 

Ø dragenter，该事件在源对象进入目标对象时触发，其语法结构是：

  HTMLElement.ondragenter = function(){      ...  }  

Ø dragover，该事件在源对象在目标对象上悬停时触发，其语法结构是：

  HTMLElement.ondragover = function(event){  event.preventDefault();   ...  }  

注意：dragover事件中必须执行event.preventDefault()，否则不会触发drop事件!!!

Ø dragleave，该事件在源对象拖离目标对象时触发，其语法结构是：

  HTMLElement.ondragleave = function(){       ...   }  

Ø drop，该事件在源对象在目标对象上释放时触发，其语法结构是：

  HTMLElement.ondrop = function(event){  event.preventDefault();  ...  }  

事件的触发顺序:

dragstart -> drag -> dragenter -> dragover -> drop -> dragend

### （2）dataTransfer属性

dragEvent接口的dataTransfer属性用于保存拖放数据，将返回DataTransfer对象

其语法结构是：

  DataTransfer  DragEvent.dataTransfer  

### （3）DataTransfer对象

Ø setData()方法：用于为一个给定的类型设置数据，如果类型不存在，则自动添加到未尾，如果存在的话，则替换原来的数据，其语法结构是：

  DataTransfer.setData(类型,数据)  

Ø getData()方法：用于返回指定类型的数据，如果类型不存在或者没有数据，则返回空字符串，其语法结构是：

  variable = DataTransfer.getData(类型)  

**逻辑删除的实现:**

**需要在对应的数据表中添加一个标识字段,****用于标识**

**记录的状态,****而且该字段只有两个状态,****假设0****表示正常状态,1****表示逻辑删除状态，另外逻辑状态的改变是通过UPDATE****语句实现。如站长推荐，是否热卖等都是如法炮制。**

## 9、Node中实现文件上传

### （1）标准的表单文件上传

**此时表单必须设置以下属性：**

² **表单的提交方式必须为POST**

² **必须设置表单的enctype="multipart/form-data"****属性**

**示例代码如下：**

 <form method="post" enctype="multipart/form-data" action="/single">

   <input type="file" name="avatar"><hr>

   <input type="submit" value="上传">

 </form>

### （2）Multer中间件

Multer 是一个 node.js 中间件，用于处理 multipart/form-data 类型的表单数据，它主要用于上传文件。

安装

npm install --save multer

https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md

 

 

 

## 三、微信小程序

## 1、JSON

l JSON(JavaScript Object Notation)： 是一种轻量级的数据交换格式。

Ø 官网：https://www.json.org/json-zh.html

Ø JSON建构于两种结构：对象与数组

Ø 对象的结构：

 

Ø 数组结构：

 

Ø 值的数据类型为：string、number、true、false、null、object,array

 

Ø 字符串的结构为：

 

## 2、微信公众平台

l 微信公众平台：基于腾讯提供的微信服务器和客户端APP,由更多的第三方服务提供者加入，为广大的微信客户端提供咨讯和服务。

Ø 域名：https://mp.weixin.qq.com

Ø 微信公众平台提供四种第三方服务类型：

F 服务号：对客户提供一对一的服务，如中国移动、中国联通、招商银行等, 适用人群：媒体、企业、政府或其他组织。

F 订阅号：向所有的订阅者提供免费的咨讯服务，适用人群：个人、媒体、企业、政府或其他组织。

F 小程序：在微信客户端提供类似APP功能的服务，达到“用完即走”的目的。

F 企业微信：为企业内部的员工提供日常办公支持，与微信消息、支付等互通。

## 3、微信小程序开发

### （1）概述

2010年微信内自带有WebView组件(本质就是解析HTML/CSS/JS解释器)就成为在微信内部浏览网页的标准,同时腾讯提供了扩展的JS API接口，但未公开。

2015年，腾讯发布了一整套的网页开发工具包，称为JS–SDK(Software Development Kit，软件开发工具包),开放了拍摄，录音、支付、分享等功能。

  但仍有些问题未解决，如页面首屏加载速度过慢、DOM操作太过繁琐、效率低等

2017年，微信张小龙团队推出了小程序技术(mini program)，基于已有的 JS-SDK，提供了一整套微信中创建和管理页面的解决方案

  单个小程序打包后（代码+图片+音视频等资源）所有文件不能超过2MB

  个大型小程序，可以拆分为多个子包（称为分包：subpackage），但所有分包加在一起不能超过12MB

2019年，发现了微信小程序的巨大平台引流能力后，支付宝、百度、头条.... 都陆续推出了自己的小程序

小程序与普通网页开发的区别

| 普通网页                                                | 小程序中的网页                                               |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| HTML标记，由W3C制定和维护的                             | WXML,由小程序提供的页面组件                                  |
| CSS样式，由W3C制定和维护的                              | WXSS,由小程序提供的样式语言                                  |
| JavaScript(ES、DOM、BOM)                                | ES(ECMAScript)、WXS、微信扩展API                             |
| 渲染线程和脚本线程是互斥的,任何时间只能执行其中的一件。 | 渲染线程和脚本线程是两个独立的线程,是异步执行的              |
| 可以使用ES、DOM及BOM                                    | 因为渲染线程与脚本线程是两个独立的线程，也就意味着脚本线程无法访问渲染线程，说白就是**不能进行任何的****DOM****和BOM****操作**。 |
| 需要考虑浏览器及设备的兼容性及                          | 基本上不需要考虑兼容性                                       |

### （2）开发环境

① 在微信公众平台注册开发者账号

注册地址https://mp.weixin.qq.com/wxopen/waregister?action=step1&token=&lang=zh_CN

注：邮箱要求：未被微信公众号注册，未被微信开放平台注册，未被个人微信号绑定的邮箱。

② 在微信公众平台注册账号：小程序账号 > 个人账号

③登录微信公众平台下的小程序账号，获取AppID ：开发 > 开发设置 > 开发者ID

④ 下载并安装微信小程序开发者工具（稳定版）

⑤ 启动微信开发者工具，使用AppID创建小程序项目

F 使用云开发：使用腾讯专为小程序提供的云数据库、云存储服务器；操作简单，无需购

买域名，一定范围内免费

F 不使用云开发：不使用腾讯专用的小程序服务器，但可以使用自己的云服务器，如新浪

云、阿里云服务器等

  注：创建小程序项目需要先在本地手动创建以字母、数字组合为名称的目录

 (微信小程序创建项目时不会自动创建目录，所以需先行手动创建项目目录)

### （3）目录结构

sitemap.json：小程序“站点导航图”配置——爬虫索引控制设置    

project.config.json： 项目在开发工具中的全部配置    

app.json： 整个项目的全局配置    

page.json： 每个页面的专有配置，可以覆盖全局配置    

.wxml文件：页面/组件模板文件    (不能使用HTML标签，例如、等只能使用小程序专有的标签)    

.wxss文件：页面/组件样式文件，语法与CSS相同，增加相对尺寸单位rpx     

app.wxss： 整个项目的公共样式     

page.wxss：每个小程序页面专有样式   

 .js/.ts：页面/组件脚本文件     app.js： 整个项目的入口脚本;     page.js：每个页面的专有脚本             

 注：app.json、app.js、app.wxss必须放置在小程序应用的根目录内。

project.config.json：项目的配置文件

  {      setting:{       "checkSiteMap":false      }  }=  

sitemap.json – 设置微信爬虫的爬取规则

  {      "rules":[             {               //是否允许索引指定的页面                "action":"allow|disallow",               "page":"页面的路径(必须存在于app.json中的pages数组内)",                "params":["参数名称1","参数名称2",...],                "matching":"页面地址的匹配原则(exact|inclusive|exclusive)"             }      ]  }  如：{   "rules": [    {     "action" : "disallow",     "page" : "pages/index/index"    },    {     "action" : "allow",     "page" : "*"    }   ]  }  

app.json

  {      //小程序的页面      "pages":["页面路径1","页面路径2",...],    //窗口的配置项      "window":{         "navigationBarTitleText":"标题文本内容",         "navigationBarTextStyle":"black|white",         "navigationBarBackgroundColor":"导航背景颜色",         "  enablePullDownRefresh":是否开启全局下拉刷新,         "backgroundTextStyle":"dark|light(下拉刷新时loading的样式)",         "backgroundColor":"窗口的背景颜色"    },      //底部的选项卡      "tabBar":{         color:"正常显示的文本颜色",         selectedColor:"激活的文本颜色",         //列出选项卡的信息(选项卡至少2个，至多5个)         "list":[           {              "pagePath":"页面路径，该路径必须存在于pages数组中",              "text":"显示文本",                "iconPath":"正常显示的图片路径",              "selectedIconPath":"被激活的图片路径"             }         ]      }  },  

强调：

a)   页面路径中不能带有扩展名;

b)   为了便于管理页面,每个页面必须单独创建目录,也就是说只要写以"pages/index/index"的结构即可;

c)   pages 数组的第一项代表小程序的初始页面（首页）

d)   tabBar中list用于指定底部选项卡的信息，选项卡数量至少2个至多5个

e)   list中的pagePage必须存在于pages数组中

示例：

| app.json的演示代码如下                              |
| --------------------------------------------------- |
| G:\Web2020\Courseware\03_myNote\code\17_MiniProgram |

### （5）wxss

l WXSS(Weixin Style Sheets)，是一套样式表语言，用于控制WXML组件的表现。

Ø WXSS基本上支持所有的CSS选择器，如ID选择器、类选择器、元素选择器、群组选择器、后代选择器等。

Ø app.wxss是全局样式文件，可作用于每一个WXML页面；

Ø page.wxss是针对于页面的局部样式文件；如果局部样式与全局样式冲突，则局部样式优先级高于全局样式。

Ø WXSS对CSS的扩展 -- 尺寸单位

rpx(responsive pixel,响应式像素)，可以根据屏幕宽度进行自适应的操作,规则屏幕宽度为750rpx

实际在屏幕的宽度： 设备的物理尺寸 X 宽度rpx / 750，如

| .box{     width:375rpx;  } | 在IPHONE6/7/8中的实际宽度为： 375 * 375 /  750 = 187.5px  在IPHONE6/7/8  plus中的实际宽度为： 414 *  375 / 750 = 207px |
| -------------------------- | ------------------------------------------------------------ |
|                            |                                                              |

### （6）组件

WXML中标签必须为双标签，如果为单标签的话，必须以/>结尾

##### 1）<view>组件

view组件是视图容器组件，其语法结构：

  <view   hover-class="按下去的样式类"   hover-start-time="按住多长时间会出现点击状(50毫秒)"   hover-stay-time="指定手动松开后点击状态的保留时间(400毫秒)"></view>  官方文档：https://developers.weixin.qq.com/miniprogram/dev/component/view.html  

示例：

| wxml:  <view   class="container"   hover-class="hover"  hover-start-time="100"  hover-stay-time="500"></view> | wxss:  .container{   width:375rpx;   height:200rpx;   border:2rpx solid #000;  }  .hover{   border:2rpx solid #00f;  } |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

##### 2）<image>组件

<image>组件是图片组件，支持GIF、JPG、PNG、WEBP、SVG，语法结构是：

  <image src="图像的URL地址" mode="缩放、裁切的模式" lazy-load="是否懒加载">  </image>  官方文档： https://developers.weixin.qq.com/miniprogram/dev/component/image.html  

注：

image组件的默度尺寸为320X240

mode用于指定图片的缩放、裁切模式，值包括：

scaleToFill,缩放模式，不保持横纵比缩放图片，将图片宽度拉伸到默认尺寸

aspectFit,缩放模式，保持横纵比缩放图片,让图片的长边显示出来

aspectFill,缩放模式，保持横纵比缩放图片让图片的短边显示出来

示例：

| wxml:  <image src="../../images/b8ef831ac7a94d08.jpg">  </image>  <image src="https://img30.360buyimg.com/pop/s590x470_jfs/t1/129759/33/546/58234/5ece7096Ed023063f/65c76df588218f06.jpg.webp">  </image> | wxss:  image{   width:100%;   height:280px;  } |
| ------------------------------------------------------------ | ---------------------------------------------- |
|                                                              |                                                |

##### 3）<swiper>组件

<swiper>组件是轮播图组件，语法结构是：

  <swiper       autoplay="是否自动播放"      indicator-dots="是否显示指点"      circular="是否衔接滑动"      interval="自动切换时的时间间隔(5000)"      duration="动画的切换时长(500)"      vertical="是否为纵向轮播图">      <swiper-item>...</swiper-item>  </swiper>  官方文档：https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html  

示例：

| wxml:  <swiper    autoplay="true"   indicator-dots="true"   indicator-color="#333"   indicator-active-color="#fff"   circular="true"   class="swiper">  <swiper-item>     <image src=".jpg"></image>   </swiper-item>     <image src=".jpg"></image>   </swiper-item>  ……  </swiper> | wxss:  image{   display: block;   width:100%;  }  .swiper{   margin:0 15rpx;  } |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

##### 3）<text>组件

<text>组件是文本组件，其语法结构是：

  <text selectable="文本是否可选" decode="是否解码">      ...  </text>  官方文档：https://developers.weixin.qq.com/miniprogram/dev/component/text.html  

示例：

| wxml:  <text selectable="true" decode="true">  A&gt;B  [环球时报-环球网报道 记者 郭媛丹 李司坤]9日上午，隶属美国海军的一架C-40运输机飞越台湾空域。</text> | wxss:  text{   line-height: 1.5em;   font-size:14px;  } |
| ------------------------------------------------------------ | ------------------------------------------------------- |
|                                                              |                                                         |

##### 4）<icon>组件

<icon>组件为图标组件，语法结构是：

  <icon type="类型" size="尺寸"  color="颜色"></icon>  类型有：success,成功warn,警告info,信息waiting,等待download,下载cancel,取消  search,搜索clear,清除  官方文档：https://developers.weixin.qq.com/miniprogram/dev/component/icon.html  

示例：

  wxml:  <icon type="success"></icon>  <icon type="warn"></icon>  <icon type="info"></icon>  <icon type="waiting"></icon>  <icon type="download"></icon>  <icon type="cancel"></icon>  

##### 5）<progress>组件

<progress>组件为进度条组件，其语法结构是:

  <progress   precent=""  show-info=" "  stroke-width=" "  activeColor=" "  ……  </progress>  官方文档：https://developers.weixin.qq.com/miniprogram/dev/component/progress.html  

示例：

  wxml:  <progress    percent="20"   show-info="true"   font-size="16"   stroke-width="5"   backgroundColor="#EBEBEB"   activeColor="#09BB07">    <icon type="success_no_circle"></icon>   </progress>  

##### 6）<navigator>组件

<navigator>组件为页面链接组件，其语法结构是：

  <navigator url="当前小程序内的跳转链接" open-type="跳转方式">  ...  </navigator>  官方文档：https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html  

注:

默认情况下URL属性只能跳转到没有包含在tabBar属性的页面上

open-type属性用于指定跳转方式

F switchTab，跳转到包含在tabBar属性的页面上(就是跳转到包含底部选项卡的页面)

F navigate

F redirect

F reLaunch

F navigateBack

示例：

  wxml:  <navigator url="/pages/index/index" open-type="switchTab">返回首页</navigator>  <navigator url="/pages/progress/progress">返回进度条页面  </navigator>  

##### 7）<button>组件

<button>组件为按钮组件，其语法结构是：

| <button       size="按钮尺寸(default\|mini)"       type="按钮类型(primary\|default\|warn)"      plain="是否镂空"      open-type="开启微信开放能力">      ...  </button>\ | open-type属性包括：  F contact,打开客服会话  F share,用户转发  F getPhoneNumber，获取用户手机号  F getUserInfo，获取用户信息  F openSetting,打开授权设置页  F launchApp，打开APP |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 官方文档：https://developers.weixin.qq.com/miniprogram/dev/component/button.html |                                                              |

示例：

  wxml:  <!--pages/button/button.wxml-->  <button size="default" type="primary">主要</button>  <button size="default" type="default">默认</button>  <button size="default" type="warn">警告</button>  <!-- 微信开放能力 -->  <button size="default" open-type="contact">打开客服会话</button>  <button size="default" open-type="share">用户转发</button>  <button size="default" open-type="getPhoneNumber">获取手机号</button>  <button size="default">获取用户信息</button>  <button size="default">打开授权页</button>  

##### 8）<input>组件

<input>组件为输入框组件，该原件为原生组件，其语法结构是：

| <input       type="输入框类型"       placeholder="占位符"       maxlength="最大输入长度"       focus="是否获取焦点"      password="是否为密码"  disabled="是否禁用">  </input> | 输入框的类型包括：  F text,文本输入键盘  F number,数字输入键盘  F idcard,身份证号输入键盘  F digit,带小数点输入数字键盘 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 官方文档：https://developers.weixin.qq.com/miniprogram/dev/component/input.html |                                                              |

示例：

  wxml:  输入留言:<input type="text"/>  输入手机号：<input type="number"/>  输入身份证号:<input type="idcard"/>  输入汇款金额:<input type="digit"/>  密码:<input type="number" password="true"/>  

##### 9）native-component 

原生组件：是由手机操作系统提供的组件。一般的WXSS样式对其无效，而且原生组件的z-index非常高，不能被小程序组件的z-index覆盖。

  小程序中的部分组件是由客户端创建的原生组件，这些组件有：  [camera](https://developers.weixin.qq.com/miniprogram/dev/component/camera.html)  [canvas](https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html)  [input](https://developers.weixin.qq.com/miniprogram/dev/component/input.html)（仅在focus时表现为原生组件）  [live-player](https://developers.weixin.qq.com/miniprogram/dev/component/live-player.html)  [live-pusher](https://developers.weixin.qq.com/miniprogram/dev/component/live-pusher.html)  [map](https://developers.weixin.qq.com/miniprogram/dev/component/map.html)  [textarea](https://developers.weixin.qq.com/miniprogram/dev/component/textarea.html)  [video](https://developers.weixin.qq.com/miniprogram/dev/component/video.html)     官方文档：  https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html    

### （7）wxml

l WXML(Weixin Markup Language):是微信的标记语言, 用于实现页面/组件的结构。

##### 1）数据绑定

WXML中所有的动态数据来源于对应page的data属性。

示例：

  Page({   data: {     username:"Tom",     password:"123"   }  })  

##### 2）内容绑定

  <component>{{variable}}</component>  

注:

双花括号内支持的运算符,包括：

算数运算符、字符运算符、逻辑运算符、比较运算符、三目运算符、对象属性运算符

示例：

| //js中data代码如下：  data: {     username:"Tom",     password:"123",     n:3,     m:5,     user:{       id:1,       name:'Rose'     }   } | //wxml的代码如下：  <text>用户名:{{username}}</text>  <text>密码:{{password}}</text>  <!-- 算数运算符 -->  <text>{{n + m }}</text>  <text>{{n - m }}</text>  <!-- 比较运算符 -->  <text>{{n > m }}</text>  <!-- 逻辑运算符 -->  <text>{{!(n > m) }}</text>  <!-- 三目运算符 -->  <text>{{ n > 0 ? "中国" : "法国"}}</text>  <!-- 对象属性运算符 -->  <text>{{user.name}}</text> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

##### 3）属性绑定

Vue中属性绑定是通过v-bind或简写为冒号(:)实现的，而小程序中仍然采用双花括号语法

  <component 属性名称="{{variable}}">...</component>  

示例：

| //JS代码如下：  data: {     username:"Tom",     password:"123",     n:3,     m:5,     user:{       id:1,       name:"Rose"     },     //用iconType变量控制图标的类型     iconType:"cancel"   } | //WXML代码如下：  <icon type="{{iconType}}"></icon> |
| ------------------------------------------------------------ | --------------------------------------------------- |
|                                                              |                                                     |

##### 4）样式绑定

绑定语法:

  <component style="{{variable}}">...</component>  <component class="{{variable}}">...</component>  

示例：

| //wxss的代码如下：  .red{   color:red;  }  .default{   color:#000;  } | //js代码如下：  data: {   //用className变量控制CSS类名称   className:'red'  } | //WXML代码如下：  <text class="{{className}}">  样式绑定</text> |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |                                                              |

##### 5）循环结构

循环结构语法

  <组件名称       wx:for="{{数组变量}}"       wx:for-item="数组当前项的名称"      wx:for-index="数组当前项的下标名称"      wx:key="指定唯一名称">      ...  </组件名称>  

示例1：

| data: {     //存储国家名称的数组     country:["中国","美国","法国","德国"]   } | 数组当前项的变量名称默认为item,当前项默认的下标为index  <text wx:for="{{country}}">  第{{index}}位的国家名称是:{{item}}  </text>  //此时会在调式工具显示警告信息 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

示例2：

  <!-- 版本1:沿用系统默认的当前项名称与下标 -->  <text wx:for="{{country}}" wx:key="index">  第{{index}}位的国家名称是:{{item}}</text>  <!-- 版本2:指定当前项的名称与下标 -->  <text wx:for="{{country}}"  wx:for-item="v"  wx:for-index="k">  第{{k}}位的国家名称是:{{v}}</text>  <!-- 版本3:指定当前项的名称、下标与key -->  <text wx:for="{{country}}"  wx:for-item="v"  wx:for-index="k"  wx:key="k">  第{{k}}位的国家名称是:{{v}} </text>  

示例3：

| data{   users:[    {    id:1,    username:"张三",    //true表示男,false表示女    sex:true    },    {    id:2,    username:"李四",    //true表示男,false表示女    sex:false    },    {    id:3,    username:"王五",    //true表示男,false表示女    sex:true    }   ]  } | <!-- 输出所有的用户信息 -->  <text wx:for="{{users}}">  {{item.id}}  --  {{item.username}}  --  {{item.sex ? "男" : "女"}}  </text> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

##### 6）分支结构

<组件名称 wx:if="{{条件表达式}}">...</组件名称>

<view wx:if="{{condition}}"> True </view>

<组件名称 wx:if="{{条件表达式}}">...</组件名称>

<组件名称 wx:elif="{{条件表达式}}">...</组件名称>

<组件名称 wx:else></组件名称>

```
<view wx:if="{{length > 5}}"> 1 </view>
```

```
<view wx:elif="{{length > 2}}"> 2 </view>
```

```
<view wx:else> 3 </view>
```

因为 `wx:if` 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 `` 标签将多个组件包装起来，并在上边使用 `wx:if` 控制属性。

```
<block wx:if="{{true}}">
```

```
  <view> view1 </view>
```

```
  <view> view2 </view>
```

```
</block>
```

注:`block`并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。

官方文档 https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html

##### 7）事件绑定

① 事件列表

|          | 浏览器事件                 | 移动端事件                                                   | 小程序事件                                                   |
| -------- | -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 键盘事件 | keydown、keyup、keypress   | 无                                                           | 无                                                           |
| 鼠标事件 | click、mouseover、mouseout | 无                                                           | 无                                                           |
| 页面事件 | load、unload               | load、unload                                                 | 无,通过生命周期钩子函数                                      |
| 触屏事件 | 无                         | touchstart,开始触屏  touchmove，触屏拖动  touchend,释放手指  touchcancel,触发被取消（来电话了）  tap,轻敲  longtap, 长敲(350ms) | touchstart,开始触屏  touchmove，触屏拖动  touchend,释放手指  touchcancel,触发被取消（来电话了）  tap,轻敲  longtap, 长敲(350ms)  longpress |

② 小程序中事件绑定

  <组件名称 bind事件名称="处理函数名称">...</组件名称>  <组件名称 bind:事件名称="处理函数名称">...</组件名称>  <组件名称 catch事件名称="处理函数名称">...</组件名称>  

示例1：

| <button bindtap="f1"></button>  提醒：微信小程序中的事件绑定时的函数名称**不能**带有小括号  问题：如何进行参数的传递呢？ |
| ------------------------------------------------------------ |
| <button bind:tap="f2">按钮</button>                          |
| <button catchtap="f3">按钮</button>   catch会阻止事件向上冒泡 |

tap、longtap、longpress之间的区别:

longtap事件会触发tap事件,longpress不会触发tap事件,建议使用longpress取代longtap。

##### 8）双向数据绑定

双向数据绑定针对表单控件。

步骤1：将Model中的数据绑定到View

 

步骤2：将View中的数据改变通知Model

 

Page实例中的setData()方法用于改变模型中的数据,语法结构是：

this.setData({...})

##### 9）事件对象

当组件触发事件时，逻辑层(page.js)绑定该事件的函数中就会接收一个事件对象.

该事件对象包括：type:事件类型，如tap、longtap等

① detail,自定义事件所携带的数据，如用户文本框中输入的数据,对象类型，结构如：

| {  value:"20",  cursor:1,  keyCode:50  } | 所以detail对象的value属性即表单控件输入的值！ |
| ---------------------------------------- | --------------------------------------------- |
|                                          |                                               |

② <block>标签：

| <block>  ...  </block> | block标签可以将某些组件包含在其中，目的是为了保证分支或循环结构的完整性，但不会在节点树中形成多余的标签。  dataset，用于获取组件上自定义属性的数据，对象类型 |
| ---------------------- | ------------------------------------------------------------ |
|                        |                                                              |

### （8）微信小程序中的交互

| showToast方法      | 用于显示短消息提示框  wx.showToast({  title:"提示文本"  icon:"图标(success\|loading\|none)"  image:"自定义图标"  duration:显示时长(1500ms)  }) |
| ------------------ | ------------------------------------------------------------ |
| wx.hideToast()方法 | 用于隐藏短消息提示框                                         |
| wx.showModal()     | 用于显示模态框                                               |
| wx.showLoading()   | 用于显示加载提示框                                           |
| wx.hideLoading()   | 用于隐藏加载提示框                                           |

### （9）小程序中应用(App, Application)与组件的生命周期函数

① 应用的生命周期钩子函数

应用的生命周期存储在app.js文件中，App()必须且只能被调用一次

| onLaunch() | 小程序初始化完成时触发，只触发一次                 |
| ---------- | -------------------------------------------------- |
| onShow()   | 小程序已启动，或者从后台切换到前台时触发，触发多次 |
| onHide()   | 小程序从前台切换到后台时触发，触发多次             |

② 页面的生命周期 – page.js

| onLoad(options) | 页面加载时触发，一个页面只会调用一次                         |
| --------------- | ------------------------------------------------------------ |
| onShow()        | 页面显示/切换到前台时触发，触发多次                          |
| onReady()       | 初始渲染完成后触发，只被触发一次                             |
| onHide()        | 页面隐藏/切换到后台时触发，触发多次                          |
| onUnload()      | 小程序的首页加载时触发的事件有  app.onLaunch->app.onShow->page.onLoad->page.onShow->page.onReady  在正常情况下切换到后台时，触发的事件有  page.onHide->app.onHide  在正常情况下切换到前台时，触发的事件有  app.onShow->page.onShow |

### （10）小程序中的页面跳转

① wx.navigateTo，导航到，保留跳转

| wx.navigateTo({  url:"URL地址"  }) | list(a,商品列表页面) navigateTo(导航到) detail(b,商品详情页面) list.onHide->detail.onLoad->detail.onShow->detail.onReady  如果此时点击小程序的"返回"，则触发的事件有：  detail.onUnload-->list.onShow |
| ---------------------------------- | ------------------------------------------------------------ |
|                                    |                                                              |

② wx.redirectTo，重定向到 – 销毁跳转

| wx.redirectTo({  url:"URL地址"  }) | list(a,商品列表页面) redirectTo(重定向到) detail(b,商品详情页面)  list.onUnload->detail.onLoad->detail.onShow->detail.onReady |
| ---------------------------------- | ------------------------------------------------------------ |
|                                    |                                                              |

③ wx.switchTab,切换到有标签页的页面

list(a,商品列表页面) switchTo(切换选项卡页面) index(b,首页)

如果list页面不存在选项卡的的话，则触发

list.onUnload->index.onLoad->index.onShow->index.onReady

④ wx.reLaunch,重新加载

list(a,商品列表页面) reLaunch(重新加载) list(a,商品列表页面)

list.onUnload->list.onLoad->list.onShow->list.onReady

强调：navigateTo()、redirectTo()方法只能跳转到没有标签页面的页面!!!

总结：

| navigateTo    | 当前页面 navigateTo 目标页面 => 保留跳转，结果:  当前页面隐藏，目标页面显示  如果要从"目标页面"返回"当前页面",则需要通过navigateBack()方法 |
| ------------- | ------------------------------------------------------------ |
| redirectTo    | 当前页面 redirectTo 目标页面 => 销毁跳转,结果：  当前页面销毁，目标页面显示  此时小程序将显示"首页"标志，点击该标志时导致：  "目标页面"销毁，首页显示 |
| switchTab     | 跳转到有标签的页面  目标页面是否销毁取决于目标页面是否也具备标签 |
| reLaunch      | 重新加载  当前页面销毁，目标页面显示                         |
| navigator组件 | <navigator url=""  open-type="跳转方式">...</navigator>      |

跳转方式包括：

navigate,等价于wx.navigateTo

redirect,等价于wx.redirecTo

switchTab,等价于wx.switchTab

reLaunch,等价于wx.reLaunch

### （11）小程序中请求外部数据

① 小程序对于访问的外部数据的进行了以下限制：

F 域名只支持 https

F 域名必须经过ICP备案

F 域名不能为本机IP地址

F 每个小程序最多可以配置20个域名，且必须保证域名已经在小程序控制台注册

② 配置小程序外部数据请求的域名

F 登录微信小程序开发者平台(https://mp.weixin.qq.com)

F 开发->开发设置

③ 小程序发送网络请求

  wx.request({      url:"URL地址",      data:请求参数(字符串或对象),      method:"请求方式(GET|POST|PUT|DELETE)",      success:(res)=>{         //成功时需要执行的回调函数(只要服务器存在返回信息即成功)      },      fail:(err)=>{         //失败时需要执行回调函数   },      complete:()=>{         //完成时需要执行的回调函数   }  })  

## 4、学子影院项目

学子影院的实现步骤

### （1）设置导航栏与底部选项卡（app.json）

代码如下：

  {   "pages":[    "pages/index/index",    "pages/ranking/ranking",    "pages/logs/logs"   ],   "window":{    "backgroundTextStyle":"light",    "navigationBarBackgroundColor": "#333333",    "navigationBarTitleText": "学子影院",    "navigationBarTextStyle":"white"   },   "tabBar": {    "color": "#888888",    "selectedColor": "#0aa1ed",    "list": [        {     "pagePath": "pages/index/index",     "text": "首页",     "iconPath": "images/home_disabled.png",     "selectedIconPath": "images/home_enabled.png"     },     {      "pagePath": "pages/ranking/ranking",      "text": "排行榜",      "iconPath": "images/ranking_disabled.png",      "selectedIconPath": "images/ranking_enabled.png"     }    ]   }  }  

### （2）设定全局样式（app.wxss）

其代码如下：

| /* 页面组件样式 */  page{   width: 100%;height: 100%;   background-color: #f9f9f9;  } | /* 外层容器的样式 */  .container{   height: 100%;   background-color: #333333;  } |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

### （3）学子影院首页（pages/index/index）

① index中轮播图效果的实现

F 轮播图数据应该为动态数据，那么也就意味着<swiper>标签内需要添加wx:for="{{变量名称}}"结构，所以必须在index.js的data中声明一个属性用于来存储轮播图的广告信息,而且该变量是数组类型）

F 此时变量为空数组，必须发送请求以获取豆瓣的最新上映的电影海报图片作为轮播图的图片

F 问题是：在什么情况下发送请求呢？

于是引申出 -- 页面的生命周期的钩子函数 (onLoad、onShow、onHide...)）

index.html和index.wxss代码如下

| <!-- 轮播图开始 -->  <view class="swiper">   <swiper autoplay="true" indicator-dots="true" circular="true">    <swiper-item         wx:for="{{swiperMovies}}"      wx:key="index">     <image src="{{item.images.large}}"></image>    </swiper-item>   </swiper>   </view>  <!-- 轮播图结束 --> | index.wxss中轮播图样式  /* 轮播图容器*/  .swiper swiper{   height:480rpx;  }  /* 轮播图图像 */  .swiper image{   display: block;   width: 100%;   height: 100%;  } |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

index.js代码如下：

  Page({  data: {    //存储轮播图的变量    swiperMovies:[]   },   onLoad: function () {    //获取轮播广告     wx.request({     url: 'https://api.douban.com/v2/movie/in_theaters?apikey=0df993c66c0c636e29ecbb5344252a4a&start=0&count=10',     method:'GET',     header:{      'content-type':'application/x-www-form-urlencoded'     },    success:(res)=>{     this.setData({      swiperMovies:res.data.subjects    })  }  });  

② 实现“正在上映”、“即将上映”，“TOP250”版块的布局

F “正在上映”、“即将上映”，“TOP250”的实现思路与轮播图是类似的

F 纵观整体的“正在上映”、“即将上映”，“TOP250”版块的结构是相同的，所以只需要完成一个完整的版块，其他版块即可实现。

F 当版块布局结构完成后，如何实现动态的数据？ 

-- 页面初始情况下就要显示相关的轮播图，正在上映、即将上映等的影片信息，所以仍需在Page对象的onLoad()生命周期钩子函数内完成异步向豆瓣服务器发送请求的业务!!!

F 实现步骤

\1.   Page对象的data中声明一个属性用于存储“正在上映”的影片信息

\2.   向豆瓣服务器发送GET请求，以获取“正在上映”的影片信息

\3.   数据获取到后，在页面中通过wx:for结构遍历页面组件

思考：

1.如何实现变量名称的动态化?或者说在setData中如何接收type参数来决定变量名称?

2.排行榜的数据如何实现动态化？ --> 来源于top250的API

3.在影片详情页面中显示不同影片的信息? --> Page 的onLoad()方法中存在一个options参数

### （4）影片排行榜的实现

① 实现页面的结构及样式

| <view class="container">  <!-- 电影列表开始 -->   <view class="list">  <!-- 影片信息开始 -->     <view class="item">    <!-- 影片海报开始 -->    <navigator url="/pages/detail/detail">      <image class="poster" src="https://img3.doubanio.com/view/photo/s_ratio_poster/public/p480747492.webp"></image>      </navigator>      <!-- 影片海报结束 -->    <!-- 影片信息开始 -->    <view class="meta">     <navigator url="/pages/detail/detail">      <text class="title">影片名称</text>     </navigator>     <text class="subTitle">英文名称(上映年份)</text>  <view class="directors">        导演：       <text>名称</text>      <text>名称</text>     </view>    </view>  <!-- 影片信息结束 -->      <!-- 影片评论开始 -->      <view class="rating">      <text>7.8</text>      </view>      <!-- 影片评论结束 -->    </view>    <!-- 影片信息结束 -->     </view>   <!-- 电影列表结束 -->  </view> | .item{   display: flex;    padding:20rpx 40rpx;   margin:20rpx;   background-color: #fff;   border-radius: 10rpx;  }  .poster{   flex: 1;   width:120rpx;   height:178rpx;   margin-right:20rpx;  }  .meta{flex: 4;}  .title{   display: block;   color:#000;   font-size:40rpx;   margin-bottom:20rpx;  }  .subTitle,.directors{   display: block;   color:#999;   font-size:24rpx;   margin-bottom:15rpx;  }  .rating{flex: 1;}  .rating text{   display: inline-block;   padding:10rpx;   background-color: #f9705a;   color:#fff;   border-radius: 10rpx;  } |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

② 如何实现动态的数据?也就是说在页面加载后要显示一部分的TOP250的影片信息，同样涉及到页面的生命周期钩子函数 – onLoad()

Ø 需要在Page的data属性中声明变量，用于存储获取到的影片信息，示例如下：

   data: {    //存储电影排行榜的影片数据    movies:[]},  

Ø 刚刚分析后得到，应该在onLoad()钩子函数中异步获取豆瓣的TOP250的部分数据，示例代码如下：***(\******后续还要调整)\***

  onLoad: function (options) {    wx.request({     url: 'https://api.douban.com/v2/movie/top250?apikey=0df993c66c0c636e29ecbb5344252a4a&start=20&count=10',     method:'GET',     header:{     'content-type':'application/x-www-form-urlencoded'    },    success:(res)=>{     this.setData({      movies:res.data.subjects     });    }   })  },  

### （5）页面传参

现在在index.wxml和ranking.wxml中都存在<navigator>组件，并且都链接到pages/detail/detail页面，而在这个页面中要显示不同的影片的详细信息，所以必须想办法，在链接时将影片的ID传递到pages/detail/detail页面中来，才可以获取到影片的详细信息 --- 涉及到的问题是怎么样将ID传递？ -- **URL****地址栏**,如

<navigator url="/pages/detail/detail?id=1&mid=2&pid=3">导航到详情面</navigator>

当把参数传递到目标页面后，引申出—如何在目标页面中接收？

 -- onLoad()钩子函数中的options参数！！！

传参方式

| 同一页面内                                                   | 不同页面内                                 |
| ------------------------------------------------------------ | ------------------------------------------ |
| 组件存在自定义属性  <image  data-id="5" bindtap="delete">删除</image>  e.target.dataset.id  表单控件  <input  type="text" bindinput="f1"></input>                                    作业：      1.必须保证在总页数范围内可向下拖动时发送请求      2.9如何变成9.0                           f1(e){  this.setData({  username:e.detail.value  })    } | 地址栏传递，形如  pages/detail/detail?id=6 |

## 5、小程序的云开发

### （1）云开发的基础

 

小程序的云开发提供的服务类型有：

| 云存储   | 相当于网盘，可以在其中存储任意的图片、音频、视频等资源 |
| -------- | ------------------------------------------------------ |
| 云数据库 | 是一个专为小程序使用的JSON数据库                       |
| 云函数   | 可以提供更为复杂的服务器的扩展功能                     |

开通云开发

\1. 单击开发工具栏中的“云开发”按钮

 

\2. 在开通云开发的对话框中输入环境名称及环境ID

​     

​        说明：    1.       每个小程序最多只能开通两个云服务（工具栏中“云开发”->设置->环境名称->创建新环境）    2.       每个云服务中包含三种服务：云存储、云数据库、云函数    3.       小程序只能使用自己关联的云服务器，协议前缀为cloud://    4.       云服务一旦指定，无法修改                     

 



### （2）云存储

将云存储想像成网盘，用于存储小程序使用资源文件（如图片，音频、视频等），其资源文件的访问可以通过：

① 直接通过云开发控制台实现（图形化管理界面）

 

<image src="cloud://web-mx-wuhua-gn0n3.7765-web-mx-wuhua-gn0n3-1301465321/images/2.jpg">

</image>

② 通过JS脚本实现

Ø 通过wx.chooseImage()方法选择图像

  wx.chooseImage({  count:指定图像的数量  sourceType:"图像来源(['album',  'camera'])",  success:(result)=>{  ...  }  })  

Ø 通过wx.cloud.uploadFile()方法将文件上传到云存储

  wx.cloud.uploadFile({  filePath:"本地文件路径",  cloudPath:"云存储的路径及名称",  success:(res)=>{  ...  }  })  

### （3）云数据库

云数据库既可以在小程序的前端，也可以在云函数中读写数据的JSON类型数据库。其底层为MongoDB – 非关系型的数据库

① 关系型数据库与非关系型数据库的区别

| 关系型数据库                                                 | 非关系型数据库                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 常用的DBMS:  MySQL、SQL Server、Oracle                       | 常用的NoSQL(Not  Only SQL)：  MongoDB、Redis                 |
| 核心概念：  数据库(Database)->数据表(Table)->列(Column)->行(Row) | 核心概念:  数据库(Database)->集合(Collection)->字段(Field)->Record(记录)/Document(文档) |
| 记录的结构 -- users  id   username  age   salary  1    Tom   25    27896.33  2    Rose   21    29896.33 | [  {  "username":"Rose",   "age":23,   "birthday":new Date(2000-1-1)  },  {   "username":"Rose",   "birthday":new Date(2000-1-1)   "sex":true,    "friends":[    {       "name":"张三"     },     {       "name":"李四"     }   ]  }  ] |
| 数据类型：  整型、浮点型、字符型、布尔型                     | 数据类型：  字符型、数值型、布尔型、数组、对象               |
| 操作命令：  所有的关系型数据库的查询命令来源于SQL规范，比较有名的扩展：  SQL Server -> T-SQL  Oralce -> PL/SQL | 操作命令：  不尽相同                                         |
| 关系的维护：  通过外键实现                                   | 关系的维护  不存在关系的概念                                 |

② 云数据库的管理 – 图形化界面(云开发控制台)

\1. 进入云开发控制台后，单击“数据库”图标，即进入到数据库中

\2. 单击“集合列表”中的“+”号，增加集合

\3. 单击"添加记录"/"导入"以添加/导入记录

\3. 如有需要，则必须设置数据的访问权限

 

③ 云数据库的管理 – 命令(小程序客户端)

² 建立数据库连接 – 返回Database对象

  let db = wx.cloud.database();

² Database对象的collection()方法

Collection对象 数据库对象.collection("集合名称")

④ 云数据库操作

\1.   记录的查找 – 条件表达式(参见思维导图)

wx.cloud.database().collection("comments").where({

​       字段名称:运算符对象(通过"数据库实例.command"来得到)
 });

\2.   增加记录—通过Collection()对象的add()方法实现，语法结构是：

collection对象.add({

​    data:{

​       ...

​    }

})

\3.   更新记录—通过Collection()对象的update()方法实现，语法结构是：

Collection.update({

​    data:{

​       ...

​    }

})

说明:

A.注意权限问题

B.注意基础库版本 – ^2.10

也可以通过Document对象的update()或set()方法,其中set()方法用于实现替换更新,这两个方法的共同点是：只更新一条记录

\4.   删除记录—通过Collection对象的remove()方法或Document对象的remove()方法实现

Collection对象的remove()方法必须带有where()条件，且与基础库版本关系密切,语法结构为：

Collection.where(...).remove({

​    sucess:(res)=>{

​       ...

​    }

})

说明：

基础库版本^2.10只能删除一条记录，否则将抛出异步（此时只能通过云函数实现删除操作）

### （4）云函数

云函数就是在腾讯云运行的针对小程序的自定义函数。

① 创建云函数：在小程序项目中创建云函数

   

 

A.   编写自定义函数的代码，结构如:

exports.main = async (param, context) => {

 //param代表的自定义函数的参数形成的对象

 return param.a1 + param.a2;

}

其中param代表所有的参数形成的对象！！！

B.   将本地的云函数上传到云服务器

 

 

C.   在小程序中调用云服务器中的云函数，语法结构如下：

wx.cloud.callFunction({

​    name:"云函数名称",

​    data:{云函数的参数形成的对象},

​    success:(res)=>{

​       ...

​    }

})

② 云函数是运行在云服务器的Node.js环境中。可以通过第三方模块 request-promise实现云函数的异步请求。实现步骤：

A.   在云函数的目录下(package.json文件所在的目录)执行

npm install –save request-promise

该语句真实目的是为了让package.json中添加依赖关系

B.   编写云函数，示例代码如下：

  // 云函数入口文件  const cloud = require('wx-server-sdk')  //加载request-promise模块  const rp = require('request-promise');     cloud.init()     // 云函数入口函数  exports.main = async (event, context) => {   let url = "http://101.96.128.94:9999/data/product/list.php?pno=2";   return rp.get(url);  }  

重新部署到云服务器上

C.   在微信小程序中调用云函数即可。

## 6、WXS

WXS(Weixin Script) 微信脚本，与ES基本相同

### （1）WXS模块

① 创建WXS模块

\1. 创建以".wxs"为扩展名的模块文件,示例代码如下：

  var numberUtil = {    numberFormat:function(value){     var v = parseInt(value);     return v.toFixed(2);    }  }     module.exports = {   numberFormat:numberUtil.numberFormat  }  

\2. 在页面组件通过<wxs>标签引入WXS模块，类似于<script src="xxx.js"></script>

<wxs src="WXS模块文件的位置及名称" module="模块名称"></wxs>

  <wxs src="../../utils/utils.wxs" module="numberUtil"></wxs>  <text>{{numberUtil.numberFormat(9)}}</text>  <text>{{numberUtil.numberFormat(9.1)}}</text>  

 

 

 









