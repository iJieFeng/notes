# 浏览器的进程模型

## 什么是进程

程序运行需要有它自己专属的内存空间，可以把这块空间简单理解为进程。

每个应用至少有一个进程，进程之间相互独立，可以通信，要双方同意。

<img src="C:\Users\jiefe\AppData\Roaming\Typora\typora-user-images\image-20231019110742976.png" style="zoom: 50%;" />

## 什么是线程

有了进程后，就可以运行程序的代码了。

运行代码的 `人` 称之为线程。

一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。

如果程序需要同时执行多块代码，主线程就会启用更多的线程来执行代码，所以一个进程中可以包含多个线程。

<img src="C:\Users\jiefe\AppData\Roaming\Typora\typora-user-images\image-20231019112019822.png" alt="image-20231019112019822" style="zoom:50%;" />

## 浏览器的进程和线程

**浏览器是一个多进程多线程的应用程序**

<img src="C:\Users\jiefe\AppData\Roaming\Typora\typora-user-images\image-20231019114140725.png" alt="image-20231019114140725" style="zoom:67%;" />

<img src="C:\Users\jiefe\AppData\Roaming\Typora\typora-user-images\image-20231019114055491.png" alt="image-20231019114055491" style="zoom: 80%;" />

**渲染进程** 负责执行HTML、CSS、JS代码，默认情况下，浏览器会为每一个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。



# 事件循环

渲染主线程处理的任务包括但不限于：

- 解析HTML
- 解析CSS
- 计算样式
- 处理图层
- 每秒把页面画画60次
- 执行全局js代码
- 执行事件处理函数
- 执行计时器的回调函数
- ......

渲染主线程执行任务的方式：**事件循环** event loop

1. 在最开始的时候，渲染主线程会进入到一个无限循环
2. 每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环，如果没有就进入休眠状态。
3. 其他所有线程可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒继续循环任务。

<img src="C:\Users\jiefe\AppData\Roaming\Typora\typora-user-images\image-20231019115246101.png" alt="image-20231019115246101" style="zoom:67%;" />

## 异步

代码执行过程中，会遇到一些无法立即处理的任务，比如：

- 计时完成后需要执行的任务 -- setTimeout、setInterval
- 网络通信完成后需要执行的任务 -- XHR、Fetch
- 用户操作后需要执行的任务 -- addEventListener

如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于 `阻塞` 的状态，从而导致浏览器 `卡死`

<img src="C:\Users\jiefe\AppData\Roaming\Typora\typora-user-images\image-20231019121056474.png" alt="image-20231019121056474" style="zoom:67%;" />

为了解决这个阻塞问题，浏览器选择 **异步** 来解决这个问题

<img src="C:\Users\jiefe\AppData\Roaming\Typora\typora-user-images\image-20231019125620221.png" alt="image-20231019125620221" style="zoom:67%;" />



> 面试题目： **如何理解js的异步**？

> js是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。
>
> 而渲染主线程承担着诸多的工作，渲染页面，执行js 都在其中运行。
>
> 如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。
>
> 所以浏览器采用异步的方式来避免，具体做法就是当某些任务发生时，比如计时器，网络，事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续的代码，当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。
>
> 在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。



> 面试题：*js为何会阻碍页面渲染*

> 参考答案：页面渲染和js都在浏览渲染主线程中执行。

```html
<h1>good morning</h1>
<button>change</button>
```

```js
var h1 = document.querySelector('h1')
var btn = document.querySelector('button')
// 死循环指定的时间
function delay(duration) {
    var start = Date.now()
    while (Date.now() - start < duration) {}
}
btn.onclick = function () {
    h1.textContent = 'good evening'
 	delay(3000)
}
```

上述代码中，点击按钮，不会立马修改页面中的文字，而是会产生一个渲染页面的任务，此时渲染主线程还有一个等待3s的任务需要执行，所以3s后才执行渲染任务改变页面中的文字。



## 任务优先级

浏览器渲染主线程中的任务是没有优先级的，在消息队列中先进先出

但 **消息队列是有优先级的**

- 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。

- 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行

  https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint

目前 chrome 中，至少包含下面队列

- 延时队列：用于存放计时器到达后的回调任务，优先级中
- 交互队列：用户存放用户操作后产生的事件处理任务，优先级高
- 微队列：用户存放需要最快执行的任务，优先级最高

添加任务到微队列的主要方式主要是使用 Promise、MutationObserver， process.nextTick(Node.js 环境)

```js
// 立即把一个函数添加到微队列
Promise.resolve().then(函数)
```

<img src="C:\Users\jiefe\AppData\Roaming\Typora\typora-user-images\image-20231019145022543.png" alt="image-20231019145022543" style="zoom:67%;" />

```js
async function Prom() {
  console.log('Y')
  await Promise.resolve()
  console.log('X')
}

setTimeout(() => {
  console.log(1)
  Promise.resolve().then(() => {
    console.log(2)
  })
}, 0)

setTimeout(() => {
  console.log(3)
  Promise.resolve().then(() => {
    console.log(4)
  })
}, 0)

Promise.resolve().then(() => {
  console.log(5);
})

Promise.resolve().then(() => {
  console.log(6);
})

Promise.resolve().then(() => {
  console.log(7);
})

Promise.resolve().then(() => {
  console.log(8);
})

Prom()

console.log(0);

// Y 0 5 6 7 8 X 1 2 3 4
```



> 面试题：阐述一下 js 的事件循环

> 参考答案：
>
> 事件循环又叫消息循环，是浏览器渲染主线程的工作方式
>
> 在chrome的源码中，它开启了一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列的末尾即可。
>
> 过去把消息队列简单分为宏任务和微任务，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更灵活多变的处理方式。
>
> 根据w3c官方的解释，每个任务又不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列，不同的任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定有最高的优先级，必须优先执行。



> 面试题：js中的计时器能做到精确计时吗？为什么

> 答案：不行，因为
>
> 1. 操作系统的计时函数本身就有少量偏差，由于js的计时器最终调用的是操作系统的函数，也就携带了这些偏差。
> 2. 按照w3c的标准，浏览器实现计时器时，如果嵌套超过5层，则会携带有4毫秒的最少事件，这样在计时时间少于4毫秒时又带来了偏差。
>
> 3. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，会有偏差。



总结

- js是单线程语言

- js运行在浏览器的渲染主线程上，渲染主线程只有一个

- 渲染主线程不能是多线程，是因为如果不同线程在同一时间操作相同的DOM，页面就不知道该如何展示了

- 因为单线程，渲染主线程上的所有任务都需要排队

- 执行任务的过程会遇到一些无法立即处理的任务，如计时器，网络，事件监听，

- 如果让主线程等待这些任务，就会导致主线程产生阻塞，浏览器卡死

- 为了解决阻塞的问题，就有了异步（单线程是异步产生的原因）

  主线程将这些无法立即执行的任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续的代码，当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。

- 事件循环是异步的实现方式

  浏览器会开启了一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列的末尾即可。

  过去把消息队列简单分为宏任务和微任务，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更灵活多变的处理方式。

  根据w3c官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列，不同的任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定有最高的优先级，必须优先执行。

  











